From aa9ac6429021f6cadd6f169981c05364c24d1542 Mon Sep 17 00:00:00 2001
From: "H.J. Lu" <hjl.tools@gmail.com>
Date: Sun, 18 Apr 2021 06:09:42 -0700
Subject: [PATCH 08/10] Backport LAM patches to 2.33

---
 ...ARCH_CET_ALLOC_SHSTK-with-PROT_SHSTK.patch |  571 ++++++++
 ...-tst-sigreturn-1.c-from-Linux-kernel.patch | 1113 ++++++++++++++++
 ...ter-to-cast-an-integer-to-void-point.patch |   28 +
 ...-wrapper-for-clone-clone2-and-clone3.patch |  350 +++++
 ...ays-pass-stack-size-to-create_thread.patch |  177 +++
 0006-x86-64-Add-the-clone3-wrapper.patch      |  127 ++
 ...dd-static-tests-for-__clone_internal.patch |  517 ++++++++
 ...LIBC_PRIVATE-Export-__clone_internal.patch |   24 +
 ...-address.h-An-API-for-tagged-address.patch | 1174 +++++++++++++++++
 ...HREAD_SETMEM-THREAD_SETMEM_NC-for-mo.patch |  143 ++
 ...U_PROPERTY_X86_FEATURE_1_LAM_U-48-57.patch |   27 +
 0012-Initial-enable-lam.patch                 |  511 +++++++
 ...-Rename-dl-cet.-ch-to-dl-feature.-ch.patch |  253 ++++
 ...-prctl.h-to-support-both-CET-and-LAM.patch |  286 ++++
 ...feature-control-and-tunables-for-LAM.patch |  147 +++
 0016-x86-Update-feature-disable-for-LAM.patch |  118 ++
 ...mpatible-string-functions-at-run-tim.patch |  239 ++++
 ...-Modularize-sysdeps-x86-dl-feature.c.patch |  516 ++++++++
 0019-x86-Enable-LAM-feature.patch             |  975 ++++++++++++++
 0020-Backport-x86-Enable-LAM-feature.patch    |  268 ++++
 0021-x86-Make-memmove-LAM-compliant.patch     |  131 ++
 ...s-tagged-address.h-in-some-LAM-tests.patch |  936 +++++++++++++
 0023-Add-test-memmove-lam_u57.c.patch         |   85 ++
 ...prove-string-test-memmove.c-coverage.patch |   83 ++
 glibc.spec                                    |   27 +
 25 files changed, 8826 insertions(+)
 create mode 100644 0001-x86-Replace-ARCH_CET_ALLOC_SHSTK-with-PROT_SHSTK.patch
 create mode 100644 0002-x86-Add-tst-sigreturn-1.c-from-Linux-kernel.patch
 create mode 100644 0003-Add-cast_to_pointer-to-cast-an-integer-to-void-point.patch
 create mode 100644 0004-Add-an-internal-wrapper-for-clone-clone2-and-clone3.patch
 create mode 100644 0005-nptl-Always-pass-stack-size-to-create_thread.patch
 create mode 100644 0006-x86-64-Add-the-clone3-wrapper.patch
 create mode 100644 0007-Add-static-tests-for-__clone_internal.patch
 create mode 100644 0008-GLIBC_PRIVATE-Export-__clone_internal.patch
 create mode 100644 0009-sys-tagged-address.h-An-API-for-tagged-address.patch
 create mode 100644 0010-x86_64-Correct-THREAD_SETMEM-THREAD_SETMEM_NC-for-mo.patch
 create mode 100644 0011-Add-GNU_PROPERTY_X86_FEATURE_1_LAM_U-48-57.patch
 create mode 100644 0012-Initial-enable-lam.patch
 create mode 100644 0013-Rename-dl-cet.-ch-to-dl-feature.-ch.patch
 create mode 100644 0014-x86-Update-prctl.h-to-support-both-CET-and-LAM.patch
 create mode 100644 0015-x86-Update-feature-control-and-tunables-for-LAM.patch
 create mode 100644 0016-x86-Update-feature-disable-for-LAM.patch
 create mode 100644 0017-Disable-LAM-incompatible-string-functions-at-run-tim.patch
 create mode 100644 0018-x86-Modularize-sysdeps-x86-dl-feature.c.patch
 create mode 100644 0019-x86-Enable-LAM-feature.patch
 create mode 100644 0020-Backport-x86-Enable-LAM-feature.patch
 create mode 100644 0021-x86-Make-memmove-LAM-compliant.patch
 create mode 100644 0022-Use-sys-tagged-address.h-in-some-LAM-tests.patch
 create mode 100644 0023-Add-test-memmove-lam_u57.c.patch
 create mode 100644 0024-Improve-string-test-memmove.c-coverage.patch

diff --git a/0001-x86-Replace-ARCH_CET_ALLOC_SHSTK-with-PROT_SHSTK.patch b/0001-x86-Replace-ARCH_CET_ALLOC_SHSTK-with-PROT_SHSTK.patch
new file mode 100644
index 0000000..bfec35c
--- /dev/null
+++ b/0001-x86-Replace-ARCH_CET_ALLOC_SHSTK-with-PROT_SHSTK.patch
@@ -0,0 +1,571 @@
+From 7608fc6094cb55221fdd1711082df51733a4a011 Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Sat, 15 Aug 2020 08:04:23 -0700
+Subject: [PATCH 01/24] x86: Replace ARCH_CET_ALLOC_SHSTK with PROT_SHSTK
+
+Since the upstream kernel will support shadow stack allocation with
+PROT_SHSTK, remove ARCH_CET_ALLOC_SHSTK and add __allocate_shadow_stack
+to use PROT_SHSTK.
+
+Also rename ARCH_CET_XXX to ARCH_X86_CET_XXX to match the upstream kernel
+header file.
+---
+ sysdeps/unix/sysv/linux/i386/getcontext.S     |  2 +-
+ sysdeps/unix/sysv/linux/i386/makecontext.S    | 88 +++++++------------
+ sysdeps/unix/sysv/linux/i386/swapcontext.S    |  2 +-
+ sysdeps/unix/sysv/linux/x86/Makefile          |  1 +
+ .../sysv/linux/x86/allocate-shadow-stack.c    | 75 ++++++++++++++++
+ .../sysv/linux/x86/allocate-shadow-stack.h    | 27 ++++++
+ sysdeps/unix/sysv/linux/x86/bits/mman.h       |  1 +
+ sysdeps/unix/sysv/linux/x86/cpu-features.c    |  3 +-
+ sysdeps/unix/sysv/linux/x86/dl-cet.h          |  4 +-
+ .../unix/sysv/linux/x86/include/asm/prctl.h   | 15 ++--
+ .../sysv/linux/x86/tst-cet-setcontext-1.c     |  2 +-
+ .../unix/sysv/linux/x86_64/__start_context.S  | 38 ++------
+ sysdeps/unix/sysv/linux/x86_64/getcontext.S   |  2 +-
+ sysdeps/unix/sysv/linux/x86_64/makecontext.c  | 29 +++---
+ sysdeps/unix/sysv/linux/x86_64/swapcontext.S  |  2 +-
+ 15 files changed, 174 insertions(+), 117 deletions(-)
+ create mode 100644 sysdeps/unix/sysv/linux/x86/allocate-shadow-stack.c
+ create mode 100644 sysdeps/unix/sysv/linux/x86/allocate-shadow-stack.h
+
+diff --git a/sysdeps/unix/sysv/linux/i386/getcontext.S b/sysdeps/unix/sysv/linux/i386/getcontext.S
+index 95e8d06dd1..61c0195b33 100644
+--- a/sysdeps/unix/sysv/linux/i386/getcontext.S
++++ b/sysdeps/unix/sysv/linux/i386/getcontext.S
+@@ -63,7 +63,7 @@ ENTRY(__getcontext)
+ 	   been recorded yet.  */
+ 	sub	$24, %esp
+ 	mov	%esp, %ecx
+-	movl	$ARCH_CET_STATUS, %ebx
++	movl	$ARCH_X86_CET_STATUS, %ebx
+ 	movl	$__NR_arch_prctl, %eax
+ 	ENTER_KERNEL
+ 	testl	%eax, %eax
+diff --git a/sysdeps/unix/sysv/linux/i386/makecontext.S b/sysdeps/unix/sysv/linux/i386/makecontext.S
+index 059fa5a95e..3609fff7ac 100644
+--- a/sysdeps/unix/sysv/linux/i386/makecontext.S
++++ b/sysdeps/unix/sysv/linux/i386/makecontext.S
+@@ -74,28 +74,37 @@ ENTRY(__makecontext)
+ 	testl	$X86_FEATURE_1_SHSTK, %gs:FEATURE_1_OFFSET
+ 	jz	L(skip_ssp)
+ 
+-	/* Reload the pointer to ucontext.  */
+-	movl	4(%esp), %eax
++	/* Shadow stack is enabled.  Load the pointer to ucontext in
++	   ECX.  */
++	movl	4(%esp), %ecx
++
++	/* Pass the address of __ssp[1] in EDX.  */
++	leal	(oSSP + 4)(%ecx), %edx
++	/* Pass stack size in EAX.  */
++	movl	oSS_SIZE(%ecx), %eax
++
++	/* Call __allocate_shadow_stack to allocate a new shadow stack.  */
++	call	__allocate_shadow_stack
++	/* Check for error return.  */
++	testl	%eax, %eax
++	jne	L(hlt)		/* This should never happen.  */
+ 
+-	/* Shadow stack is enabled.  We need to allocate a new shadow
+-	   stack.  */
+-	subl	oSS_SP(%eax), %edx
+-	shrl	$STACK_SIZE_TO_SHADOW_STACK_SIZE_SHIFT, %edx
++	/* Reload the pointer to ucontext into ECX.  */
++	movl	4(%esp), %ecx
+ 
+-	/* Align shadow stack size to 8 bytes.  */
+-	addl	$7, %edx
+-	andl	$-8, %edx
++	/* Load the base address of the new shadow stack into EAX.  */
++	movl	(oSSP + 4)(%ecx), %eax
+ 
+-	/* Store shadow stack size in __ssp[2].  */
+-	movl	%edx, (oSSP + 8)(%eax)
++	/* Store the new shadow stack pointer, the shadow stack base +
++	   the shadow stack size - 4, in __ssp[0].  */
++	addl	(oSSP + 8)(%ecx), %eax
++	subl	$4, %eax
++	movl	%eax, oSSP(%ecx)
+ 
+ 	/* Save ESI in the second scratch register slot.  */
+-	movl	%esi, oSCRATCH2(%eax)
++	movl	%esi, oSCRATCH2(%ecx)
+ 	/* Save EDI in the third scratch register slot.  */
+-	movl	%edi, oSCRATCH3(%eax)
+-
+-	/* Save the pointer to ucontext.  */
+-	movl	%eax, %edi
++	movl	%edi, oSCRATCH3(%ecx)
+ 
+ 	/* Get the original shadow stack pointer.  */
+ 	rdsspd	%esi
+@@ -105,7 +114,7 @@ ENTRY(__makecontext)
+ 	andl	$-8, %esi
+ 
+ 	/* Load the top of the new stack into EDX.  */
+-	movl	oESP(%eax), %edx
++	movl	oESP(%ecx), %edx
+ 
+ 	/* We need to terminate the FDE here because the unwinder looks
+ 	   at ra-1 for unwind information.  */
+@@ -119,39 +128,14 @@ ENTRY(__makecontext)
+ 	   onto stack.  */
+ 	addl	$4, %esp
+ 
+-	/* Allocate the new shadow stack.  Save EBX in the first scratch
+-	   register slot.  */
+-	movl	%ebx, oSCRATCH1(%eax)
+-
+-	/* CET syscall takes 64-bit sizes.  */
+-	subl	$16, %esp
+-	movl	(oSSP + 8)(%eax), %ecx
+-	movl	%ecx, (%esp)
+-	movl	$0, 4(%esp)
+-	movl	%ecx, 8(%esp)
+-	movl	$0, 12(%esp)
+-	movl	%esp, %ecx
+-
+-	movl	$ARCH_CET_ALLOC_SHSTK, %ebx
+-	movl	$__NR_arch_prctl, %eax
+-	ENTER_KERNEL
+-	testl	%eax, %eax
+-	jne	L(hlt)		/* This should never happen.  */
+-
+-	/* Copy the base address of the new shadow stack to __ssp[1].  */
+-	movl	(%esp), %eax
+-	movl	%eax, (oSSP + 4)(%edi)
+-
+-	addl	$16, %esp
++	/* Load the new shadow stack base in __ssp[1] into EAX.  */
++	movl	(oSSP + 4)(%ecx), %eax
+ 
+-	/* Restore EBX from the first scratch register slot.  */
+-	movl	oSCRATCH1(%edi), %ebx
+-
+-	/* Get the size of the new shadow stack.  */
+-	movl	(oSSP + 8)(%edi), %ecx
++	/* Load the new shadow stack size in __ssp[2] into EDI.  */
++	movl	(oSSP + 8)(%ecx), %edi
+ 
+ 	/* Use the restore stoken to restore the new shadow stack.  */
+-	rstorssp -8(%eax, %ecx)
++	rstorssp -8(%eax, %edi)
+ 
+ 	/* Save the restore token at the next 8 byte aligned boundary
+ 	   on the original shadow stack.  */
+@@ -163,27 +147,21 @@ ENTRY(__makecontext)
+ 	jmp	L(exitcode)
+ 1:
+ 
+-	/* Get the new shadow stack pointer.  */
+-	rdsspd	%eax
+-
+ 	/* Use the restore stoken to restore the original shadow stack.  */
+ 	rstorssp -8(%esi)
+ 
+ 	/* Save the restore token on the new shadow stack.  */
+ 	saveprevssp
+ 
+-	/* Store the new shadow stack pointer in __ssp[0].  */
+-	movl	%eax, oSSP(%edi)
+-
+ 	/* Restore the original stack.  */
+ 	mov	%edx, %esp
+ 
+ 	cfi_startproc
+ 
+ 	/* Restore ESI from the second scratch register slot.  */
+-	movl	oSCRATCH2(%edi), %esi
++	movl	oSCRATCH2(%ecx), %esi
+ 	/* Restore EDI from the third scratch register slot.  */
+-	movl	oSCRATCH3(%edi), %edi
++	movl	oSCRATCH3(%ecx), %edi
+ 
+ 	ret
+ 
+diff --git a/sysdeps/unix/sysv/linux/i386/swapcontext.S b/sysdeps/unix/sysv/linux/i386/swapcontext.S
+index 369c22f7f2..e9111d5d19 100644
+--- a/sysdeps/unix/sysv/linux/i386/swapcontext.S
++++ b/sysdeps/unix/sysv/linux/i386/swapcontext.S
+@@ -91,7 +91,7 @@ ENTRY(__swapcontext)
+ 	   been recorded yet.  */
+ 	sub	$24, %esp
+ 	mov	%esp, %ecx
+-	movl	$ARCH_CET_STATUS, %ebx
++	movl	$ARCH_X86_CET_STATUS, %ebx
+ 	movl	$__NR_arch_prctl, %eax
+ 	ENTER_KERNEL
+ 	testl	%eax, %eax
+diff --git a/sysdeps/unix/sysv/linux/x86/Makefile b/sysdeps/unix/sysv/linux/x86/Makefile
+index 6bfd6bec49..6ba85d5c76 100644
+--- a/sysdeps/unix/sysv/linux/x86/Makefile
++++ b/sysdeps/unix/sysv/linux/x86/Makefile
+@@ -46,6 +46,7 @@ CFLAGS-tst-cet-vfork-1.c += -mshstk
+ endif
+ 
+ ifeq ($(subdir),stdlib)
++sysdep_routines += allocate-shadow-stack
+ tests += tst-cet-setcontext-1
+ CFLAGS-tst-cet-setcontext-1.c += -mshstk
+ endif
+diff --git a/sysdeps/unix/sysv/linux/x86/allocate-shadow-stack.c b/sysdeps/unix/sysv/linux/x86/allocate-shadow-stack.c
+new file mode 100644
+index 0000000000..a90a09515a
+--- /dev/null
++++ b/sysdeps/unix/sysv/linux/x86/allocate-shadow-stack.c
+@@ -0,0 +1,75 @@
++/* Helper function to allocate shadow stack.
++   Copyright (C) 2020 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <sysdep.h>
++#include <stdint.h>
++#include <errno.h>
++#include <sys/mman.h>
++#include <libc-pointer-arith.h>
++#include <allocate-shadow-stack.h>
++
++/* NB: This can be treated as a syscall by caller.  */
++
++#ifndef __x86_64__
++__attribute__ ((regparm (2)))
++#endif
++long int
++__allocate_shadow_stack (size_t stack_size,
++			 shadow_stack_size_t *child_stack)
++{
++  long int ret;
++  size_t shadow_stack_size
++    = stack_size >> STACK_SIZE_TO_SHADOW_STACK_SIZE_SHIFT;
++  /* Align shadow stack to 8 bytes.  */
++  shadow_stack_size = ALIGN_UP (shadow_stack_size, 8);
++  /* NB: Must use __mmap (see mmap64.c and mmap.c).  */
++  void *shadow_stack = __mmap (0, shadow_stack_size,
++			       PROT_READ | PROT_WRITE,
++			       MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
++  /* Report the mmap error.  */
++  if (shadow_stack == MAP_FAILED)
++    return -errno;
++
++  void *shadow_stack_top = shadow_stack + shadow_stack_size;
++
++  /* Shadow stack restore token.  */
++  uint64_t shadow_stack_token = (uintptr_t) shadow_stack_top;
++#ifdef __x86_64__
++  shadow_stack_token |= 1;
++#endif
++
++  /* Store shadow stack restore token at the top of shadow stack.  */
++  *(uint64_t *) (shadow_stack_top - 8) = shadow_stack_token;
++
++  /* Enable shadow stack with PROT_SHSTK.  */
++  ret = (long) INTERNAL_SYSCALL_CALL (mprotect, shadow_stack,
++				      shadow_stack_size,
++				      PROT_READ | PROT_SHSTK);
++  if (INTERNAL_SYSCALL_ERROR_P ((uintptr_t) ret))
++    {
++      INTERNAL_SYSCALL_CALL (munmap, shadow_stack, shadow_stack_size);
++      /* Report the mprotect error.  */
++      return ret;
++    }
++
++  /* Save the shadow stack base and size on child stack.  */
++  child_stack[0] = (uintptr_t) shadow_stack;
++  child_stack[1] = shadow_stack_size;
++
++  return 0;
++}
+diff --git a/sysdeps/unix/sysv/linux/x86/allocate-shadow-stack.h b/sysdeps/unix/sysv/linux/x86/allocate-shadow-stack.h
+new file mode 100644
+index 0000000000..25e3814867
+--- /dev/null
++++ b/sysdeps/unix/sysv/linux/x86/allocate-shadow-stack.h
+@@ -0,0 +1,27 @@
++/* Helper function to allocate shadow stack.
++   Copyright (C) 2020 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <ucontext.h>
++
++typedef __typeof (((ucontext_t *) 0)->__ssp[0]) shadow_stack_size_t;
++
++extern long int __allocate_shadow_stack (size_t, shadow_stack_size_t *)
++#ifndef __x86_64__
++  __attribute__ ((regparm (2)))
++#endif
++  attribute_hidden;
+diff --git a/sysdeps/unix/sysv/linux/x86/bits/mman.h b/sysdeps/unix/sysv/linux/x86/bits/mman.h
+index b2ae788555..d37eb80158 100644
+--- a/sysdeps/unix/sysv/linux/x86/bits/mman.h
++++ b/sysdeps/unix/sysv/linux/x86/bits/mman.h
+@@ -26,6 +26,7 @@
+ /* Other flags.  */
+ #ifdef __USE_MISC
+ # define MAP_32BIT	0x40		/* Only give out 32-bit addresses.  */
++# define PROT_SHSTK	0x10		/* Shadow stack pages.  */
+ #endif
+ 
+ #include <bits/mman-map-flags-generic.h>
+diff --git a/sysdeps/unix/sysv/linux/x86/cpu-features.c b/sysdeps/unix/sysv/linux/x86/cpu-features.c
+index 60f766853d..76ef99d4a1 100644
+--- a/sysdeps/unix/sysv/linux/x86/cpu-features.c
++++ b/sysdeps/unix/sysv/linux/x86/cpu-features.c
+@@ -24,7 +24,8 @@ static inline int __attribute__ ((always_inline))
+ get_cet_status (void)
+ {
+   unsigned long long cet_status[3];
+-  if (INTERNAL_SYSCALL_CALL (arch_prctl, ARCH_CET_STATUS, cet_status) == 0)
++  if (INTERNAL_SYSCALL_CALL (arch_prctl, ARCH_X86_CET_STATUS,
++			     cet_status) == 0)
+     return cet_status[0];
+   return 0;
+ }
+diff --git a/sysdeps/unix/sysv/linux/x86/dl-cet.h b/sysdeps/unix/sysv/linux/x86/dl-cet.h
+index 86151d8bbd..a431b601cc 100644
+--- a/sysdeps/unix/sysv/linux/x86/dl-cet.h
++++ b/sysdeps/unix/sysv/linux/x86/dl-cet.h
+@@ -21,12 +21,12 @@
+ static inline int __attribute__ ((always_inline))
+ dl_cet_disable_cet (unsigned int cet_feature)
+ {
+-  return (int) INTERNAL_SYSCALL_CALL (arch_prctl, ARCH_CET_DISABLE,
++  return (int) INTERNAL_SYSCALL_CALL (arch_prctl, ARCH_X86_CET_DISABLE,
+ 				      cet_feature);
+ }
+ 
+ static inline int __attribute__ ((always_inline))
+ dl_cet_lock_cet (void)
+ {
+-  return (int) INTERNAL_SYSCALL_CALL (arch_prctl, ARCH_CET_LOCK, 0);
++  return (int) INTERNAL_SYSCALL_CALL (arch_prctl, ARCH_X86_CET_LOCK, 0);
+ }
+diff --git a/sysdeps/unix/sysv/linux/x86/include/asm/prctl.h b/sysdeps/unix/sysv/linux/x86/include/asm/prctl.h
+index 45ad0b052f..d58754018b 100644
+--- a/sysdeps/unix/sysv/linux/x86/include/asm/prctl.h
++++ b/sysdeps/unix/sysv/linux/x86/include/asm/prctl.h
+@@ -4,7 +4,7 @@
+ 
+ #include_next <asm/prctl.h>
+ 
+-#ifndef ARCH_CET_STATUS
++#ifndef ARCH_X86_CET_STATUS
+ /* CET features:
+    IBT:   GNU_PROPERTY_X86_FEATURE_1_IBT
+    SHSTK: GNU_PROPERTY_X86_FEATURE_1_SHSTK
+@@ -14,14 +14,9 @@
+      shadow stack base address: addr[1].
+      shadow stack size: addr[2].
+  */
+-# define ARCH_CET_STATUS	0x3001
++# define ARCH_X86_CET_STATUS	0x3001
+ /* Disable CET features in unsigned int features.  */
+-# define ARCH_CET_DISABLE	0x3002
++# define ARCH_X86_CET_DISABLE	0x3002
+ /* Lock all CET features.  */
+-# define ARCH_CET_LOCK		0x3003
+-/* Allocate a new shadow stack with unsigned long long *addr:
+-     IN: requested shadow stack size: *addr.
+-     OUT: allocated shadow stack address: *addr.
+- */
+-# define ARCH_CET_ALLOC_SHSTK	0x3004
+-#endif /* ARCH_CET_STATUS */
++# define ARCH_X86_CET_LOCK		0x3003
++#endif /* ARCH_X86_CET_STATUS */
+diff --git a/sysdeps/unix/sysv/linux/x86/tst-cet-setcontext-1.c b/sysdeps/unix/sysv/linux/x86/tst-cet-setcontext-1.c
+index 38ca4b1d05..74a9a55677 100644
+--- a/sysdeps/unix/sysv/linux/x86/tst-cet-setcontext-1.c
++++ b/sysdeps/unix/sysv/linux/x86/tst-cet-setcontext-1.c
+@@ -88,7 +88,7 @@ do_test (void)
+   makecontext (&ctx[4], (void (*) (void)) f1, 0);
+ 
+   /* NB: When shadow stack is enabled, makecontext calls arch_prctl
+-     with ARCH_CET_ALLOC_SHSTK to allocate a new shadow stack which
++     with ARCH_X86_CET_MMAP_SHSTK to allocate a new shadow stack which
+      can be unmapped.  The base address and size of the new shadow
+      stack are returned in __ssp[1] and __ssp[2].  makecontext is
+      called for CTX1, CTX3 and CTX4.  But only CTX1 is used.  New
+diff --git a/sysdeps/unix/sysv/linux/x86_64/__start_context.S b/sysdeps/unix/sysv/linux/x86_64/__start_context.S
+index 49381e369e..bfde78d814 100644
+--- a/sysdeps/unix/sysv/linux/x86_64/__start_context.S
++++ b/sysdeps/unix/sysv/linux/x86_64/__start_context.S
+@@ -25,20 +25,14 @@
+ /* Use CALL to push __start_context onto the new stack as well as the new
+    shadow stack.  RDI points to ucontext:
+    Incoming:
+-     __ssp[0]: The original caller's shadow stack pointer.
+-     __ssp[1]: The size of the new shadow stack.
+-     __ssp[2]: The size of the new shadow stack.
+-   Outgoing:
+      __ssp[0]: The new shadow stack pointer.
+      __ssp[1]: The base address of the new shadow stack.
+      __ssp[2]: The size of the new shadow stack.
+  */
+ 
+ ENTRY(__push___start_context)
+-	/* Save the pointer to ucontext.  */
+-	movq	%rdi, %r9
+ 	/* Get the original shadow stack pointer.  */
+-	rdsspq	%r8
++	rdsspq	%rcx
+ 	/* Save the original stack pointer.  */
+ 	movq	%rsp, %rdx
+ 	/* Load the top of the new stack into RSI.  */
+@@ -46,24 +40,12 @@ ENTRY(__push___start_context)
+ 	/* Add 8 bytes to RSI since CALL will push the 8-byte return
+ 	   address onto stack.  */
+ 	leaq	8(%rsi), %rsp
+-	/* Allocate the new shadow stack.  The size of the new shadow
+-	   stack is passed in __ssp[1].  */
+-	lea	(oSSP + 8)(%rdi), %RSI_LP
+-	movl	$ARCH_CET_ALLOC_SHSTK, %edi
+-	movl	$__NR_arch_prctl, %eax
+-	/* The new shadow stack base is returned in __ssp[1].  */
+-	syscall
+-	testq	%rax, %rax
+-	jne	L(hlt)		/* This should never happen.  */
+-
+-	/* Get the size of the new shadow stack.  */
+-	movq	8(%rsi), %rdi
+-
+-	/* Get the base address of the new shadow stack.  */
+-	movq	(%rsi), %rsi
+-
++	/* The size of the new shadow stack is stored in __ssp[2].  */
++	mov	(oSSP + 16)(%rdi), %RSI_LP
++	/* The new shadow stack base is stored in __ssp[1].  */
++	mov	(oSSP + 8)(%rdi), %RAX_LP
+ 	/* Use the restore stoken to restore the new shadow stack.  */
+-	rstorssp -8(%rsi, %rdi)
++	rstorssp -8(%rax, %rsi)
+ 
+ 	/* Save the restore token on the original shadow stack.  */
+ 	saveprevssp
+@@ -74,18 +56,12 @@ ENTRY(__push___start_context)
+ 	jmp	__start_context
+ 1:
+ 
+-	/* Get the new shadow stack pointer.  */
+-	rdsspq	%rdi
+-
+ 	/* Use the restore stoken to restore the original shadow stack.  */
+-	rstorssp -8(%r8)
++	rstorssp -8(%rcx)
+ 
+ 	/* Save the restore token on the new shadow stack.  */
+ 	saveprevssp
+ 
+-	/* Store the new shadow stack pointer in __ssp[0].  */
+-	movq	%rdi, oSSP(%r9)
+-
+ 	/* Restore the original stack.  */
+ 	mov	%rdx, %rsp
+ 	ret
+diff --git a/sysdeps/unix/sysv/linux/x86_64/getcontext.S b/sysdeps/unix/sysv/linux/x86_64/getcontext.S
+index 5ca779b15b..aee363b000 100644
+--- a/sysdeps/unix/sysv/linux/x86_64/getcontext.S
++++ b/sysdeps/unix/sysv/linux/x86_64/getcontext.S
+@@ -71,7 +71,7 @@ ENTRY(__getcontext)
+ 	   been recorded yet.  */
+ 	sub	$24, %RSP_LP
+ 	mov	%RSP_LP, %RSI_LP
+-	movl	$ARCH_CET_STATUS, %edi
++	movl	$ARCH_X86_CET_STATUS, %edi
+ 	movl	$__NR_arch_prctl, %eax
+ 	syscall
+ 	testq	%rax, %rax
+diff --git a/sysdeps/unix/sysv/linux/x86_64/makecontext.c b/sysdeps/unix/sysv/linux/x86_64/makecontext.c
+index ceb5c02bad..950e3b1201 100644
+--- a/sysdeps/unix/sysv/linux/x86_64/makecontext.c
++++ b/sysdeps/unix/sysv/linux/x86_64/makecontext.c
+@@ -25,6 +25,8 @@
+ # include <pthread.h>
+ # include <libc-pointer-arith.h>
+ # include <sys/prctl.h>
++# include <sys/mman.h>
++# include <allocate-shadow-stack.h>
+ #endif
+ 
+ #include "ucontext_i.h"
+@@ -89,23 +91,24 @@ __makecontext (ucontext_t *ucp, void (*func) (void), int argc, ...)
+   if ((feature_1 & X86_FEATURE_1_SHSTK) != 0)
+     {
+       /* Shadow stack is enabled.  We need to allocate a new shadow
+-         stack.  */
+-      unsigned long ssp_size = (((uintptr_t) sp
+-				 - (uintptr_t) ucp->uc_stack.ss_sp)
+-				>> STACK_SIZE_TO_SHADOW_STACK_SIZE_SHIFT);
+-      /* Align shadow stack to 8 bytes.  */
+-      ssp_size = ALIGN_UP (ssp_size, 8);
+-
+-      ucp->__ssp[1] = ssp_size;
+-      ucp->__ssp[2] = ssp_size;
+-
+-      /* Call __push___start_context to allocate a new shadow stack,
+-	 push __start_context onto the new stack as well as the new
+-	 shadow stack.  NB: After __push___start_context returns,
++         stack.  NB:
+ 	   ucp->__ssp[0]: The new shadow stack pointer.
+ 	   ucp->__ssp[1]: The base address of the new shadow stack.
+ 	   ucp->__ssp[2]: The size of the new shadow stack.
+        */
++      long int ret
++	= __allocate_shadow_stack (((uintptr_t) sp
++				    - (uintptr_t) ucp->uc_stack.ss_sp),
++				   &ucp->__ssp[1]);
++      if (ret != 0)
++	{
++	  /* FIXME: What should we do?  */
++	  abort ();
++	}
++
++      ucp->__ssp[0] = ucp->__ssp[1] + ucp->__ssp[2] - 8;
++      /* Call __push___start_context to push __start_context onto the new
++	 stack as well as the new shadow stack.  */
+       __push___start_context (ucp);
+     }
+   else
+diff --git a/sysdeps/unix/sysv/linux/x86_64/swapcontext.S b/sysdeps/unix/sysv/linux/x86_64/swapcontext.S
+index dbc1a3a840..16648a6080 100644
+--- a/sysdeps/unix/sysv/linux/x86_64/swapcontext.S
++++ b/sysdeps/unix/sysv/linux/x86_64/swapcontext.S
+@@ -115,7 +115,7 @@ ENTRY(__swapcontext)
+ 	   been recorded yet.  */
+ 	sub	$24, %RSP_LP
+ 	mov	%RSP_LP, %RSI_LP
+-	movl	$ARCH_CET_STATUS, %edi
++	movl	$ARCH_X86_CET_STATUS, %edi
+ 	movl	$__NR_arch_prctl, %eax
+ 	syscall
+ 	testq	%rax, %rax
+-- 
+2.31.1
+
diff --git a/0002-x86-Add-tst-sigreturn-1.c-from-Linux-kernel.patch b/0002-x86-Add-tst-sigreturn-1.c-from-Linux-kernel.patch
new file mode 100644
index 0000000..cb56c8c
--- /dev/null
+++ b/0002-x86-Add-tst-sigreturn-1.c-from-Linux-kernel.patch
@@ -0,0 +1,1113 @@
+From ee37ff83c329713966d3da7de510a47895f0bbc7 Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Sat, 15 Aug 2020 08:21:32 -0700
+Subject: [PATCH 02/24] x86: Add tst-sigreturn-1.c from Linux kernel
+
+Add tst-sigreturn-1.c from tools/testing/selftests/x86/sigreturn.c in
+Linux kernel to test shadow stack with PROT_SHSTK and MAP_32BIT.  Also
+add <asm/desc_defs.h> from Linux kernel for tst-sigreturn-1.c.
+---
+ sysdeps/unix/sysv/linux/x86/Makefile          |   7 +
+ .../sysv/linux/x86/include/asm/desc_defs.h    | 135 +++
+ sysdeps/unix/sysv/linux/x86/tst-sigreturn-1.c | 929 ++++++++++++++++++
+ 3 files changed, 1071 insertions(+)
+ create mode 100644 sysdeps/unix/sysv/linux/x86/include/asm/desc_defs.h
+ create mode 100644 sysdeps/unix/sysv/linux/x86/tst-sigreturn-1.c
+
+diff --git a/sysdeps/unix/sysv/linux/x86/Makefile b/sysdeps/unix/sysv/linux/x86/Makefile
+index 6ba85d5c76..081f74a904 100644
+--- a/sysdeps/unix/sysv/linux/x86/Makefile
++++ b/sysdeps/unix/sysv/linux/x86/Makefile
+@@ -24,6 +24,13 @@ ifeq ($(subdir),setjmp)
+ tests += tst-saved_mask-1
+ endif
+ 
++ifeq ($(subdir),signal)
++tests-internal += tst-sigreturn-1
++ifneq ($(enable-cet),no)
++CFLAGS-tst-sigreturn-1.c += -mshstk
++endif
++endif
++
+ ifneq ($(enable-cet),no)
+ ifeq ($(subdir),elf)
+ tests += tst-cet-property-1 tst-cet-property-2
+diff --git a/sysdeps/unix/sysv/linux/x86/include/asm/desc_defs.h b/sysdeps/unix/sysv/linux/x86/include/asm/desc_defs.h
+new file mode 100644
+index 0000000000..a91f3b6e4f
+--- /dev/null
++++ b/sysdeps/unix/sysv/linux/x86/include/asm/desc_defs.h
+@@ -0,0 +1,135 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/* Written 2000 by Andi Kleen */
++#ifndef _ASM_X86_DESC_DEFS_H
++#define _ASM_X86_DESC_DEFS_H
++
++/*
++ * Segment descriptor structure definitions, usable from both x86_64 and i386
++ * archs.
++ */
++
++#ifndef __ASSEMBLY__
++
++#include <linux/types.h>
++
++/* 8 byte segment descriptor */
++struct desc_struct {
++	u16	limit0;
++	u16	base0;
++	u16	base1: 8, type: 4, s: 1, dpl: 2, p: 1;
++	u16	limit1: 4, avl: 1, l: 1, d: 1, g: 1, base2: 8;
++} __attribute__((packed));
++
++#define GDT_ENTRY_INIT(flags, base, limit)			\
++	{							\
++		.limit0		= (u16) (limit),		\
++		.limit1		= ((limit) >> 16) & 0x0F,	\
++		.base0		= (u16) (base),			\
++		.base1		= ((base) >> 16) & 0xFF,	\
++		.base2		= ((base) >> 24) & 0xFF,	\
++		.type		= (flags & 0x0f),		\
++		.s		= (flags >> 4) & 0x01,		\
++		.dpl		= (flags >> 5) & 0x03,		\
++		.p		= (flags >> 7) & 0x01,		\
++		.avl		= (flags >> 12) & 0x01,		\
++		.l		= (flags >> 13) & 0x01,		\
++		.d		= (flags >> 14) & 0x01,		\
++		.g		= (flags >> 15) & 0x01,		\
++	}
++
++enum {
++	GATE_INTERRUPT = 0xE,
++	GATE_TRAP = 0xF,
++	GATE_CALL = 0xC,
++	GATE_TASK = 0x5,
++};
++
++enum {
++	DESC_TSS = 0x9,
++	DESC_LDT = 0x2,
++	DESCTYPE_S = 0x10,	/* !system */
++};
++
++/* LDT or TSS descriptor in the GDT. */
++struct ldttss_desc {
++	u16	limit0;
++	u16	base0;
++
++	u16	base1 : 8, type : 5, dpl : 2, p : 1;
++	u16	limit1 : 4, zero0 : 3, g : 1, base2 : 8;
++#ifdef CONFIG_X86_64
++	u32	base3;
++	u32	zero1;
++#endif
++} __attribute__((packed));
++
++typedef struct ldttss_desc ldt_desc;
++typedef struct ldttss_desc tss_desc;
++
++struct idt_bits {
++	u16		ist	: 3,
++			zero	: 5,
++			type	: 5,
++			dpl	: 2,
++			p	: 1;
++} __attribute__((packed));
++
++struct gate_struct {
++	u16		offset_low;
++	u16		segment;
++	struct idt_bits	bits;
++	u16		offset_middle;
++#ifdef CONFIG_X86_64
++	u32		offset_high;
++	u32		reserved;
++#endif
++} __attribute__((packed));
++
++typedef struct gate_struct gate_desc;
++
++static inline unsigned long gate_offset(const gate_desc *g)
++{
++#ifdef CONFIG_X86_64
++	return g->offset_low | ((unsigned long)g->offset_middle << 16) |
++		((unsigned long) g->offset_high << 32);
++#else
++	return g->offset_low | ((unsigned long)g->offset_middle << 16);
++#endif
++}
++
++static inline unsigned long gate_segment(const gate_desc *g)
++{
++	return g->segment;
++}
++
++struct desc_ptr {
++	unsigned short size;
++	unsigned long address;
++} __attribute__((packed)) ;
++
++#endif /* !__ASSEMBLY__ */
++
++/* Access rights as returned by LAR */
++#define AR_TYPE_RODATA		(0 * (1 << 9))
++#define AR_TYPE_RWDATA		(1 * (1 << 9))
++#define AR_TYPE_RODATA_EXPDOWN	(2 * (1 << 9))
++#define AR_TYPE_RWDATA_EXPDOWN	(3 * (1 << 9))
++#define AR_TYPE_XOCODE		(4 * (1 << 9))
++#define AR_TYPE_XRCODE		(5 * (1 << 9))
++#define AR_TYPE_XOCODE_CONF	(6 * (1 << 9))
++#define AR_TYPE_XRCODE_CONF	(7 * (1 << 9))
++#define AR_TYPE_MASK		(7 * (1 << 9))
++
++#define AR_DPL0			(0 * (1 << 13))
++#define AR_DPL3			(3 * (1 << 13))
++#define AR_DPL_MASK		(3 * (1 << 13))
++
++#define AR_A			(1 << 8)   /* "Accessed" */
++#define AR_S			(1 << 12)  /* If clear, "System" segment */
++#define AR_P			(1 << 15)  /* "Present" */
++#define AR_AVL			(1 << 20)  /* "AVaiLable" (no HW effect) */
++#define AR_L			(1 << 21)  /* "Long mode" for code segments */
++#define AR_DB			(1 << 22)  /* D/B, effect depends on type */
++#define AR_G			(1 << 23)  /* "Granularity" (limit in pages) */
++
++#endif /* _ASM_X86_DESC_DEFS_H */
+diff --git a/sysdeps/unix/sysv/linux/x86/tst-sigreturn-1.c b/sysdeps/unix/sysv/linux/x86/tst-sigreturn-1.c
+new file mode 100644
+index 0000000000..329d13210c
+--- /dev/null
++++ b/sysdeps/unix/sysv/linux/x86/tst-sigreturn-1.c
+@@ -0,0 +1,929 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * sigreturn.c - tests for x86 sigreturn(2) and exit-to-userspace
++ * Copyright (c) 2014-2015 Andrew Lutomirski
++ *
++ * This is a series of tests that exercises the sigreturn(2) syscall and
++ * the IRET / SYSRET paths in the kernel.
++ *
++ * For now, this focuses on the effects of unusual CS and SS values,
++ * and it has a bunch of tests to make sure that ESP/RSP is restored
++ * properly.
++ *
++ * The basic idea behind these tests is to raise(SIGUSR1) to create a
++ * sigcontext frame, plug in the values to be tested, and then return,
++ * which implicitly invokes sigreturn(2) and programs the user context
++ * as desired.
++ *
++ * For tests for which we expect sigreturn and the subsequent return to
++ * user mode to succeed, we return to a short trampoline that generates
++ * SIGTRAP so that the meat of the tests can be ordinary C code in a
++ * SIGTRAP handler.
++ *
++ * The inner workings of each test is documented below.
++ *
++ * Do not run on outdated, unpatched kernels at risk of nasty crashes.
++ */
++
++#ifndef _GNU_SOURCE
++#define _GNU_SOURCE
++#endif
++
++#include <sys/time.h>
++#include <time.h>
++#include <stdlib.h>
++#include <sys/syscall.h>
++#include <unistd.h>
++#include <stdio.h>
++#include <string.h>
++#include <inttypes.h>
++#include <sys/mman.h>
++#include <sys/signal.h>
++#include <sys/ucontext.h>
++#include <asm/ldt.h>
++#include <err.h>
++#include <setjmp.h>
++#include <stddef.h>
++#include <stdbool.h>
++#include <sys/ptrace.h>
++#include <sys/user.h>
++#include <sys/mman.h>
++#include <x86intrin.h>
++
++#include <support/test-driver.h>
++
++/* Pull in AR_xyz defines. */
++typedef unsigned int u32;
++typedef unsigned short u16;
++#include <asm/desc_defs.h>
++
++/*
++ * Copied from asm/ucontext.h, as asm/ucontext.h conflicts badly with the glibc
++ * headers.
++ */
++#ifdef __x86_64__
++/*
++ * UC_SIGCONTEXT_SS will be set when delivering 64-bit or x32 signals on
++ * kernels that save SS in the sigcontext.  All kernels that set
++ * UC_SIGCONTEXT_SS will correctly restore at least the low 32 bits of esp
++ * regardless of SS (i.e. they implement espfix).
++ *
++ * Kernels that set UC_SIGCONTEXT_SS will also set UC_STRICT_RESTORE_SS
++ * when delivering a signal that came from 64-bit code.
++ *
++ * Sigreturn restores SS as follows:
++ *
++ * if (saved SS is valid || UC_STRICT_RESTORE_SS is set ||
++ *     saved CS is not 64-bit)
++ *         new SS = saved SS  (will fail IRET and signal if invalid)
++ * else
++ *         new SS = a flat 32-bit data segment
++ */
++#define UC_SIGCONTEXT_SS       0x2
++#define UC_STRICT_RESTORE_SS   0x4
++#endif
++
++/*
++ * In principle, this test can run on Linux emulation layers (e.g.
++ * Illumos "LX branded zones").  Solaris-based kernels reserve LDT
++ * entries 0-5 for their own internal purposes, so start our LDT
++ * allocations above that reservation.  (The tests don't pass on LX
++ * branded zones, but at least this lets them run.)
++ */
++#define LDT_OFFSET 6
++
++/* An aligned stack accessible through some of our segments. */
++static unsigned char stack16[65536] __attribute__((aligned(4096)));
++
++/*
++ * An aligned int3 instruction used as a trampoline.  Some of the tests
++ * want to fish out their ss values, so this trampoline copies ss to eax
++ * before the int3.
++ */
++asm (".pushsection .text\n\t"
++     ".type int3, @function\n\t"
++     ".align 4096\n\t"
++     "int3:\n\t"
++     "mov %ss,%ecx\n\t"
++     "int3\n\t"
++     ".size int3, . - int3\n\t"
++     ".align 4096, 0xcc\n\t"
++     ".popsection");
++extern char int3[4096];
++
++/*
++ * At startup, we prepapre:
++ *
++ * - ldt_nonexistent_sel: An LDT entry that doesn't exist (all-zero
++ *   descriptor or out of bounds).
++ * - code16_sel: A 16-bit LDT code segment pointing to int3.
++ * - data16_sel: A 16-bit LDT data segment pointing to stack16.
++ * - npcode32_sel: A 32-bit not-present LDT code segment pointing to int3.
++ * - npdata32_sel: A 32-bit not-present LDT data segment pointing to stack16.
++ * - gdt_data16_idx: A 16-bit GDT data segment pointing to stack16.
++ * - gdt_npdata32_idx: A 32-bit not-present GDT data segment pointing to
++ *   stack16.
++ *
++ * For no particularly good reason, xyz_sel is a selector value with the
++ * RPL and LDT bits filled in, whereas xyz_idx is just an index into the
++ * descriptor table.  These variables will be zero if their respective
++ * segments could not be allocated.
++ */
++static unsigned short ldt_nonexistent_sel;
++static unsigned short code16_sel, data16_sel, npcode32_sel, npdata32_sel;
++
++static unsigned short gdt_data16_idx, gdt_npdata32_idx;
++
++static unsigned short GDT3(int idx)
++{
++	return (idx << 3) | 3;
++}
++
++static unsigned short LDT3(int idx)
++{
++	return (idx << 3) | 7;
++}
++
++/* Our sigaltstack scratch space. */
++static char altstack_data[SIGSTKSZ];
++
++static void sethandler(int sig, void (*handler)(int, siginfo_t *, void *),
++		       int flags)
++{
++	struct sigaction sa;
++	memset(&sa, 0, sizeof(sa));
++	sa.sa_sigaction = handler;
++	sa.sa_flags = SA_SIGINFO | flags;
++	sigemptyset(&sa.sa_mask);
++	if (sigaction(sig, &sa, 0))
++		err(1, "sigaction");
++}
++
++static void clearhandler(int sig)
++{
++	struct sigaction sa;
++	memset(&sa, 0, sizeof(sa));
++	sa.sa_handler = SIG_DFL;
++	sigemptyset(&sa.sa_mask);
++	if (sigaction(sig, &sa, 0))
++		err(1, "sigaction");
++}
++
++static void add_ldt(const struct user_desc *desc, unsigned short *var,
++		    const char *name)
++{
++	if (syscall(__NR_modify_ldt, 1, desc, sizeof(*desc)) == 0) {
++		*var = LDT3(desc->entry_number);
++	} else {
++		printf("[NOTE]\tFailed to create %s segment\n", name);
++		*var = 0;
++	}
++}
++
++static void setup_ldt(void)
++{
++	if ((unsigned long)stack16 > (1ULL << 32) - sizeof(stack16))
++		errx(EXIT_UNSUPPORTED, "stack16 is too high\n");
++	if ((unsigned long)int3 > (1ULL << 32) - sizeof(int3))
++		errx(EXIT_UNSUPPORTED, "int3 is too high\n");
++
++	ldt_nonexistent_sel = LDT3(LDT_OFFSET + 2);
++
++	const struct user_desc code16_desc = {
++		.entry_number    = LDT_OFFSET + 0,
++		.base_addr       = (unsigned long)int3,
++		.limit           = 4095,
++		.seg_32bit       = 0,
++		.contents        = 2, /* Code, not conforming */
++		.read_exec_only  = 0,
++		.limit_in_pages  = 0,
++		.seg_not_present = 0,
++		.useable         = 0
++	};
++	add_ldt(&code16_desc, &code16_sel, "code16");
++
++	const struct user_desc data16_desc = {
++		.entry_number    = LDT_OFFSET + 1,
++		.base_addr       = (unsigned long)stack16,
++		.limit           = 0xffff,
++		.seg_32bit       = 0,
++		.contents        = 0, /* Data, grow-up */
++		.read_exec_only  = 0,
++		.limit_in_pages  = 0,
++		.seg_not_present = 0,
++		.useable         = 0
++	};
++	add_ldt(&data16_desc, &data16_sel, "data16");
++
++	const struct user_desc npcode32_desc = {
++		.entry_number    = LDT_OFFSET + 3,
++		.base_addr       = (unsigned long)int3,
++		.limit           = 4095,
++		.seg_32bit       = 1,
++		.contents        = 2, /* Code, not conforming */
++		.read_exec_only  = 0,
++		.limit_in_pages  = 0,
++		.seg_not_present = 1,
++		.useable         = 0
++	};
++	add_ldt(&npcode32_desc, &npcode32_sel, "npcode32");
++
++	const struct user_desc npdata32_desc = {
++		.entry_number    = LDT_OFFSET + 4,
++		.base_addr       = (unsigned long)stack16,
++		.limit           = 0xffff,
++		.seg_32bit       = 1,
++		.contents        = 0, /* Data, grow-up */
++		.read_exec_only  = 0,
++		.limit_in_pages  = 0,
++		.seg_not_present = 1,
++		.useable         = 0
++	};
++	add_ldt(&npdata32_desc, &npdata32_sel, "npdata32");
++
++	struct user_desc gdt_data16_desc = {
++		.entry_number    = -1,
++		.base_addr       = (unsigned long)stack16,
++		.limit           = 0xffff,
++		.seg_32bit       = 0,
++		.contents        = 0, /* Data, grow-up */
++		.read_exec_only  = 0,
++		.limit_in_pages  = 0,
++		.seg_not_present = 0,
++		.useable         = 0
++	};
++
++	if (syscall(__NR_set_thread_area, &gdt_data16_desc) == 0) {
++		/*
++		 * This probably indicates vulnerability to CVE-2014-8133.
++		 * Merely getting here isn't definitive, though, and we'll
++		 * diagnose the problem for real later on.
++		 */
++		printf("[WARN]\tset_thread_area allocated data16 at index %d\n",
++		       gdt_data16_desc.entry_number);
++		gdt_data16_idx = gdt_data16_desc.entry_number;
++	} else {
++		printf("[OK]\tset_thread_area refused 16-bit data\n");
++	}
++
++	struct user_desc gdt_npdata32_desc = {
++		.entry_number    = -1,
++		.base_addr       = (unsigned long)stack16,
++		.limit           = 0xffff,
++		.seg_32bit       = 1,
++		.contents        = 0, /* Data, grow-up */
++		.read_exec_only  = 0,
++		.limit_in_pages  = 0,
++		.seg_not_present = 1,
++		.useable         = 0
++	};
++
++	if (syscall(__NR_set_thread_area, &gdt_npdata32_desc) == 0) {
++		/*
++		 * As a hardening measure, newer kernels don't allow this.
++		 */
++		printf("[WARN]\tset_thread_area allocated npdata32 at index %d\n",
++		       gdt_npdata32_desc.entry_number);
++		gdt_npdata32_idx = gdt_npdata32_desc.entry_number;
++	} else {
++		printf("[OK]\tset_thread_area refused 16-bit data\n");
++	}
++}
++
++/* State used by our signal handlers. */
++static gregset_t initial_regs, requested_regs, resulting_regs;
++
++/* Instructions for the SIGUSR1 handler. */
++static volatile unsigned short sig_cs, sig_ss;
++static volatile sig_atomic_t sig_trapped, sig_err, sig_trapno;
++#ifdef __x86_64__
++static volatile sig_atomic_t sig_corrupt_final_ss;
++#endif
++
++/* Abstractions for some 32-bit vs 64-bit differences. */
++#ifdef __x86_64__
++# define REG_IP REG_RIP
++# define REG_SP REG_RSP
++# define REG_CX REG_RCX
++
++struct selectors {
++	unsigned short cs, gs, fs, ss;
++};
++
++static unsigned short *ssptr(ucontext_t *ctx)
++{
++	struct selectors *sels = (void *)&ctx->uc_mcontext.gregs[REG_CSGSFS];
++	return &sels->ss;
++}
++
++static unsigned short *csptr(ucontext_t *ctx)
++{
++	struct selectors *sels = (void *)&ctx->uc_mcontext.gregs[REG_CSGSFS];
++	return &sels->cs;
++}
++#else
++# define REG_IP REG_EIP
++# define REG_SP REG_ESP
++# define REG_CX REG_ECX
++
++static greg_t *ssptr(ucontext_t *ctx)
++{
++	return &ctx->uc_mcontext.gregs[REG_SS];
++}
++
++static greg_t *csptr(ucontext_t *ctx)
++{
++	return &ctx->uc_mcontext.gregs[REG_CS];
++}
++#endif
++
++/*
++ * Checks a given selector for its code bitness or returns -1 if it's not
++ * a usable code segment selector.
++ */
++int cs_bitness(unsigned short cs)
++{
++	uint32_t valid = 0, ar;
++	asm ("lar %[cs], %[ar]\n\t"
++	     "jnz 1f\n\t"
++	     "mov $1, %[valid]\n\t"
++	     "1:"
++	     : [ar] "=r" (ar), [valid] "+rm" (valid)
++	     : [cs] "r" (cs));
++
++	if (!valid)
++		return -1;
++
++	bool db = (ar & (1 << 22));
++	bool l = (ar & (1 << 21));
++
++	if (!(ar & (1<<11)))
++	    return -1;	/* Not code. */
++
++	if (l && !db)
++		return 64;
++	else if (!l && db)
++		return 32;
++	else if (!l && !db)
++		return 16;
++	else
++		return -1;	/* Unknown bitness. */
++}
++
++/*
++ * Checks a given selector for its code bitness or returns -1 if it's not
++ * a usable code segment selector.
++ */
++bool is_valid_ss(unsigned short cs)
++{
++	uint32_t valid = 0, ar;
++	asm ("lar %[cs], %[ar]\n\t"
++	     "jnz 1f\n\t"
++	     "mov $1, %[valid]\n\t"
++	     "1:"
++	     : [ar] "=r" (ar), [valid] "+rm" (valid)
++	     : [cs] "r" (cs));
++
++	if (!valid)
++		return false;
++
++	if ((ar & AR_TYPE_MASK) != AR_TYPE_RWDATA &&
++	    (ar & AR_TYPE_MASK) != AR_TYPE_RWDATA_EXPDOWN)
++		return false;
++
++	return (ar & AR_P);
++}
++
++/* Number of errors in the current test case. */
++static volatile sig_atomic_t nerrs;
++
++static void validate_signal_ss(int sig, ucontext_t *ctx)
++{
++#ifdef __x86_64__
++	bool was_64bit = (cs_bitness(*csptr(ctx)) == 64);
++
++	if (!(ctx->uc_flags & UC_SIGCONTEXT_SS)) {
++		printf("[FAIL]\tUC_SIGCONTEXT_SS was not set\n");
++		nerrs++;
++
++		/*
++		 * This happens on Linux 4.1.  The rest will fail, too, so
++		 * return now to reduce the noise.
++		 */
++		return;
++	}
++
++	/* UC_STRICT_RESTORE_SS is set iff we came from 64-bit mode. */
++	if (!!(ctx->uc_flags & UC_STRICT_RESTORE_SS) != was_64bit) {
++		printf("[FAIL]\tUC_STRICT_RESTORE_SS was wrong in signal %d\n",
++		       sig);
++		nerrs++;
++	}
++
++	if (is_valid_ss(*ssptr(ctx))) {
++		/*
++		 * DOSEMU was written before 64-bit sigcontext had SS, and
++		 * it tries to figure out the signal source SS by looking at
++		 * the physical register.  Make sure that keeps working.
++		 */
++		unsigned short hw_ss;
++		asm ("mov %%ss, %0" : "=rm" (hw_ss));
++		if (hw_ss != *ssptr(ctx)) {
++			printf("[FAIL]\tHW SS didn't match saved SS\n");
++			nerrs++;
++		}
++	}
++#endif
++}
++
++/*
++ * SIGUSR1 handler.  Sets CS and SS as requested and points IP to the
++ * int3 trampoline.  Sets SP to a large known value so that we can see
++ * whether the value round-trips back to user mode correctly.
++ */
++static void sigusr1(int sig, siginfo_t *info, void *ctx_void)
++{
++	ucontext_t *ctx = (ucontext_t*)ctx_void;
++
++	validate_signal_ss(sig, ctx);
++
++	memcpy(&initial_regs, &ctx->uc_mcontext.gregs, sizeof(gregset_t));
++
++	*csptr(ctx) = sig_cs;
++	*ssptr(ctx) = sig_ss;
++
++	ctx->uc_mcontext.gregs[REG_IP] =
++		sig_cs == code16_sel ? 0 : (unsigned long)&int3;
++	ctx->uc_mcontext.gregs[REG_SP] = (unsigned long)0x8badf00d5aadc0deULL;
++	ctx->uc_mcontext.gregs[REG_CX] = 0;
++
++#ifdef __i386__
++	/*
++	 * Make sure the kernel doesn't inadvertently use DS or ES-relative
++	 * accesses in a region where user DS or ES is loaded.
++	 *
++	 * Skip this for 64-bit builds because long mode doesn't care about
++	 * DS and ES and skipping it increases test coverage a little bit,
++	 * since 64-bit kernels can still run the 32-bit build.
++	 */
++	ctx->uc_mcontext.gregs[REG_DS] = 0;
++	ctx->uc_mcontext.gregs[REG_ES] = 0;
++#endif
++
++	memcpy(&requested_regs, &ctx->uc_mcontext.gregs, sizeof(gregset_t));
++	requested_regs[REG_CX] = *ssptr(ctx);	/* The asm code does this. */
++
++	return;
++}
++
++/*
++ * Called after a successful sigreturn (via int3) or from a failed
++ * sigreturn (directly by kernel).  Restores our state so that the
++ * original raise(SIGUSR1) returns.
++ */
++static void sigtrap(int sig, siginfo_t *info, void *ctx_void)
++{
++	ucontext_t *ctx = (ucontext_t*)ctx_void;
++
++	validate_signal_ss(sig, ctx);
++
++	sig_err = ctx->uc_mcontext.gregs[REG_ERR];
++	sig_trapno = ctx->uc_mcontext.gregs[REG_TRAPNO];
++
++	unsigned short ss;
++	asm ("mov %%ss,%0" : "=r" (ss));
++
++	greg_t asm_ss = ctx->uc_mcontext.gregs[REG_CX];
++	if (asm_ss != sig_ss && sig == SIGTRAP) {
++		/* Sanity check failure. */
++		printf("[FAIL]\tSIGTRAP: ss = %hx, frame ss = %hx, ax = %llx\n",
++		       ss, *ssptr(ctx), (unsigned long long)asm_ss);
++		nerrs++;
++	}
++
++	memcpy(&resulting_regs, &ctx->uc_mcontext.gregs, sizeof(gregset_t));
++	memcpy(&ctx->uc_mcontext.gregs, &initial_regs, sizeof(gregset_t));
++
++#ifdef __x86_64__
++	if (sig_corrupt_final_ss) {
++		if (ctx->uc_flags & UC_STRICT_RESTORE_SS) {
++			printf("[FAIL]\tUC_STRICT_RESTORE_SS was set inappropriately\n");
++			nerrs++;
++		} else {
++			/*
++			 * DOSEMU transitions from 32-bit to 64-bit mode by
++			 * adjusting sigcontext, and it requires that this work
++			 * even if the saved SS is bogus.
++			 */
++			printf("\tCorrupting SS on return to 64-bit mode\n");
++			*ssptr(ctx) = 0;
++		}
++	}
++#endif
++
++	sig_trapped = sig;
++}
++
++#ifdef __x86_64__
++/* Tests recovery if !UC_STRICT_RESTORE_SS */
++static void sigusr2(int sig, siginfo_t *info, void *ctx_void)
++{
++	ucontext_t *ctx = (ucontext_t*)ctx_void;
++
++	if (!(ctx->uc_flags & UC_STRICT_RESTORE_SS)) {
++		printf("[FAIL]\traise(2) didn't set UC_STRICT_RESTORE_SS\n");
++		nerrs++;
++		return;  /* We can't do the rest. */
++	}
++
++	ctx->uc_flags &= ~UC_STRICT_RESTORE_SS;
++	*ssptr(ctx) = 0;
++
++	/* Return.  The kernel should recover without sending another signal. */
++}
++
++static int test_nonstrict_ss(void)
++{
++	clearhandler(SIGUSR1);
++	clearhandler(SIGTRAP);
++	clearhandler(SIGSEGV);
++	clearhandler(SIGILL);
++	sethandler(SIGUSR2, sigusr2, 0);
++
++	nerrs = 0;
++
++	printf("[RUN]\tClear UC_STRICT_RESTORE_SS and corrupt SS\n");
++	raise(SIGUSR2);
++	if (!nerrs)
++		printf("[OK]\tIt worked\n");
++
++	return nerrs;
++}
++#endif
++
++/* Finds a usable code segment of the requested bitness. */
++int find_cs(int bitness)
++{
++	unsigned short my_cs;
++
++	asm ("mov %%cs,%0" :  "=r" (my_cs));
++
++	if (cs_bitness(my_cs) == bitness)
++		return my_cs;
++	if (cs_bitness(my_cs + (2 << 3)) == bitness)
++		return my_cs + (2 << 3);
++	if (my_cs > (2<<3) && cs_bitness(my_cs - (2 << 3)) == bitness)
++	    return my_cs - (2 << 3);
++	if (cs_bitness(code16_sel) == bitness)
++		return code16_sel;
++
++	printf("[WARN]\tCould not find %d-bit CS\n", bitness);
++	return -1;
++}
++
++static int test_valid_sigreturn(int cs_bits, bool use_16bit_ss, int force_ss)
++{
++	int cs = find_cs(cs_bits);
++	if (cs == -1) {
++		printf("[SKIP]\tCode segment unavailable for %d-bit CS, %d-bit SS\n",
++		       cs_bits, use_16bit_ss ? 16 : 32);
++		return 0;
++	}
++
++	if (force_ss != -1) {
++		sig_ss = force_ss;
++	} else {
++		if (use_16bit_ss) {
++			if (!data16_sel) {
++				printf("[SKIP]\tData segment unavailable for %d-bit CS, 16-bit SS\n",
++				       cs_bits);
++				return 0;
++			}
++			sig_ss = data16_sel;
++		} else {
++			asm volatile ("mov %%ss,%0" : "=r" (sig_ss));
++		}
++	}
++
++	sig_cs = cs;
++
++	printf("[RUN]\tValid sigreturn: %d-bit CS (%hx), %d-bit SS (%hx%s)\n",
++	       cs_bits, sig_cs, use_16bit_ss ? 16 : 32, sig_ss,
++	       (sig_ss & 4) ? "" : ", GDT");
++
++	raise(SIGUSR1);
++
++	nerrs = 0;
++
++	/*
++	 * Check that each register had an acceptable value when the
++	 * int3 trampoline was invoked.
++	 */
++	for (int i = 0; i < NGREG; i++) {
++		greg_t req = requested_regs[i], res = resulting_regs[i];
++
++		if (i == REG_TRAPNO || i == REG_IP)
++			continue;	/* don't care */
++
++		if (i == REG_SP) {
++			/*
++			 * If we were using a 16-bit stack segment, then
++			 * the kernel is a bit stuck: IRET only restores
++			 * the low 16 bits of ESP/RSP if SS is 16-bit.
++			 * The kernel uses a hack to restore bits 31:16,
++			 * but that hack doesn't help with bits 63:32.
++			 * On Intel CPUs, bits 63:32 end up zeroed, and, on
++			 * AMD CPUs, they leak the high bits of the kernel
++			 * espfix64 stack pointer.  There's very little that
++			 * the kernel can do about it.
++			 *
++			 * Similarly, if we are returning to a 32-bit context,
++			 * the CPU will often lose the high 32 bits of RSP.
++			 */
++
++			if (res == req)
++				continue;
++
++			if (cs_bits != 64 && ((res ^ req) & 0xFFFFFFFF) == 0) {
++				printf("[NOTE]\tSP: %llx -> %llx\n",
++				       (unsigned long long)req,
++				       (unsigned long long)res);
++				continue;
++			}
++
++			printf("[FAIL]\tSP mismatch: requested 0x%llx; got 0x%llx\n",
++			       (unsigned long long)requested_regs[i],
++			       (unsigned long long)resulting_regs[i]);
++			nerrs++;
++			continue;
++		}
++
++		bool ignore_reg = false;
++#ifdef __i386__
++		if (i == REG_UESP)
++			ignore_reg = true;
++#else
++		if (i == REG_CSGSFS) {
++			struct selectors *req_sels =
++				(void *)&requested_regs[REG_CSGSFS];
++			struct selectors *res_sels =
++				(void *)&resulting_regs[REG_CSGSFS];
++			if (req_sels->cs != res_sels->cs) {
++				printf("[FAIL]\tCS mismatch: requested 0x%hx; got 0x%hx\n",
++				       req_sels->cs, res_sels->cs);
++				nerrs++;
++			}
++
++			if (req_sels->ss != res_sels->ss) {
++				printf("[FAIL]\tSS mismatch: requested 0x%hx; got 0x%hx\n",
++				       req_sels->ss, res_sels->ss);
++				nerrs++;
++			}
++
++			continue;
++		}
++#endif
++
++		/* Sanity check on the kernel */
++		if (i == REG_CX && req != res) {
++			printf("[FAIL]\tCX (saved SP) mismatch: requested 0x%llx; got 0x%llx\n",
++			       (unsigned long long)req,
++			       (unsigned long long)res);
++			nerrs++;
++			continue;
++		}
++
++		if (req != res && !ignore_reg) {
++			printf("[FAIL]\tReg %d mismatch: requested 0x%llx; got 0x%llx\n",
++			       i, (unsigned long long)req,
++			       (unsigned long long)res);
++			nerrs++;
++		}
++	}
++
++	if (nerrs == 0)
++		printf("[OK]\tall registers okay\n");
++
++	return nerrs;
++}
++
++static int test_bad_iret(int cs_bits, unsigned short ss, int force_cs)
++{
++	int cs = force_cs == -1 ? find_cs(cs_bits) : force_cs;
++	if (cs == -1)
++		return 0;
++
++	sig_cs = cs;
++	sig_ss = ss;
++
++	printf("[RUN]\t%d-bit CS (%hx), bogus SS (%hx)\n",
++	       cs_bits, sig_cs, sig_ss);
++
++	sig_trapped = 0;
++	raise(SIGUSR1);
++	if (sig_trapped) {
++		char errdesc[32] = "";
++		if (sig_err) {
++			const char *src = (sig_err & 1) ? " EXT" : "";
++			const char *table;
++			if ((sig_err & 0x6) == 0x0)
++				table = "GDT";
++			else if ((sig_err & 0x6) == 0x4)
++				table = "LDT";
++			else if ((sig_err & 0x6) == 0x2)
++				table = "IDT";
++			else
++				table = "???";
++
++			sprintf(errdesc, "%s%s index %d, ",
++				table, src, sig_err >> 3);
++		}
++
++		char trapname[32];
++		if (sig_trapno == 13)
++			strcpy(trapname, "GP");
++		else if (sig_trapno == 11)
++			strcpy(trapname, "NP");
++		else if (sig_trapno == 12)
++			strcpy(trapname, "SS");
++		else if (sig_trapno == 32)
++			strcpy(trapname, "IRET");  /* X86_TRAP_IRET */
++		else
++			sprintf(trapname, "%d", sig_trapno);
++
++		printf("[OK]\tGot #%s(0x%lx) (i.e. %s%s)\n",
++		       trapname, (unsigned long)sig_err,
++		       errdesc, strsignal(sig_trapped));
++		return 0;
++	} else {
++		/*
++		 * This also implicitly tests UC_STRICT_RESTORE_SS:
++		 * We check that these signals set UC_STRICT_RESTORE_SS and,
++		 * if UC_STRICT_RESTORE_SS doesn't cause strict behavior,
++		 * then we won't get SIGSEGV.
++		 */
++		printf("[FAIL]\tDid not get SIGSEGV\n");
++		return 1;
++	}
++}
++
++static int
++do_test (void)
++{
++	int total_nerrs = 0;
++	unsigned short my_cs, my_ss;
++
++#if defined(__x86_64__) && defined(__CET__)
++	void *ssp_base;
++	unsigned long ssp_64, ssp_32;
++
++	ssp_64 = _get_ssp();
++
++	if (ssp_64 != 0) {
++		/* Allocate a shadow stack within 32-bit address range */
++		ssp_base = mmap (0, 0x1000, PROT_READ | PROT_WRITE,
++				 MAP_ANONYMOUS | MAP_PRIVATE | MAP_32BIT,
++				 -1, 0);
++		if (ssp_base == MAP_FAILED) {
++			printf("[FAIL]\tCannot allocate shadow stack\n");
++			return 1;
++		}
++
++		/*
++		 * The top of shadow stack is an 8-byte token, point ssp_32
++		 * to the token.
++		 */
++		ssp_32 = (uintptr_t) ssp_base + 0x1000 - 8;
++		/* Store the token.  */
++		*(unsigned long long *) ((uintptr_t) ssp_32)
++			= (uintptr_t) (ssp_base + 0x1001);
++		/* Enable shadow stack with PROT_SHSTK.  */
++		if (mprotect (ssp_base, 0x1000, PROT_READ | PROT_SHSTK)) {
++			printf("[FAIL]\tCannot enable shadow stack\n");
++			return 1;
++		}
++		asm volatile("rstorssp (%0)\n":: "r" (ssp_32));
++		asm volatile("saveprevssp");
++	}
++#endif
++
++	asm volatile ("mov %%cs,%0" : "=r" (my_cs));
++	asm volatile ("mov %%ss,%0" : "=r" (my_ss));
++	setup_ldt();
++
++	stack_t stack = {
++		.ss_sp = altstack_data,
++		.ss_size = SIGSTKSZ,
++	};
++	if (sigaltstack(&stack, NULL) != 0)
++		err(1, "sigaltstack");
++
++	sethandler(SIGUSR1, sigusr1, 0);
++	sethandler(SIGTRAP, sigtrap, SA_ONSTACK);
++
++	/* Easy cases: return to a 32-bit SS in each possible CS bitness. */
++	total_nerrs += test_valid_sigreturn(64, false, -1);
++	total_nerrs += test_valid_sigreturn(32, false, -1);
++	total_nerrs += test_valid_sigreturn(16, false, -1);
++
++	/*
++	 * Test easy espfix cases: return to a 16-bit LDT SS in each possible
++	 * CS bitness.  NB: with a long mode CS, the SS bitness is irrelevant.
++	 *
++	 * This catches the original missing-espfix-on-64-bit-kernels issue
++	 * as well as CVE-2014-8134.
++	 */
++	total_nerrs += test_valid_sigreturn(64, true, -1);
++	total_nerrs += test_valid_sigreturn(32, true, -1);
++	total_nerrs += test_valid_sigreturn(16, true, -1);
++
++	if (gdt_data16_idx) {
++		/*
++		 * For performance reasons, Linux skips espfix if SS points
++		 * to the GDT.  If we were able to allocate a 16-bit SS in
++		 * the GDT, see if it leaks parts of the kernel stack pointer.
++		 *
++		 * This tests for CVE-2014-8133.
++		 */
++		total_nerrs += test_valid_sigreturn(64, true,
++						    GDT3(gdt_data16_idx));
++		total_nerrs += test_valid_sigreturn(32, true,
++						    GDT3(gdt_data16_idx));
++		total_nerrs += test_valid_sigreturn(16, true,
++						    GDT3(gdt_data16_idx));
++	}
++
++#ifdef __x86_64__
++	/* Nasty ABI case: check SS corruption handling. */
++	sig_corrupt_final_ss = 1;
++	total_nerrs += test_valid_sigreturn(32, false, -1);
++	total_nerrs += test_valid_sigreturn(32, true, -1);
++	sig_corrupt_final_ss = 0;
++#endif
++
++	/*
++	 * We're done testing valid sigreturn cases.  Now we test states
++	 * for which sigreturn itself will succeed but the subsequent
++	 * entry to user mode will fail.
++	 *
++	 * Depending on the failure mode and the kernel bitness, these
++	 * entry failures can generate SIGSEGV, SIGBUS, or SIGILL.
++	 */
++	clearhandler(SIGTRAP);
++	sethandler(SIGSEGV, sigtrap, SA_ONSTACK);
++	sethandler(SIGBUS, sigtrap, SA_ONSTACK);
++	sethandler(SIGILL, sigtrap, SA_ONSTACK);  /* 32-bit kernels do this */
++
++	/* Easy failures: invalid SS, resulting in #GP(0) */
++	test_bad_iret(64, ldt_nonexistent_sel, -1);
++	test_bad_iret(32, ldt_nonexistent_sel, -1);
++	test_bad_iret(16, ldt_nonexistent_sel, -1);
++
++	/* These fail because SS isn't a data segment, resulting in #GP(SS) */
++	test_bad_iret(64, my_cs, -1);
++	test_bad_iret(32, my_cs, -1);
++	test_bad_iret(16, my_cs, -1);
++
++	/* Try to return to a not-present code segment, triggering #NP(SS). */
++	test_bad_iret(32, my_ss, npcode32_sel);
++
++	/*
++	 * Try to return to a not-present but otherwise valid data segment.
++	 * This will cause IRET to fail with #SS on the espfix stack.  This
++	 * exercises CVE-2014-9322.
++	 *
++	 * Note that, if espfix is enabled, 64-bit Linux will lose track
++	 * of the actual cause of failure and report #GP(0) instead.
++	 * This would be very difficult for Linux to avoid, because
++	 * espfix64 causes IRET failures to be promoted to #DF, so the
++	 * original exception frame is never pushed onto the stack.
++	 */
++	test_bad_iret(32, npdata32_sel, -1);
++
++	/*
++	 * Try to return to a not-present but otherwise valid data
++	 * segment without invoking espfix.  Newer kernels don't allow
++	 * this to happen in the first place.  On older kernels, though,
++	 * this can trigger CVE-2014-9322.
++	 */
++	if (gdt_npdata32_idx)
++		test_bad_iret(32, GDT3(gdt_npdata32_idx), -1);
++
++#ifdef __x86_64__
++	total_nerrs += test_nonstrict_ss();
++
++#ifdef __CET__
++	if (ssp_64 != 0) {
++		/* Point ssp_64 to the restore token */
++		ssp_64 -= 8;
++		asm volatile("rstorssp (%0)\n":: "r" (ssp_64));
++		asm volatile("saveprevssp");
++		munmap(ssp_base, 0x1000);
++	}
++#endif
++#endif
++
++	return total_nerrs ? 1 : 0;
++}
++
++#include <support/test-driver.c>
+-- 
+2.31.1
+
diff --git a/0003-Add-cast_to_pointer-to-cast-an-integer-to-void-point.patch b/0003-Add-cast_to_pointer-to-cast-an-integer-to-void-point.patch
new file mode 100644
index 0000000..4cd3dc3
--- /dev/null
+++ b/0003-Add-cast_to_pointer-to-cast-an-integer-to-void-point.patch
@@ -0,0 +1,28 @@
+From 9275e01d2adba7ac5379357739682e0f2f750c89 Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Fri, 21 May 2021 15:58:36 -0700
+Subject: [PATCH 03/24] Add cast_to_pointer to cast an integer to void *
+ pointer
+
+(cherry picked from commit 94bc766ec627b2c44a6c72bc40013957ffc4b6cd)
+---
+ include/libc-pointer-arith.h | 3 +++
+ 1 file changed, 3 insertions(+)
+
+diff --git a/include/libc-pointer-arith.h b/include/libc-pointer-arith.h
+index 72e722c5aa..04ba537617 100644
+--- a/include/libc-pointer-arith.h
++++ b/include/libc-pointer-arith.h
+@@ -37,6 +37,9 @@
+ /* Cast an integer or a pointer VAL to integer with proper type.  */
+ # define cast_to_integer(val) ((__integer_if_pointer_type (val)) (val))
+ 
++/* Cast an integer VAL to void * pointer.  */
++# define cast_to_pointer(val) ((void *) (uintptr_t) (val))
++
+ /* Align a value by rounding down to closest size.
+    e.g. Using size of 4096, we get this behavior:
+ 	{4095, 4096, 4097} = {0, 4096, 4096}.  */
+-- 
+2.31.1
+
diff --git a/0004-Add-an-internal-wrapper-for-clone-clone2-and-clone3.patch b/0004-Add-an-internal-wrapper-for-clone-clone2-and-clone3.patch
new file mode 100644
index 0000000..8a8752a
--- /dev/null
+++ b/0004-Add-an-internal-wrapper-for-clone-clone2-and-clone3.patch
@@ -0,0 +1,350 @@
+From 2b760d4bbc9f53cfaf03b4cfbe57f0f747bf280a Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Sat, 13 Feb 2021 11:47:46 -0800
+Subject: [PATCH 04/24] Add an internal wrapper for clone, clone2 and clone3
+
+The clone3 system call provides a superset of the functionality of clone
+and clone2.  It also provides a number of API improvements, including
+the ability to specify the size of the child's stack area which can be
+used by kernel to compute the shadow stack size when allocating the
+shadow stack.  Add:
+
+extern int __clone_internal (struct clone_args *__cl_args,
+			     int (*__func) (void *__arg), void *__arg);
+
+to provide an abstract interface for clone, clone2 and clone3.
+
+1. Simplify stack management for thread creation by passing both stack
+base and size to create_thread.
+2. Consolidate clone vs clone2 differences into a single file.
+3. Use only __clone_internal to clone a thread.
+4. Call __clone3 if HAVE_CLONE3_WAPPER is defined.  If __clone3 returns
+-1 with ENOSYS, fall back to clone or clone2.
+5. Enable the public clone3 wrapper in the future after it has been
+added to all targets.
+---
+ include/clone_internal.h                 | 16 +++++
+ sysdeps/unix/sysv/linux/Makefile         |  2 +-
+ sysdeps/unix/sysv/linux/clone-internal.c | 91 ++++++++++++++++++++++++
+ sysdeps/unix/sysv/linux/clone3.c         |  1 +
+ sysdeps/unix/sysv/linux/clone3.h         | 60 ++++++++++++++++
+ sysdeps/unix/sysv/linux/createthread.c   | 25 ++++---
+ sysdeps/unix/sysv/linux/spawni.c         | 26 +++----
+ 7 files changed, 193 insertions(+), 28 deletions(-)
+ create mode 100644 include/clone_internal.h
+ create mode 100644 sysdeps/unix/sysv/linux/clone-internal.c
+ create mode 100644 sysdeps/unix/sysv/linux/clone3.c
+ create mode 100644 sysdeps/unix/sysv/linux/clone3.h
+
+diff --git a/include/clone_internal.h b/include/clone_internal.h
+new file mode 100644
+index 0000000000..4b23ef33ce
+--- /dev/null
++++ b/include/clone_internal.h
+@@ -0,0 +1,16 @@
++#ifndef _CLONE3_H
++#include_next <clone3.h>
++
++extern __typeof (clone3) __clone3;
++
++/* The internal wrapper of clone/clone2 and clone3.  If __clone3 returns
++   -1 with ENOSYS, fall back to clone or clone2.  */
++extern int __clone_internal (struct clone_args *__cl_args,
++			     int (*__func) (void *__arg), void *__arg);
++
++#ifndef _ISOMAC
++libc_hidden_proto (__clone3)
++libc_hidden_proto (__clone_internal)
++#endif
++
++#endif
+diff --git a/sysdeps/unix/sysv/linux/Makefile b/sysdeps/unix/sysv/linux/Makefile
+index 472eab700d..23dd99c2e8 100644
+--- a/sysdeps/unix/sysv/linux/Makefile
++++ b/sysdeps/unix/sysv/linux/Makefile
+@@ -64,7 +64,7 @@ sysdep_routines += adjtimex clone umount umount2 readahead sysctl \
+ 		   time64-support pselect32 \
+ 		   xstat fxstat lxstat xstat64 fxstat64 lxstat64 \
+ 		   fxstatat fxstatat64 \
+-		   xmknod xmknodat
++		   xmknod xmknodat clone3 clone-internal
+ 
+ CFLAGS-gethostid.c = -fexceptions
+ CFLAGS-tee.c = -fexceptions -fasynchronous-unwind-tables
+diff --git a/sysdeps/unix/sysv/linux/clone-internal.c b/sysdeps/unix/sysv/linux/clone-internal.c
+new file mode 100644
+index 0000000000..1e7a8f6b35
+--- /dev/null
++++ b/sysdeps/unix/sysv/linux/clone-internal.c
+@@ -0,0 +1,91 @@
++/* The internal wrapper of clone and clone3.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library.  If not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <sysdep.h>
++#include <stddef.h>
++#include <errno.h>
++#include <sched.h>
++#include <clone_internal.h>
++#include <libc-pointer-arith.h>	/* For cast_to_pointer.  */
++#include <stackinfo.h>		/* For _STACK_GROWS_{UP,DOWN}.  */
++
++#define CLONE_ARGS_SIZE_VER0 64 /* sizeof first published struct */
++#define CLONE_ARGS_SIZE_VER1 80 /* sizeof second published struct */
++#define CLONE_ARGS_SIZE_VER2 88 /* sizeof third published struct */
++
++#define sizeof_field(TYPE, MEMBER) sizeof ((((TYPE *)0)->MEMBER))
++#define offsetofend(TYPE, MEMBER) \
++  (offsetof (TYPE, MEMBER) + sizeof_field (TYPE, MEMBER))
++
++_Static_assert (__alignof (struct clone_args) == 8,
++		"__alignof (struct clone_args) != 8");
++_Static_assert (offsetofend (struct clone_args, tls) == CLONE_ARGS_SIZE_VER0,
++		"offsetofend (struct clone_args, tls) != CLONE_ARGS_SIZE_VER0");
++_Static_assert (offsetofend (struct clone_args, set_tid_size) == CLONE_ARGS_SIZE_VER1,
++		"offsetofend (struct clone_args, set_tid_size) != CLONE_ARGS_SIZE_VER1");
++_Static_assert (offsetofend (struct clone_args, cgroup) == CLONE_ARGS_SIZE_VER2,
++		"offsetofend (struct clone_args, cgroup) != CLONE_ARGS_SIZE_VER2");
++_Static_assert (sizeof (struct clone_args) == CLONE_ARGS_SIZE_VER2,
++		"sizeof (struct clone_args) != CLONE_ARGS_SIZE_VER2");
++
++int
++__clone_internal (struct clone_args *cl_args,
++		  int (*func) (void *arg), void *arg)
++{
++  int ret;
++#ifdef HAVE_CLONE3_WAPPER
++  /* Try clone3 first.  */
++  int saved_errno = errno;
++  ret = __clone3 (cl_args, sizeof (*cl_args), func, arg);
++  if (ret != -1 || errno != ENOSYS)
++    return ret;
++
++  /* NB: Restore errno since errno may be checked against non-zero
++     return value.  */
++  __set_errno (saved_errno);
++#endif
++
++  /* Map clone3 arguments to clone arguments.  NB: No need to check
++     invalid clone3 specific bits in flags nor exit_signal since this
++     is an internal function.  */
++  int flags = cl_args->flags | cl_args->exit_signal;
++  void *stack = cast_to_pointer (cl_args->stack);
++
++#ifdef __ia64__
++  ret = __clone2 (func, stack, cl_args->stack_size,
++		  flags, arg,
++		  cast_to_pointer (cl_args->parent_tid),
++		  cast_to_pointer (cl_args->tls),
++		  cast_to_pointer (cl_args->child_tid));
++#else
++# if !_STACK_GROWS_DOWN && !_STACK_GROWS_UP
++#  error "Define either _STACK_GROWS_DOWN or _STACK_GROWS_UP"
++# endif
++
++# if _STACK_GROWS_DOWN
++  stack += cl_args->stack_size;
++# endif
++  ret = __clone (func, stack, flags, arg,
++		 cast_to_pointer (cl_args->parent_tid),
++		 cast_to_pointer (cl_args->tls),
++		 cast_to_pointer (cl_args->child_tid));
++#endif
++  return ret;
++}
++
++libc_hidden_def (__clone_internal)
+diff --git a/sysdeps/unix/sysv/linux/clone3.c b/sysdeps/unix/sysv/linux/clone3.c
+new file mode 100644
+index 0000000000..de963ef89d
+--- /dev/null
++++ b/sysdeps/unix/sysv/linux/clone3.c
+@@ -0,0 +1 @@
++/* An empty placeholder.  */
+diff --git a/sysdeps/unix/sysv/linux/clone3.h b/sysdeps/unix/sysv/linux/clone3.h
+new file mode 100644
+index 0000000000..0488884d59
+--- /dev/null
++++ b/sysdeps/unix/sysv/linux/clone3.h
+@@ -0,0 +1,60 @@
++/* The wrapper of clone3.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library.  If not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#ifndef _CLONE3_H
++#define _CLONE3_H	1
++
++#include <features.h>
++#include <stdint.h>
++#include <stddef.h>
++
++__BEGIN_DECLS
++
++/* This struct should only be used in an argument to the clone3 system
++   call (along with its size argument).  It may be extended with new
++   fields in the future.  */
++
++struct clone_args
++{
++  uint64_t flags;	 /* Flags bit mask.  */
++  uint64_t pidfd;	 /* Where to store PID file descriptor
++			    (pid_t *).  */
++  uint64_t child_tid;	 /* Where to store child TID, in child's memory
++			    (pid_t *).  */
++  uint64_t parent_tid;	 /* Where to store child TID, in parent's memory
++			    (int *). */
++  uint64_t exit_signal;	 /* Signal to deliver to parent on child
++			    termination */
++  uint64_t stack;	 /* The lowest address of stack.  */
++  uint64_t stack_size;	 /* Size of stack.  */
++  uint64_t tls;		 /* Location of new TLS.  */
++  uint64_t set_tid;	 /* Pointer to a pid_t array
++			    (since Linux 5.5).  */
++  uint64_t set_tid_size; /* Number of elements in set_tid
++			    (since Linux 5.5). */
++  uint64_t cgroup;	 /* File descriptor for target cgroup
++			    of child (since Linux 5.7).  */
++} __attribute__ ((aligned (8)));
++
++/* The wrapper of clone3.  */
++extern int clone3 (struct clone_args *__cl_args, size_t __size,
++		   int (*__func) (void *__arg), void *__arg);
++
++__END_DECLS
++
++#endif /* clone3.h */
+diff --git a/sysdeps/unix/sysv/linux/createthread.c b/sysdeps/unix/sysv/linux/createthread.c
+index bc3409b326..406c73ba00 100644
+--- a/sysdeps/unix/sysv/linux/createthread.c
++++ b/sysdeps/unix/sysv/linux/createthread.c
+@@ -25,15 +25,10 @@
+ #include <ldsodefs.h>
+ #include <tls.h>
+ #include <stdint.h>
++#include <clone_internal.h>
+ 
+ #include <arch-fork.h>
+ 
+-#ifdef __NR_clone2
+-# define ARCH_CLONE __clone2
+-#else
+-# define ARCH_CLONE __clone
+-#endif
+-
+ /* See the comments in pthread_create.c for the requirements for these
+    two macros and the create_thread function.  */
+ 
+@@ -47,7 +42,8 @@ static int start_thread (void *arg) __attribute__ ((noreturn));
+ 
+ static int
+ create_thread (struct pthread *pd, const struct pthread_attr *attr,
+-	       bool *stopped_start, STACK_VARIABLES_PARMS, bool *thread_ran)
++	       bool *stopped_start, void *stackaddr, size_t stacksize,
++	       bool *thread_ran)
+ {
+   /* Determine whether the newly created threads has to be started
+      stopped since we have to set the scheduling parameters or set the
+@@ -100,9 +96,18 @@ create_thread (struct pthread *pd, const struct pthread_attr *attr,
+ 
+   TLS_DEFINE_INIT_TP (tp, pd);
+ 
+-  if (__glibc_unlikely (ARCH_CLONE (&start_thread, STACK_VARIABLES_ARGS,
+-				    clone_flags, pd, &pd->tid, tp, &pd->tid)
+-			== -1))
++  struct clone_args args =
++    {
++      .flags = clone_flags,
++      .pidfd = (uintptr_t) &pd->tid,
++      .parent_tid = (uintptr_t) &pd->tid,
++      .child_tid = (uintptr_t) &pd->tid,
++      .stack = (uintptr_t) stackaddr,
++      .stack_size = stacksize,
++      .tls = (uintptr_t) tp,
++    };
++  int ret = __clone_internal (&args, &start_thread, pd);
++  if (__glibc_unlikely (ret == -1))
+     return errno;
+ 
+   /* It's started now, so if we fail below, we'll have to cancel it
+diff --git a/sysdeps/unix/sysv/linux/spawni.c b/sysdeps/unix/sysv/linux/spawni.c
+index b53b81b8fc..30cc8fa4a9 100644
+--- a/sysdeps/unix/sysv/linux/spawni.c
++++ b/sysdeps/unix/sysv/linux/spawni.c
+@@ -31,6 +31,7 @@
+ #include <dl-sysdep.h>
+ #include <libc-pointer-arith.h>
+ #include <ldsodefs.h>
++#include <clone_internal.h>
+ #include "spawn_int.h"
+ 
+ /* The Linux implementation of posix_spawn{p} uses the clone syscall directly
+@@ -59,21 +60,6 @@
+    normal program exit with the exit code 127.  */
+ #define SPAWN_ERROR	127
+ 
+-#ifdef __ia64__
+-# define CLONE(__fn, __stackbase, __stacksize, __flags, __args) \
+-  __clone2 (__fn, __stackbase, __stacksize, __flags, __args, 0, 0, 0)
+-#else
+-# define CLONE(__fn, __stack, __stacksize, __flags, __args) \
+-  __clone (__fn, __stack, __flags, __args)
+-#endif
+-
+-/* Since ia64 wants the stackbase w/clone2, re-use the grows-up macro.  */
+-#if _STACK_GROWS_UP || defined (__ia64__)
+-# define STACK(__stack, __stack_size) (__stack)
+-#elif _STACK_GROWS_DOWN
+-# define STACK(__stack, __stack_size) (__stack + __stack_size)
+-#endif
+-
+ 
+ struct posix_spawn_args
+ {
+@@ -379,8 +365,14 @@ __spawnix (pid_t * pid, const char *file,
+      need for CLONE_SETTLS.  Although parent and child share the same TLS
+      namespace, there will be no concurrent access for TLS variables (errno
+      for instance).  */
+-  new_pid = CLONE (__spawni_child, STACK (stack, stack_size), stack_size,
+-		   CLONE_VM | CLONE_VFORK | SIGCHLD, &args);
++  struct clone_args clone_args =
++    {
++      .flags = CLONE_VM | CLONE_VFORK,
++      .exit_signal = SIGCHLD,
++      .stack = (uintptr_t) stack,
++      .stack_size = stack_size,
++    };
++  new_pid = __clone_internal (&clone_args, __spawni_child, &args);
+ 
+   /* It needs to collect the case where the auxiliary process was created
+      but failed to execute the file (due either any preparation step or
+-- 
+2.31.1
+
diff --git a/0005-nptl-Always-pass-stack-size-to-create_thread.patch b/0005-nptl-Always-pass-stack-size-to-create_thread.patch
new file mode 100644
index 0000000..0bb0b6c
--- /dev/null
+++ b/0005-nptl-Always-pass-stack-size-to-create_thread.patch
@@ -0,0 +1,177 @@
+From 2aa613e38ab5ae80fa9d49b4240a1861c6164924 Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Mon, 10 May 2021 12:10:01 -0700
+Subject: [PATCH 05/24] nptl: Always pass stack size to create_thread
+
+Since the stack size argument for create_thread is now unconditional,
+always pass stack size to create_thread.
+---
+ nptl/allocatestack.c  | 59 ++++---------------------------------------
+ nptl/createthread.c   |  3 ++-
+ nptl/pthread_create.c | 17 +++++++------
+ 3 files changed, 16 insertions(+), 63 deletions(-)
+
+diff --git a/nptl/allocatestack.c b/nptl/allocatestack.c
+index 149b999603..73c7f33a00 100644
+--- a/nptl/allocatestack.c
++++ b/nptl/allocatestack.c
+@@ -34,47 +34,6 @@
+ #include <stack-aliasing.h>
+ 
+ 
+-#ifndef NEED_SEPARATE_REGISTER_STACK
+-
+-/* Most architectures have exactly one stack pointer.  Some have more.  */
+-# define STACK_VARIABLES void *stackaddr = NULL
+-
+-/* How to pass the values to the 'create_thread' function.  */
+-# define STACK_VARIABLES_ARGS stackaddr
+-
+-/* How to declare function which gets there parameters.  */
+-# define STACK_VARIABLES_PARMS void *stackaddr
+-
+-/* How to declare allocate_stack.  */
+-# define ALLOCATE_STACK_PARMS void **stack
+-
+-/* This is how the function is called.  We do it this way to allow
+-   other variants of the function to have more parameters.  */
+-# define ALLOCATE_STACK(attr, pd) allocate_stack (attr, pd, &stackaddr)
+-
+-#else
+-
+-/* We need two stacks.  The kernel will place them but we have to tell
+-   the kernel about the size of the reserved address space.  */
+-# define STACK_VARIABLES void *stackaddr = NULL; size_t stacksize = 0
+-
+-/* How to pass the values to the 'create_thread' function.  */
+-# define STACK_VARIABLES_ARGS stackaddr, stacksize
+-
+-/* How to declare function which gets there parameters.  */
+-# define STACK_VARIABLES_PARMS void *stackaddr, size_t stacksize
+-
+-/* How to declare allocate_stack.  */
+-# define ALLOCATE_STACK_PARMS void **stack, size_t *stacksize
+-
+-/* This is how the function is called.  We do it this way to allow
+-   other variants of the function to have more parameters.  */
+-# define ALLOCATE_STACK(attr, pd) \
+-  allocate_stack (attr, pd, &stackaddr, &stacksize)
+-
+-#endif
+-
+-
+ /* Default alignment of stack.  */
+ #ifndef STACK_ALIGN
+ # define STACK_ALIGN __alignof__ (long double)
+@@ -399,7 +358,7 @@ advise_stack_range (void *mem, size_t size, uintptr_t pd, size_t guardsize)
+    PDP must be non-NULL.  */
+ static int
+ allocate_stack (const struct pthread_attr *attr, struct pthread **pdp,
+-		ALLOCATE_STACK_PARMS)
++		void **stack, size_t *stacksize)
+ {
+   struct pthread *pd;
+   size_t size;
+@@ -760,25 +719,17 @@ allocate_stack (const struct pthread_attr *attr, struct pthread **pdp,
+   /* We place the thread descriptor at the end of the stack.  */
+   *pdp = pd;
+ 
+-#if _STACK_GROWS_DOWN
+   void *stacktop;
+ 
+-# if TLS_TCB_AT_TP
++#if TLS_TCB_AT_TP
+   /* The stack begins before the TCB and the static TLS block.  */
+   stacktop = ((char *) (pd + 1) - __static_tls_size);
+-# elif TLS_DTV_AT_TP
++#elif TLS_DTV_AT_TP
+   stacktop = (char *) (pd - 1);
+-# endif
++#endif
+ 
+-# ifdef NEED_SEPARATE_REGISTER_STACK
+-  *stack = pd->stackblock;
+-  *stacksize = stacktop - *stack;
+-# else
+-  *stack = stacktop;
+-# endif
+-#else
++  *stacksize = stacktop - pd->stackblock;
+   *stack = pd->stackblock;
+-#endif
+ 
+   return 0;
+ }
+diff --git a/nptl/createthread.c b/nptl/createthread.c
+index 46943b33fe..2ac83111ec 100644
+--- a/nptl/createthread.c
++++ b/nptl/createthread.c
+@@ -25,7 +25,8 @@
+ 
+ static int
+ create_thread (struct pthread *pd, const struct pthread_attr *attr,
+-	       bool *stopped_start, STACK_VARIABLES_PARMS, bool *thread_ran)
++	       bool *stopped_start, void *stackaddr, size_t stacksize,
++	       bool *thread_ran)
+ {
+   /* If the implementation needs to do some tweaks to the thread after
+      it has been created at the OS level, it can set STOPPED_START here.  */
+diff --git a/nptl/pthread_create.c b/nptl/pthread_create.c
+index f13d8e44a4..2e5bc1ae7e 100644
+--- a/nptl/pthread_create.c
++++ b/nptl/pthread_create.c
+@@ -209,8 +209,8 @@ unsigned int __nptl_nthreads = 1;
+    be set to true iff the thread actually started up and then got
+    canceled before calling user code (*PD->start_routine).  */
+ static int create_thread (struct pthread *pd, const struct pthread_attr *attr,
+-			  bool *stopped_start, STACK_VARIABLES_PARMS,
+-			  bool *thread_ran);
++			  bool *stopped_start, void *stackaddr,
++			  size_t stacksize, bool *thread_ran);
+ 
+ #include <createthread.c>
+ 
+@@ -629,7 +629,8 @@ int
+ __pthread_create_2_1 (pthread_t *newthread, const pthread_attr_t *attr,
+ 		      void *(*start_routine) (void *), void *arg)
+ {
+-  STACK_VARIABLES;
++  void *stackaddr = NULL;
++  size_t stacksize = 0;
+ 
+   /* Avoid a data race in the multi-threaded case.  */
+   if (__libc_single_threaded)
+@@ -649,7 +650,7 @@ __pthread_create_2_1 (pthread_t *newthread, const pthread_attr_t *attr,
+     }
+ 
+   struct pthread *pd = NULL;
+-  int err = ALLOCATE_STACK (iattr, &pd);
++  int err = allocate_stack (iattr, &pd, &stackaddr, &stacksize);
+   int retval = 0;
+ 
+   if (__glibc_unlikely (err != 0))
+@@ -794,8 +795,8 @@ __pthread_create_2_1 (pthread_t *newthread, const pthread_attr_t *attr,
+ 
+       /* We always create the thread stopped at startup so we can
+ 	 notify the debugger.  */
+-      retval = create_thread (pd, iattr, &stopped_start,
+-			      STACK_VARIABLES_ARGS, &thread_ran);
++      retval = create_thread (pd, iattr, &stopped_start, stackaddr,
++			      stacksize, &thread_ran);
+       if (retval == 0)
+ 	{
+ 	  /* We retain ownership of PD until (a) (see CONCURRENCY NOTES
+@@ -826,8 +827,8 @@ __pthread_create_2_1 (pthread_t *newthread, const pthread_attr_t *attr,
+ 	}
+     }
+   else
+-    retval = create_thread (pd, iattr, &stopped_start,
+-			    STACK_VARIABLES_ARGS, &thread_ran);
++    retval = create_thread (pd, iattr, &stopped_start, stackaddr,
++			    stacksize, &thread_ran);
+ 
+   /* Return to the previous signal mask, after creating the new
+      thread.  */
+-- 
+2.31.1
+
diff --git a/0006-x86-64-Add-the-clone3-wrapper.patch b/0006-x86-64-Add-the-clone3-wrapper.patch
new file mode 100644
index 0000000..dbaf45b
--- /dev/null
+++ b/0006-x86-64-Add-the-clone3-wrapper.patch
@@ -0,0 +1,127 @@
+From 80a23737af9dbe977030ad24e25b6c11c95bee8b Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Thu, 13 May 2021 08:24:36 -0700
+Subject: [PATCH 06/24] x86-64: Add the clone3 wrapper
+
+extern int clone3 (struct clone_args *__cl_args, size_t __size,
+		   int (*__func) (void *__arg), void *__arg);
+---
+ sysdeps/unix/sysv/linux/x86_64/clone3.S | 92 +++++++++++++++++++++++++
+ sysdeps/unix/sysv/linux/x86_64/sysdep.h |  2 +
+ 2 files changed, 94 insertions(+)
+ create mode 100644 sysdeps/unix/sysv/linux/x86_64/clone3.S
+
+diff --git a/sysdeps/unix/sysv/linux/x86_64/clone3.S b/sysdeps/unix/sysv/linux/x86_64/clone3.S
+new file mode 100644
+index 0000000000..71caaecc29
+--- /dev/null
++++ b/sysdeps/unix/sysv/linux/x86_64/clone3.S
+@@ -0,0 +1,92 @@
++/* The clone3 syscall wrapper.  Linux/x86-64 version.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++/* clone3() is even more special than fork() as it mucks with stacks
++   and invokes a function in the right context after its all over.  */
++
++#include <sysdep.h>
++
++/* The userland implementation is:
++   int clone3 (struct clone_args *cl_args, size_t size,
++	       int (*func)(void *arg), void *arg);
++   the kernel entry is:
++   int clone3 (struct clone_args *cl_args, size_t size);
++
++   The parameters are passed in registers from userland:
++   rdi: cl_args
++   rsi: size
++   rdx: func
++   rcx: arg
++
++   The kernel expects:
++   rax: system call number
++   rdi: cl_args
++   rsi: size  */
++
++        .text
++ENTRY (__clone3)
++	/* Sanity check arguments.  */
++	movl	$-EINVAL, %eax
++	test	%RDI_LP, %RDI_LP	/* No NULL cl_args pointer.  */
++	jz	SYSCALL_ERROR_LABEL
++	test	%RDX_LP, %RDX_LP	/* No NULL function pointer.  */
++	jz	SYSCALL_ERROR_LABEL
++
++	/* Save the cl_args pointer in R8 which is preserved by the
++	   syscall.  */
++	mov	%RCX_LP, %R8_LP
++
++	/* Do the system call.  */
++	movl	$SYS_ify(clone3), %eax
++
++	/* End FDE now, because in the child the unwind info will be
++	   wrong.  */
++	cfi_endproc
++	syscall
++
++	test	%RAX_LP, %RAX_LP
++	jl	SYSCALL_ERROR_LABEL
++	jz	L(thread_start)
++
++	ret
++
++L(thread_start):
++	cfi_startproc
++	/* Clearing frame pointer is insufficient, use CFI.  */
++	cfi_undefined (rip)
++	/* Clear the frame pointer.  The ABI suggests this be done, to mark
++	   the outermost frame obviously.  */
++	xorl	%ebp, %ebp
++
++	/* Align stack to 16 bytes per the x86-64 psABI.  */
++	and	$-16, %RSP_LP
++
++	/* Set up arguments for the function call.  */
++	mov	%R8_LP, %RDI_LP	/* Argument.  */
++	call	*%rdx		/* Call function.  */
++	/* Call exit with return value from function call. */
++	movq	%rax, %rdi
++	movl	$SYS_ify(exit), %eax
++	syscall
++	cfi_endproc
++
++	cfi_startproc
++PSEUDO_END (__clone3)
++
++libc_hidden_def (__clone3)
++weak_alias (__clone3, clone3)
+diff --git a/sysdeps/unix/sysv/linux/x86_64/sysdep.h b/sysdeps/unix/sysv/linux/x86_64/sysdep.h
+index dbad2c788a..f26ffc68ae 100644
+--- a/sysdeps/unix/sysv/linux/x86_64/sysdep.h
++++ b/sysdeps/unix/sysv/linux/x86_64/sysdep.h
+@@ -377,6 +377,8 @@
+ # define HAVE_GETCPU_VSYSCALL		"__vdso_getcpu"
+ # define HAVE_CLOCK_GETRES64_VSYSCALL   "__vdso_clock_getres"
+ 
++# define HAVE_CLONE3_WAPPER			1
++
+ # define SINGLE_THREAD_BY_GLOBAL		1
+ 
+ #endif	/* __ASSEMBLER__ */
+-- 
+2.31.1
+
diff --git a/0007-Add-static-tests-for-__clone_internal.patch b/0007-Add-static-tests-for-__clone_internal.patch
new file mode 100644
index 0000000..49980a5
--- /dev/null
+++ b/0007-Add-static-tests-for-__clone_internal.patch
@@ -0,0 +1,517 @@
+From 64058f28ade5dd43140171daf7a49afa477fe8b6 Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Fri, 14 May 2021 15:23:46 -0700
+Subject: [PATCH 07/24] Add static tests for __clone_internal
+
+---
+ sysdeps/unix/sysv/linux/Makefile              |   8 +
+ .../sysv/linux/tst-align-clone-internal.c     |  86 +++++++++++
+ sysdeps/unix/sysv/linux/tst-clone2-internal.c | 137 ++++++++++++++++++
+ sysdeps/unix/sysv/linux/tst-clone3-internal.c |  99 +++++++++++++
+ .../unix/sysv/linux/tst-getpid1-internal.c    | 132 +++++++++++++++++
+ 5 files changed, 462 insertions(+)
+ create mode 100644 sysdeps/unix/sysv/linux/tst-align-clone-internal.c
+ create mode 100644 sysdeps/unix/sysv/linux/tst-clone2-internal.c
+ create mode 100644 sysdeps/unix/sysv/linux/tst-clone3-internal.c
+ create mode 100644 sysdeps/unix/sysv/linux/tst-getpid1-internal.c
+
+diff --git a/sysdeps/unix/sysv/linux/Makefile b/sysdeps/unix/sysv/linux/Makefile
+index 23dd99c2e8..f3ebd57b71 100644
+--- a/sysdeps/unix/sysv/linux/Makefile
++++ b/sysdeps/unix/sysv/linux/Makefile
+@@ -109,6 +109,14 @@ tests += tst-clone tst-clone2 tst-clone3 tst-fanotify tst-personality \
+ 	 tst-tgkill tst-sysvsem-linux tst-sysvmsg-linux tst-sysvshm-linux
+ tests-internal += tst-ofdlocks-compat tst-sigcontext-get_pc
+ 
++tests-clone-internal = \
++  tst-align-clone-internal \
++  tst-clone2-internal \
++  tst-clone3-internal \
++  tst-getpid1-internal
++tests-internal += $(tests-clone-internal)
++tests-static += $(tests-clone-internal)
++
+ CFLAGS-tst-sigcontext-get_pc.c = -fasynchronous-unwind-tables
+ 
+ # Generate the list of SYS_* macros for the system calls (__NR_*
+diff --git a/sysdeps/unix/sysv/linux/tst-align-clone-internal.c b/sysdeps/unix/sysv/linux/tst-align-clone-internal.c
+new file mode 100644
+index 0000000000..0e5307a033
+--- /dev/null
++++ b/sysdeps/unix/sysv/linux/tst-align-clone-internal.c
+@@ -0,0 +1,86 @@
++/* Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <sched.h>
++#include <stdbool.h>
++#include <stdint.h>
++#include <stdio.h>
++#include <string.h>
++#include <sys/wait.h>
++#include <unistd.h>
++#include <tst-stack-align.h>
++#include <clone_internal.h>
++#include <support/xunistd.h>
++
++static int
++f (void *arg)
++{
++  bool ok = true;
++
++  puts ("in f");
++
++  if (TEST_STACK_ALIGN ())
++    ok = false;
++
++  return ok ? 0 : 1;
++}
++
++static int
++do_test (void)
++{
++  bool ok = true;
++
++  puts ("in main");
++
++  if (TEST_STACK_ALIGN ())
++    ok = false;
++
++#ifdef __ia64__
++# define STACK_SIZE 256 * 1024
++#else
++# define STACK_SIZE 128 * 1024
++#endif
++  char st[STACK_SIZE] __attribute__ ((aligned));
++  struct clone_args clone_args =
++    {
++      .stack = (uintptr_t) st,
++      .stack_size = sizeof (st),
++    };
++  pid_t p = __clone_internal (&clone_args, f, 0);
++  if (p == -1)
++    {
++      printf("clone failed: %m\n");
++      return 1;
++    }
++
++  int e;
++  xwaitpid (p, &e, __WCLONE);
++  if (!WIFEXITED (e))
++    {
++      if (WIFSIGNALED (e))
++	printf ("died from signal %s\n", strsignal (WTERMSIG (e)));
++      else
++	puts ("did not terminate correctly");
++      return 1;
++    }
++  if (WEXITSTATUS (e) != 0)
++    ok = false;
++
++  return ok ? 0 : 1;
++}
++
++#include <support/test-driver.c>
+diff --git a/sysdeps/unix/sysv/linux/tst-clone2-internal.c b/sysdeps/unix/sysv/linux/tst-clone2-internal.c
+new file mode 100644
+index 0000000000..b8917fe713
+--- /dev/null
++++ b/sysdeps/unix/sysv/linux/tst-clone2-internal.c
+@@ -0,0 +1,137 @@
++/* Test if CLONE_VM does not change pthread pid/tid field (BZ #19957)
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <sched.h>
++#include <signal.h>
++#include <string.h>
++#include <stdio.h>
++#include <fcntl.h>
++#include <unistd.h>
++#include <stddef.h>
++#include <stdbool.h>
++#include <stdint.h>
++#include <stdlib.h>
++#include <errno.h>
++#include <sys/types.h>
++#include <sys/wait.h>
++#include <sys/syscall.h>
++#include <clone_internal.h>
++#include <support/xunistd.h>
++#include <support/check.h>
++
++static int sig;
++static int pipefd[2];
++
++static int
++f (void *a)
++{
++  close (pipefd[0]);
++
++  pid_t ppid = getppid ();
++  pid_t pid = getpid ();
++  pid_t tid = gettid ();
++
++  if (write (pipefd[1], &ppid, sizeof ppid) != sizeof (ppid))
++    FAIL_EXIT1 ("write ppid failed\n");
++  if (write (pipefd[1], &pid, sizeof pid) != sizeof (pid))
++    FAIL_EXIT1 ("write pid failed\n");
++  if (write (pipefd[1], &tid, sizeof tid) != sizeof (tid))
++    FAIL_EXIT1 ("write tid failed\n");
++
++  return 0;
++}
++
++
++static int
++do_test (void)
++{
++  sig = SIGRTMIN;
++  sigset_t ss;
++  sigemptyset (&ss);
++  sigaddset (&ss, sig);
++  if (sigprocmask (SIG_BLOCK, &ss, NULL) != 0)
++    FAIL_EXIT1 ("sigprocmask failed: %m");
++
++  if (pipe2 (pipefd, O_CLOEXEC))
++    FAIL_EXIT1 ("pipe failed: %m");
++
++#ifdef __ia64__
++# define STACK_SIZE 256 * 1024
++#else
++# define STACK_SIZE 128 * 1024
++#endif
++  char st[STACK_SIZE] __attribute__ ((aligned));
++  struct clone_args clone_args =
++    {
++      .stack = (uintptr_t) st,
++      .stack_size = sizeof (st),
++    };
++  pid_t p = __clone_internal (&clone_args, f, 0);
++
++  close (pipefd[1]);
++
++  if (p == -1)
++    FAIL_EXIT1("clone failed: %m");
++
++  pid_t ppid, pid, tid;
++  if (read (pipefd[0], &ppid, sizeof pid) != sizeof pid)
++    {
++      kill (p, SIGKILL);
++      FAIL_EXIT1 ("read ppid failed: %m");
++    }
++  if (read (pipefd[0], &pid, sizeof pid) != sizeof pid)
++    {
++      kill (p, SIGKILL);
++      FAIL_EXIT1 ("read pid failed: %m");
++    }
++  if (read (pipefd[0], &tid, sizeof tid) != sizeof tid)
++    {
++      kill (p, SIGKILL);
++      FAIL_EXIT1 ("read tid failed: %m");
++    }
++
++  close (pipefd[0]);
++
++  int ret = 0;
++
++  pid_t own_pid = getpid ();
++  pid_t own_tid = syscall (__NR_gettid);
++
++  /* Some sanity checks for clone syscall: returned ppid should be current
++     pid and both returned tid/pid should be different from current one.  */
++  if ((ppid != own_pid) || (pid == own_pid) || (tid == own_tid))
++    FAIL_RET ("ppid=%i pid=%i tid=%i | own_pid=%i own_tid=%i",
++	      (int)ppid, (int)pid, (int)tid, (int)own_pid, (int)own_tid);
++
++  int e;
++  xwaitpid (p, &e, __WCLONE);
++  if (!WIFEXITED (e))
++    {
++      if (WIFSIGNALED (e))
++	printf ("died from signal %s\n", strsignal (WTERMSIG (e)));
++      else
++	puts ("did not terminate correctly");
++      exit (EXIT_FAILURE);
++    }
++  if (WEXITSTATUS (e) != 0)
++    FAIL_EXIT1 ("exit code %d", WEXITSTATUS (e));
++
++  return ret;
++}
++
++#include <support/test-driver.c>
+diff --git a/sysdeps/unix/sysv/linux/tst-clone3-internal.c b/sysdeps/unix/sysv/linux/tst-clone3-internal.c
+new file mode 100644
+index 0000000000..2bdbc571e6
+--- /dev/null
++++ b/sysdeps/unix/sysv/linux/tst-clone3-internal.c
+@@ -0,0 +1,99 @@
++/* Check if clone (CLONE_THREAD) does not call exit_group (BZ #21512)
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <string.h>
++#include <sched.h>
++#include <signal.h>
++#include <unistd.h>
++#include <errno.h>
++#include <sys/syscall.h>
++#include <sys/wait.h>
++#include <sys/types.h>
++#include <linux/futex.h>
++#include <support/check.h>
++#include <stdatomic.h>
++#include <clone_internal.h>
++
++/* Test if clone call with CLONE_THREAD does not call exit_group.  The 'f'
++   function returns '1', which will be used by clone thread to call the
++   'exit' syscall directly.  If _exit is used instead, exit_group will be
++   used and thus the thread group will finish with return value of '1'
++   (where '2' from main thread is expected.).  */
++
++static int
++f (void *a)
++{
++  return 1;
++}
++
++/* Futex wait for TID argument, similar to pthread_join internal
++   implementation.  */
++#define wait_tid(ctid_ptr, ctid_val)					\
++  do {									\
++    __typeof (*(ctid_ptr)) __tid;					\
++    /* We need acquire MO here so that we synchronize with the		\
++       kernel's store to 0 when the clone terminates.  */		\
++    while ((__tid = atomic_load_explicit (ctid_ptr,			\
++					  memory_order_acquire)) != 0)	\
++      futex_wait (ctid_ptr, ctid_val);					\
++  } while (0)
++
++static inline int
++futex_wait (int *futexp, int val)
++{
++#ifdef __NR_futex
++  return syscall (__NR_futex, futexp, FUTEX_WAIT, val);
++#else
++  return syscall (__NR_futex_time64, futexp, FUTEX_WAIT, val);
++#endif
++}
++
++static int
++do_test (void)
++{
++  char st[1024] __attribute__ ((aligned));
++  int clone_flags = CLONE_THREAD;
++  /* Minimum required flags to used along with CLONE_THREAD.  */
++  clone_flags |= CLONE_VM | CLONE_SIGHAND;
++  /* We will used ctid to call on futex to wait for thread exit.  */
++  clone_flags |= CLONE_CHILD_CLEARTID;
++  /* Initialize with a known value.  ctid is set to zero by the kernel after the
++     cloned thread has exited.  */
++#define CTID_INIT_VAL 1
++  pid_t ctid = CTID_INIT_VAL;
++  pid_t tid;
++
++  struct clone_args clone_args =
++    {
++      .flags = clone_flags & ~CSIGNAL,
++      .exit_signal = clone_flags & CSIGNAL,
++      .stack = (uintptr_t) st,
++      .stack_size = sizeof (st),
++      .child_tid = (uintptr_t) &ctid,
++    };
++  tid = __clone_internal (&clone_args, f, NULL);
++  if (tid == -1)
++    FAIL_EXIT1 ("clone failed: %m");
++
++  wait_tid (&ctid, CTID_INIT_VAL);
++
++  return 2;
++}
++
++#define EXPECTED_STATUS 2
++#include <support/test-driver.c>
+diff --git a/sysdeps/unix/sysv/linux/tst-getpid1-internal.c b/sysdeps/unix/sysv/linux/tst-getpid1-internal.c
+new file mode 100644
+index 0000000000..5ce091168e
+--- /dev/null
++++ b/sysdeps/unix/sysv/linux/tst-getpid1-internal.c
+@@ -0,0 +1,132 @@
++/* Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <sched.h>
++#include <signal.h>
++#include <string.h>
++#include <stdio.h>
++#include <unistd.h>
++#include <sys/types.h>
++#include <sys/wait.h>
++#include <clone_internal.h>
++#include <support/xunistd.h>
++
++#ifndef TEST_CLONE_FLAGS
++#define TEST_CLONE_FLAGS 0
++#endif
++
++static int sig;
++
++static int
++f (void *a)
++{
++  puts ("in f");
++  union sigval sival;
++  sival.sival_int = getpid ();
++  printf ("pid = %d\n", sival.sival_int);
++  if (sigqueue (getppid (), sig, sival) != 0)
++    return 1;
++  return 0;
++}
++
++
++static int
++do_test (void)
++{
++  int mypid = getpid ();
++
++  sig = SIGRTMIN;
++  sigset_t ss;
++  sigemptyset (&ss);
++  sigaddset (&ss, sig);
++  if (sigprocmask (SIG_BLOCK, &ss, NULL) != 0)
++    {
++      printf ("sigprocmask failed: %m\n");
++      return 1;
++    }
++
++#ifdef __ia64__
++# define STACK_SIZE 256 * 1024
++#else
++# define STACK_SIZE 128 * 1024
++#endif
++  char st[STACK_SIZE] __attribute__ ((aligned));
++  struct clone_args clone_args =
++    {
++      .flags = TEST_CLONE_FLAGS & ~CSIGNAL,
++      .exit_signal = TEST_CLONE_FLAGS & CSIGNAL,
++      .stack = (uintptr_t) st,
++      .stack_size = sizeof (st),
++    };
++  pid_t p = __clone_internal (&clone_args, f, 0);
++  if (p == -1)
++    {
++      printf("clone failed: %m\n");
++      return 1;
++    }
++  printf ("new thread: %d\n", (int) p);
++
++  siginfo_t si;
++  do
++    if (sigwaitinfo (&ss, &si) < 0)
++      {
++	printf("sigwaitinfo failed: %m\n");
++	kill (p, SIGKILL);
++	return 1;
++      }
++  while  (si.si_signo != sig || si.si_code != SI_QUEUE);
++
++  int e;
++  xwaitpid (p, &e, __WCLONE);
++  if (!WIFEXITED (e))
++    {
++      if (WIFSIGNALED (e))
++	printf ("died from signal %s\n", strsignal (WTERMSIG (e)));
++      else
++	puts ("did not terminate correctly");
++      return 1;
++    }
++  if (WEXITSTATUS (e) != 0)
++    {
++      printf ("exit code %d\n", WEXITSTATUS (e));
++      return 1;
++    }
++
++  if (si.si_int != (int) p)
++    {
++      printf ("expected PID %d, got si_int %d\n", (int) p, si.si_int);
++      kill (p, SIGKILL);
++      return 1;
++    }
++
++  if (si.si_pid != p)
++    {
++      printf ("expected PID %d, got si_pid %d\n", (int) p, (int) si.si_pid);
++      kill (p, SIGKILL);
++      return 1;
++    }
++
++  if (getpid () != mypid)
++    {
++      puts ("my PID changed");
++      return 1;
++    }
++
++  return 0;
++}
++
++#include <support/test-driver.c>
+-- 
+2.31.1
+
diff --git a/0008-GLIBC_PRIVATE-Export-__clone_internal.patch b/0008-GLIBC_PRIVATE-Export-__clone_internal.patch
new file mode 100644
index 0000000..a9737b0
--- /dev/null
+++ b/0008-GLIBC_PRIVATE-Export-__clone_internal.patch
@@ -0,0 +1,24 @@
+From c6af37f70277310ae7d29b312a312880751d34f0 Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Fri, 14 May 2021 15:22:52 -0700
+Subject: [PATCH 08/24] GLIBC_PRIVATE: Export __clone_internal
+
+Export __clone_internal for libpthread.so and __clone_internal tests.
+---
+ sysdeps/unix/sysv/linux/Versions | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/sysdeps/unix/sysv/linux/Versions b/sysdeps/unix/sysv/linux/Versions
+index c35f783e2a..9bb13d593f 100644
+--- a/sysdeps/unix/sysv/linux/Versions
++++ b/sysdeps/unix/sysv/linux/Versions
+@@ -179,5 +179,6 @@ libc {
+     __sigtimedwait;
+     # functions used by nscd
+     __netlink_assert_response;
++    __clone_internal;
+   }
+ }
+-- 
+2.31.1
+
diff --git a/0009-sys-tagged-address.h-An-API-for-tagged-address.patch b/0009-sys-tagged-address.h-An-API-for-tagged-address.patch
new file mode 100644
index 0000000..0f0cb5a
--- /dev/null
+++ b/0009-sys-tagged-address.h-An-API-for-tagged-address.patch
@@ -0,0 +1,1174 @@
+From d69d107ba8a7c4fd8c6d6189a1c098f88a09fa0f Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Wed, 16 Dec 2020 15:25:59 -0800
+Subject: [PATCH 09/24] <sys/tagged-address.h>: An API for tagged address
+
+By default, the number of the address bits used in address translation
+is the number of address bits.  But it can be changed by ARM Top-byte
+Ignore (TBI) or Intel Linear Address Masking (LAM).
+
+<sys/tagged-address.h> provides an API for tagged address manipulation:
+
+/* Get the current address bits used in address translation.  */
+extern unsigned int get_tagged_address_bits (void);
+
+/* Get the current mask for address bits used in address translation.  */
+extern uintptr_t get_tagged_address_mask (void);
+
+/* Set the mask for address bits used in address translation.  Return 0
+   on success.  Return -1 on error.  */
+extern int set_tagged_address_mask (uintptr_t __mask);
+
+/* Return the tagged address of __ADDR with the tag value __TAG.  */
+extern void *tag_address (void *__addr, unsigned int __tag);
+
+/* Return the untagged address of __ADDR.  */
+extern void *untag_address (void *__addr);
+
+/* TRUE if constant address BITS is a valid tagged address bits.  */
+ #define TAGGED_ADDRESS_VALID_BITS(BITS)
+
+/* A mask for constant address BITS used in address translation.  */
+ #define TAGGED_ADDRESS_MASK(BITS)
+
+1. set_tagged_address_mask should be called as early as possible.
+2. set_tagged_address_mask shouldn't be allowed after main is called.
+3. After set_tagged_address_mask is called, don't allow it to be called
+again to change the tagged address mask.  Otherwise, the previously
+tagged addresses may not work anymore.
+---
+ bits/tagged-address-mask.h                    | 47 +++++++++++++
+ bits/tagged-address.h                         | 28 ++++++++
+ csu/libc-start.c                              |  3 +
+ elf/dl-support.c                              |  5 ++
+ include/sys/tagged-address.h                  |  9 +++
+ manual/Makefile                               |  3 +-
+ manual/ctype.texi                             |  2 +-
+ manual/memory.texi                            |  2 +-
+ manual/tagged-address.texi                    | 67 +++++++++++++++++++
+ misc/Makefile                                 | 35 ++++++++--
+ misc/Versions                                 |  7 ++
+ misc/set-tagged-address-mask.c                | 41 ++++++++++++
+ misc/sys/tagged-address.h                     | 45 +++++++++++++
+ misc/tagged-address.c                         | 55 +++++++++++++++
+ misc/tst-tagged-address-1-static.c            |  1 +
+ misc/tst-tagged-address-1.c                   | 53 +++++++++++++++
+ misc/tst-tagged-address-2-static.c            |  1 +
+ misc/tst-tagged-address-2.c                   | 44 ++++++++++++
+ misc/tst-tagged-address-3-static.c            |  1 +
+ misc/tst-tagged-address-3.c                   | 48 +++++++++++++
+ misc/tst-tagged-address-4-static.c            |  1 +
+ misc/tst-tagged-address-4.c                   | 35 ++++++++++
+ misc/tst-tagged-address-5.c                   | 25 +++++++
+ misc/tst-tagged-address-6.c                   | 34 ++++++++++
+ misc/tst-tagged-address-7.c                   | 40 +++++++++++
+ misc/tst-tagged-address-mod-5.c               | 45 +++++++++++++
+ misc/tst-tagged-address-mod-6.c               | 34 ++++++++++
+ misc/tst-tagged-address-mod-7.c               | 34 ++++++++++
+ sysdeps/generic/inline-tagged-address.h       | 43 ++++++++++++
+ sysdeps/generic/ldsodefs.h                    |  4 ++
+ sysdeps/unix/sysv/linux/i386/libc.abilist     |  5 ++
+ .../unix/sysv/linux/x86_64/64/libc.abilist    |  5 ++
+ .../unix/sysv/linux/x86_64/x32/libc.abilist   |  5 ++
+ 33 files changed, 799 insertions(+), 8 deletions(-)
+ create mode 100644 bits/tagged-address-mask.h
+ create mode 100644 bits/tagged-address.h
+ create mode 100644 include/sys/tagged-address.h
+ create mode 100644 manual/tagged-address.texi
+ create mode 100644 misc/set-tagged-address-mask.c
+ create mode 100644 misc/sys/tagged-address.h
+ create mode 100644 misc/tagged-address.c
+ create mode 100644 misc/tst-tagged-address-1-static.c
+ create mode 100644 misc/tst-tagged-address-1.c
+ create mode 100644 misc/tst-tagged-address-2-static.c
+ create mode 100644 misc/tst-tagged-address-2.c
+ create mode 100644 misc/tst-tagged-address-3-static.c
+ create mode 100644 misc/tst-tagged-address-3.c
+ create mode 100644 misc/tst-tagged-address-4-static.c
+ create mode 100644 misc/tst-tagged-address-4.c
+ create mode 100644 misc/tst-tagged-address-5.c
+ create mode 100644 misc/tst-tagged-address-6.c
+ create mode 100644 misc/tst-tagged-address-7.c
+ create mode 100644 misc/tst-tagged-address-mod-5.c
+ create mode 100644 misc/tst-tagged-address-mod-6.c
+ create mode 100644 misc/tst-tagged-address-mod-7.c
+ create mode 100644 sysdeps/generic/inline-tagged-address.h
+
+diff --git a/bits/tagged-address-mask.h b/bits/tagged-address-mask.h
+new file mode 100644
+index 0000000000..33571af11c
+--- /dev/null
++++ b/bits/tagged-address-mask.h
+@@ -0,0 +1,47 @@
++/* Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#ifndef _BITS_TAGGED_ADDRESS_MASK_H
++#define _BITS_TAGGED_ADDRESS_MASK_H 1
++
++#ifndef _SYS_TAGGED_ADDRESS_H
++# error "Never include this file directly.  Use <sys/tagged-address.h> instead"
++#endif
++
++#include <bits/tagged-address.h>
++
++#ifdef __GNUC__
++# if defined __USE_ISOC11 || defined __USE_ISOCXX11
++#  ifdef __USE_ISOCXX11
++#   define TAGGED_ADDRESS_ASSERT static_assert
++#  else
++#   define TAGGED_ADDRESS_ASSERT _Static_assert
++#  endif
++# else
++#  define TAGGED_ADDRESS_ASSERT(expr, msg)
++# endif
++/* A mask for constant address BITS used in address translation.  */
++# define TAGGED_ADDRESS_MASK(BITS)				    \
++  (__extension__						    \
++    ({								    \
++       TAGGED_ADDRESS_ASSERT (TAGGED_ADDRESS_VALID_BITS (BITS),	    \
++			      "Tagged address bits must be valid"); \
++       (((uintptr_t) 1) << (BITS)) - 1;				    \
++     }))
++#endif
++
++#endif /* <bits/tagged-address-mask.h> */
+diff --git a/bits/tagged-address.h b/bits/tagged-address.h
+new file mode 100644
+index 0000000000..ecd8a2942d
+--- /dev/null
++++ b/bits/tagged-address.h
+@@ -0,0 +1,28 @@
++/* Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#ifndef _BITS_TAGGED_ADDRESS_H
++#define _BITS_TAGGED_ADDRESS_H 1
++
++#ifndef _SYS_TAGGED_ADDRESS_H
++# error "Never include this file directly.  Use <sys/tagged-address.h> instead"
++#endif
++
++/* Non-zero if constant address BITS is a valid tagged address bits.  */
++#define TAGGED_ADDRESS_VALID_BITS(BITS) 0
++
++#endif /* <bits/tagged-address.h> */
+diff --git a/csu/libc-start.c b/csu/libc-start.c
+index feb0d7ce11..871a823565 100644
+--- a/csu/libc-start.c
++++ b/csu/libc-start.c
+@@ -299,6 +299,9 @@ LIBC_START_MAIN (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL),
+     GLRO(dl_debug_printf) ("\ntransferring control: %s\n\n", argv[0]);
+ #endif
+ 
++  /* set_tagged_address_mask can only be called before main.  */
++  GL(dl_tagged_address_mask_locked) = 1;
++
+ #ifndef SHARED
+   _dl_debug_initialize (0, LM_ID_BASE);
+ #endif
+diff --git a/elf/dl-support.c b/elf/dl-support.c
+index 7abb65d8e3..49d1938c38 100644
+--- a/elf/dl-support.c
++++ b/elf/dl-support.c
+@@ -211,6 +211,11 @@ struct link_map *_dl_sysinfo_map;
+ 
+ # include "get-dynamic-info.h"
+ #endif
++
++/* If nonzero, the mask for address bits used in address translation
++   is locked.  */
++int _dl_tagged_address_mask_locked;
++
+ #include "setup-vdso.h"
+ /* Define the vDSO function pointers.  */
+ #include <dl-vdso-setup.c>
+diff --git a/include/sys/tagged-address.h b/include/sys/tagged-address.h
+new file mode 100644
+index 0000000000..2e902f72b2
+--- /dev/null
++++ b/include/sys/tagged-address.h
+@@ -0,0 +1,9 @@
++#include <misc/sys/tagged-address.h>
++
++#ifndef _ISOMAC
++# include <inline-tagged-address.h>
++# define get_tagged_address_bits()	__get_tagged_address_bits ()
++# define get_tagged_address_mask()	__get_tagged_address_mask ()
++# define tag_address(addr, tag)		__tag_address ((addr), (tag))
++# define untag_address(addr)		__untag_address ((addr))
++#endif
+diff --git a/manual/Makefile b/manual/Makefile
+index e83444341e..08df2daa6b 100644
+--- a/manual/Makefile
++++ b/manual/Makefile
+@@ -34,7 +34,8 @@ info: $(objpfx)libc.info
+ endif
+ 
+ chapters = $(addsuffix .texi, \
+-		       intro errno memory ctype string charset locale	\
++		       intro errno memory tagged-address ctype string	\
++		       charset locale					\
+ 		       message search pattern io stdio llio filesys	\
+ 		       pipe socket terminal syslog math arith time	\
+ 		       resource setjmp signal startup process ipc job	\
+diff --git a/manual/ctype.texi b/manual/ctype.texi
+index d0618c5c38..28af73ff0e 100644
+--- a/manual/ctype.texi
++++ b/manual/ctype.texi
+@@ -1,4 +1,4 @@
+-@node Character Handling, String and Array Utilities, Memory, Top
++@node Character Handling, String and Array Utilities, Tagged Address, Top
+ @c %MENU% Character testing and conversion functions
+ @chapter Character Handling
+ 
+diff --git a/manual/memory.texi b/manual/memory.texi
+index b2cc65228a..4791c7c464 100644
+--- a/manual/memory.texi
++++ b/manual/memory.texi
+@@ -1,4 +1,4 @@
+-@node Memory, Character Handling, Error Reporting, Top
++@node Memory, Tagged Address, Error Reporting, Top
+ @chapter Virtual Memory Allocation And Paging
+ @c %MENU% Allocating virtual memory and controlling paging
+ @cindex memory allocation
+diff --git a/manual/tagged-address.texi b/manual/tagged-address.texi
+new file mode 100644
+index 0000000000..703c38a15d
+--- /dev/null
++++ b/manual/tagged-address.texi
+@@ -0,0 +1,67 @@
++@node Tagged Address, Character Handling, Memory, Top
++@c %MENU% Tagged address functions and macros
++@chapter Tagged Address
++
++By default, the number of the address bits used in address translation
++is the number of address bits.  But it can be changed by ARM Top-byte
++Ignore (TBI) or Intel Linear Address Masking (LAM).
++
++@Theglibc{} provides several functions and macros in the header file
++@file{sys/tagged-address.h} to manipulate tagged address bits, which is
++the number of the address bits used in address translation.
++@pindex sys/tagged-address.h
++
++@deftypefun {unsigned int} get_tagged_address_bits (void)
++@standards{GNU, sys/tagged-address.h}
++@safety{@prelim{}@mtsafe{}@assafe{}@acsafe{}}
++Get the current address bits used in address translation.  The return
++value is @code{0} if tag bits are not the highest bits in addresses.  The
++return value is the number of address bits when tagged address is
++unsupported.
++@end deftypefun
++
++@deftypefun uintptr_t get_tagged_address_mask (void)
++@standards{GNU, sys/tagged-address.h}
++@safety{@prelim{}@mtsafe{}@assafe{}@acsafe{}}
++Get the current mask for address bits used in address translation.  If a
++bit is set in the return value, this bit is used in address translation.
++The return value is @code{-1} when all bits are used in address
++translation.
++@end deftypefun
++
++@deftypefun int set_tagged_address_mask (uintptr_t @var{mask})
++@standards{GNU, sys/tagged-address.h}
++@safety{@prelim{}@mtsafe{}@assafe{}@acsafe{}}
++Set the mask for address bits used in address translation to @var{mask}.
++Only bits set in @var{mask} will be used in address translation.  The
++return value is @code{0} on success and @code{-1} on failure.  This
++function can be called only once before @code{main}.  The possible
++@code{errno} error conditions are @code{ENODEV}, @code{EPERM},
++@code{EINVAL}, and @code{ENOSYS}.
++@end deftypefun
++
++@deftypefun {void *} tag_address (void *@var{addr}, unsigned int @var{tag})
++@standards{GNU, sys/tagged-address.h}
++@safety{@prelim{}@mtsafe{}@assafe{}@acsafe{}}
++Return the address of @var{addr} with the tag value @var{tag} stored
++in the untranslated bits.  Overflow of @var{tag} in the untranslated
++bits are ignored.
++@end deftypefun
++
++@deftypefun {void *} untag_address (void *@var{addr})
++@standards{GNU, sys/tagged-address.h}
++@safety{@prelim{}@mtsafe{}@assafe{}@acsafe{}}
++Return the address of @var{addr} with all zero untranslated bits.
++@end deftypefun
++
++@deftypefn Macro int TAGGED_ADDRESS_VALID_BITS (@var{bits})
++This macro returns a nonzero value (true) if @var{bits} is a valid
++constant number of the lower address bits which can be used in address
++translation.
++@end deftypefn
++
++@deftypefn Macro {const uintptr_t} TAGGED_ADDRESS_MASK (@var{bits})
++This macro returns a nonzero value which can be passed to
++@code{set_tagged_address_mask} to specify the lower address @var{bits}
++for address translation.
++@end deftypefn
+diff --git a/misc/Makefile b/misc/Makefile
+index 05ad034baf..faf41b85d7 100644
+--- a/misc/Makefile
++++ b/misc/Makefile
+@@ -38,7 +38,9 @@ headers	:= sys/uio.h bits/uio-ext.h bits/uio_lim.h \
+ 	   bits/select2.h bits/hwcap.h sys/auxv.h \
+ 	   sys/sysmacros.h bits/sysmacros.h bits/types/struct_iovec.h \
+ 	   bits/err-ldbl.h bits/error-ldbl.h \
+-	   sys/single_threaded.h
++	   sys/single_threaded.h \
++	   sys/tagged-address.h bits/tagged-address.h \
++	   bits/tagged-address-mask.h
+ 
+ routines := brk sbrk sstk ioctl \
+ 	    readv writev preadv preadv64 pwritev pwritev64 \
+@@ -73,7 +75,8 @@ routines := brk sbrk sstk ioctl \
+ 	    fgetxattr flistxattr fremovexattr fsetxattr getxattr \
+ 	    listxattr lgetxattr llistxattr lremovexattr lsetxattr \
+ 	    removexattr setxattr getauxval ifunc-impl-list makedev \
+-	    allocate_once fd_to_filename single_threaded
++	    allocate_once fd_to_filename single_threaded \
++	    tagged-address set-tagged-address-mask
+ 
+ generated += tst-error1.mtrace tst-error1-mem.out \
+   tst-allocate_once.mtrace tst-allocate_once-mem.out
+@@ -88,15 +91,31 @@ tests := tst-dirname tst-tsearch tst-fdset tst-mntent tst-hsearch \
+ 	 tst-preadvwritev tst-preadvwritev64 tst-makedev tst-empty \
+ 	 tst-preadvwritev2 tst-preadvwritev64v2 tst-warn-wide \
+ 	 tst-ldbl-warn tst-ldbl-error tst-dbl-efgcvt tst-ldbl-efgcvt \
+-	 tst-mntent-autofs tst-syscalls tst-mntent-escape tst-select
++	 tst-mntent-autofs tst-syscalls tst-mntent-escape tst-select \
++	 tst-mntent-autofs tst-syscalls tst-mntent-escape \
++	 tst-tagged-address-1 tst-tagged-address-1-static \
++	 tst-tagged-address-2 tst-tagged-address-2-static \
++	 tst-tagged-address-3 tst-tagged-address-3-static \
++	 tst-tagged-address-4 tst-tagged-address-4-static
+ 
+ # Tests which need libdl.
+ ifeq (yes,$(build-shared))
+-tests += tst-gethostid
++tests += tst-gethostid \
++  tst-tagged-address-5 \
++  tst-tagged-address-6 \
++  tst-tagged-address-7
++modules-names += \
++  tst-tagged-address-mod-5 \
++  tst-tagged-address-mod-6 \
++  tst-tagged-address-mod-7
+ endif
+ 
+ tests-internal := tst-atomic tst-atomic-long tst-allocate_once
+-tests-static := tst-empty
++tests-static := tst-empty \
++  tst-tagged-address-1-static \
++  tst-tagged-address-2-static \
++  tst-tagged-address-3-static \
++  tst-tagged-address-4-static
+ 
+ # Test for the internal, non-exported __fd_to_filename function.
+ tests-internal += tst-fd_to_filename
+@@ -160,3 +179,9 @@ $(objpfx)tst-allocate_once-mem.out: $(objpfx)tst-allocate_once.out
+ 	$(evaluate-test)
+ 
+ $(objpfx)tst-gethostid: $(libdl)
++
++$(objpfx)tst-tagged-address-2: $(shared-thread-library)
++$(objpfx)tst-tagged-address-2-static: $(static-thread-library)
++$(objpfx)tst-tagged-address-7: $(libdl)
++$(objpfx)tst-tagged-address-7.out: $(objpfx)tst-tagged-address-mod-7.so
++$(objpfx)tst-tagged-address-mod-7.so: $(libsupport)
+diff --git a/misc/Versions b/misc/Versions
+index 95666f6548..9e9ded4d5c 100644
+--- a/misc/Versions
++++ b/misc/Versions
+@@ -164,6 +164,13 @@ libc {
+   GLIBC_2.32 {
+     __libc_single_threaded;
+   }
++  GLIBC_2.34 {
++    get_tagged_address_bits;
++    get_tagged_address_mask;
++    set_tagged_address_mask;
++    tag_address;
++    untag_address;
++  }
+   GLIBC_PRIVATE {
+     __madvise;
+     __mktemp;
+diff --git a/misc/set-tagged-address-mask.c b/misc/set-tagged-address-mask.c
+new file mode 100644
+index 0000000000..2e1e2f2343
+--- /dev/null
++++ b/misc/set-tagged-address-mask.c
+@@ -0,0 +1,41 @@
++/* Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <sys/tagged-address.h>
++#include <ldsodefs.h>
++
++/* Set the mask for address bits used in address translation.  Return 0
++   on success.  Return -1 on error.  */
++
++int
++set_tagged_address_mask (uintptr_t mask)
++{
++  if (GL(dl_tagged_address_mask_locked) != 0)
++    __set_errno (EPERM);
++  else
++    {
++      /* set_tagged_address_mask can only be called once.  */
++      GL(dl_tagged_address_mask_locked) = 1;
++
++      /* Only NOP is allowed.  */
++      if (mask == __get_tagged_address_mask ())
++	return 0;
++
++      __set_errno (ENOSYS);
++    }
++  return -1;
++}
+diff --git a/misc/sys/tagged-address.h b/misc/sys/tagged-address.h
+new file mode 100644
+index 0000000000..025a333cac
+--- /dev/null
++++ b/misc/sys/tagged-address.h
+@@ -0,0 +1,45 @@
++/* Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#ifndef _SYS_TAGGED_ADDRESS_H
++#define _SYS_TAGGED_ADDRESS_H 1
++
++#include <features.h>
++#include <stdint.h>
++#include <bits/tagged-address-mask.h>
++
++__BEGIN_DECLS
++
++/* Get the current address bits used in address translation.  */
++extern unsigned int get_tagged_address_bits (void);
++
++/* Get the current mask for address bits used in address translation.  */
++extern uintptr_t get_tagged_address_mask (void);
++
++/* Set the mask for address bits used in address translation.  Return 0
++   on success.  Return -1 on error.  */
++extern int set_tagged_address_mask (uintptr_t __mask);
++
++/* Return the tagged address of __ADDR with the tag value __TAG.  */
++extern void *tag_address (void *__addr, unsigned int __tag);
++
++/* Return the untagged address of __ADDR.  */
++extern void *untag_address (void *__addr);
++
++__END_DECLS
++
++#endif /* <sys/tagged-address.h> */
+diff --git a/misc/tagged-address.c b/misc/tagged-address.c
+new file mode 100644
+index 0000000000..df474f3d0b
+--- /dev/null
++++ b/misc/tagged-address.c
+@@ -0,0 +1,55 @@
++/* Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <sys/tagged-address.h>
++
++#undef get_tagged_address_bits
++#undef get_tagged_address_mask
++#undef tag_address
++#undef untag_address
++
++/* Get the current address bits used in address translation.  */
++
++unsigned int
++get_tagged_address_bits (void)
++{
++  return __get_tagged_address_bits ();
++}
++
++/* Get the current mask for address bits used in address translation.  */
++
++uintptr_t
++get_tagged_address_mask (void)
++{
++  return __get_tagged_address_mask ();
++}
++
++/* Return the tagged address of ADDR with the tag value TAG.  */
++
++void *
++tag_address (void *addr, unsigned int tag)
++{
++  return __tag_address (addr, tag);
++}
++
++/* Return the untagged address of ADDR.  */
++
++void *
++untag_address (void *addr)
++{
++  return __untag_address (addr);
++}
+diff --git a/misc/tst-tagged-address-1-static.c b/misc/tst-tagged-address-1-static.c
+new file mode 100644
+index 0000000000..3ed71a66c2
+--- /dev/null
++++ b/misc/tst-tagged-address-1-static.c
+@@ -0,0 +1 @@
++#include <tst-tagged-address-1.c>
+diff --git a/misc/tst-tagged-address-1.c b/misc/tst-tagged-address-1.c
+new file mode 100644
+index 0000000000..0bbc214a2f
+--- /dev/null
++++ b/misc/tst-tagged-address-1.c
+@@ -0,0 +1,53 @@
++/* Tests for set_tagged_address_mask.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <errno.h>
++#include <sys/tagged-address.h>
++#include <support/check.h>
++
++static void
++init_0 (void)
++{
++  if (set_tagged_address_mask (get_tagged_address_mask ()) != 0)
++    FAIL_EXIT1 ("set_tagged_address_mask failed: %m");
++}
++
++static void
++init_1 (void)
++{
++  if (set_tagged_address_mask (get_tagged_address_mask ()) == 0)
++    FAIL_EXIT1 ("set_tagged_address_mask should fail");
++
++  if (errno != EPERM)
++    FAIL_EXIT1 ("set_tagged_address_mask: errno (%m) != EPERM");
++}
++
++static void (*init_array []) (void)
++  __attribute__ ((used, section (".init_array"), aligned (sizeof (void *)))) =
++{
++  &init_0,
++  &init_1
++};
++
++static int
++do_test (void)
++{
++  return 0;
++}
++
++#include <support/test-driver.c>
+diff --git a/misc/tst-tagged-address-2-static.c b/misc/tst-tagged-address-2-static.c
+new file mode 100644
+index 0000000000..ac0d95e6c0
+--- /dev/null
++++ b/misc/tst-tagged-address-2-static.c
+@@ -0,0 +1 @@
++#include <tst-tagged-address-2.c>
+diff --git a/misc/tst-tagged-address-2.c b/misc/tst-tagged-address-2.c
+new file mode 100644
+index 0000000000..76caae4053
+--- /dev/null
++++ b/misc/tst-tagged-address-2.c
+@@ -0,0 +1,44 @@
++/* Test for set_tagged_address_mask with pthread.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <errno.h>
++#include <sys/tagged-address.h>
++#include <support/xthread.h>
++#include <support/check.h>
++
++static void *
++tf (void *arg)
++{
++  if (set_tagged_address_mask (get_tagged_address_mask ()) == 0)
++    FAIL_EXIT1 ("set_tagged_address_mask should fail");
++
++  if (errno != EPERM)
++    FAIL_EXIT1 ("set_tagged_address_mask: errno (%m) != EPERM");
++
++  return NULL;
++}
++
++static int
++do_test (void)
++{
++  pthread_t thr = xpthread_create (NULL, tf, NULL);
++  xpthread_join (thr);
++  return 0;
++}
++
++#include <support/test-driver.c>
+diff --git a/misc/tst-tagged-address-3-static.c b/misc/tst-tagged-address-3-static.c
+new file mode 100644
+index 0000000000..1e3591e0d6
+--- /dev/null
++++ b/misc/tst-tagged-address-3-static.c
+@@ -0,0 +1 @@
++#include <tst-tagged-address-3.c>
+diff --git a/misc/tst-tagged-address-3.c b/misc/tst-tagged-address-3.c
+new file mode 100644
+index 0000000000..e241950959
+--- /dev/null
++++ b/misc/tst-tagged-address-3.c
+@@ -0,0 +1,48 @@
++/* Tests for set_tagged_address_mask to turn off tagged address.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <sys/tagged-address.h>
++#include <support/check.h>
++
++static void
++init (void)
++{
++  uintptr_t mask = (uintptr_t) -1;
++  if (set_tagged_address_mask (mask) != 0)
++    FAIL_EXIT1 ("set_tagged_address_mask failed: %m");
++}
++
++static void (*init_array []) (void)
++  __attribute__ ((used, section (".init_array"), aligned (sizeof (void *)))) =
++{
++  &init
++};
++
++static int
++do_test (void)
++{
++  uintptr_t mask = (uintptr_t) -1;
++  uintptr_t curent_mask = get_tagged_address_mask ();
++  if (curent_mask != mask)
++    FAIL_EXIT1 ("get_tagged_address_mask failed: %p != %p",
++		(void *) curent_mask, (void *) mask);
++
++  return 0;
++}
++
++#include <support/test-driver.c>
+diff --git a/misc/tst-tagged-address-4-static.c b/misc/tst-tagged-address-4-static.c
+new file mode 100644
+index 0000000000..b0681f6f9b
+--- /dev/null
++++ b/misc/tst-tagged-address-4-static.c
+@@ -0,0 +1 @@
++#include <tst-tagged-address-4.c>
+diff --git a/misc/tst-tagged-address-4.c b/misc/tst-tagged-address-4.c
+new file mode 100644
+index 0000000000..9843f780af
+--- /dev/null
++++ b/misc/tst-tagged-address-4.c
+@@ -0,0 +1,35 @@
++/* Tests for set_tagged_address_mask.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <errno.h>
++#include <sys/tagged-address.h>
++#include <support/check.h>
++
++static int
++do_test (void)
++{
++  if (set_tagged_address_mask (get_tagged_address_mask ()) == 0)
++    FAIL_EXIT1 ("set_tagged_address_mask should fail");
++
++  if (errno != EPERM)
++    FAIL_EXIT1 ("set_tagged_address_mask: errno (%m) != EPERM");
++
++  return 0;
++}
++
++#include <support/test-driver.c>
+diff --git a/misc/tst-tagged-address-5.c b/misc/tst-tagged-address-5.c
+new file mode 100644
+index 0000000000..e00679a2cb
+--- /dev/null
++++ b/misc/tst-tagged-address-5.c
+@@ -0,0 +1,25 @@
++/* Tests for set_tagged_address_mask.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++static int
++do_test (void)
++{
++  return 0;
++}
++
++#include <support/test-driver.c>
+diff --git a/misc/tst-tagged-address-6.c b/misc/tst-tagged-address-6.c
+new file mode 100644
+index 0000000000..5fdceb1fb4
+--- /dev/null
++++ b/misc/tst-tagged-address-6.c
+@@ -0,0 +1,34 @@
++/* Tests for set_tagged_address_mask to turn off tagged address.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <sys/tagged-address.h>
++#include <support/check.h>
++
++static int
++do_test (void)
++{
++  uintptr_t mask = (uintptr_t) -1;
++  uintptr_t curent_mask = get_tagged_address_mask ();
++  if (curent_mask != mask)
++    FAIL_EXIT1 ("get_tagged_address_mask failed: %p != %p",
++		(void *) curent_mask, (void *) mask);
++
++  return 0;
++}
++
++#include <support/test-driver.c>
+diff --git a/misc/tst-tagged-address-7.c b/misc/tst-tagged-address-7.c
+new file mode 100644
+index 0000000000..f0a078188d
+--- /dev/null
++++ b/misc/tst-tagged-address-7.c
+@@ -0,0 +1,40 @@
++/* Tests for set_tagged_address_mask.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <stddef.h>
++#include <dlfcn.h>
++#include <support/check.h>
++
++static int
++do_test (void)
++{
++  const char *modname = "$ORIGIN/tst-tagged-address-mod-7.so";
++  void *h = dlopen (modname, RTLD_LAZY);
++
++  if (h == NULL)
++    {
++      const char *err = dlerror ();
++      FAIL_EXIT1 ("cannot open '%s': %s\n", modname, err);
++    }
++
++  dlclose (h);
++
++  return 0;
++}
++
++#include <support/test-driver.c>
+diff --git a/misc/tst-tagged-address-mod-5.c b/misc/tst-tagged-address-mod-5.c
+new file mode 100644
+index 0000000000..275ecc406d
+--- /dev/null
++++ b/misc/tst-tagged-address-mod-5.c
+@@ -0,0 +1,45 @@
++/* Tests for set_tagged_address_mask.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <errno.h>
++#include <sys/tagged-address.h>
++#include <support/check.h>
++
++static void
++init_0 (void)
++{
++  if (set_tagged_address_mask (get_tagged_address_mask ()) != 0)
++    FAIL_EXIT1 ("set_tagged_address_mask failed: %m");
++}
++
++static void
++init_1 (void)
++{
++  if (set_tagged_address_mask (get_tagged_address_mask ()) == 0)
++    FAIL_EXIT1 ("set_tagged_address_mask should fail");
++
++  if (errno != EPERM)
++    FAIL_EXIT1 ("set_tagged_address_mask: errno (%m) != EPERM");
++}
++
++static void (*init_array []) (void)
++  __attribute__ ((used, section (".init_array"), aligned (sizeof (void *)))) =
++{
++  &init_0,
++  &init_1
++};
+diff --git a/misc/tst-tagged-address-mod-6.c b/misc/tst-tagged-address-mod-6.c
+new file mode 100644
+index 0000000000..75dfe8e8d2
+--- /dev/null
++++ b/misc/tst-tagged-address-mod-6.c
+@@ -0,0 +1,34 @@
++/* Tests for set_tagged_address_mask to turn off tagged address.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <sys/tagged-address.h>
++#include <support/check.h>
++
++static void
++init (void)
++{
++  uintptr_t mask = (uintptr_t) -1;
++  if (set_tagged_address_mask (mask) != 0)
++    FAIL_EXIT1 ("set_tagged_address_mask failed: %m");
++}
++
++static void (*init_array []) (void)
++  __attribute__ ((used, section (".init_array"), aligned (sizeof (void *)))) =
++{
++  &init
++};
+diff --git a/misc/tst-tagged-address-mod-7.c b/misc/tst-tagged-address-mod-7.c
+new file mode 100644
+index 0000000000..c902a4e55e
+--- /dev/null
++++ b/misc/tst-tagged-address-mod-7.c
+@@ -0,0 +1,34 @@
++/* Tests for set_tagged_address_mask to turn off tagged address.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <sys/tagged-address.h>
++#include <support/check.h>
++
++static void
++init (void)
++{
++  uintptr_t mask = (uintptr_t) -1;
++  if (set_tagged_address_mask (mask) == 0)
++    FAIL_EXIT1 ("set_tagged_address_mask should have failed");
++}
++
++static void (*init_array []) (void)
++  __attribute__ ((used, section (".init_array"), aligned (sizeof (void *)))) =
++{
++  &init
++};
+diff --git a/sysdeps/generic/inline-tagged-address.h b/sysdeps/generic/inline-tagged-address.h
+new file mode 100644
+index 0000000000..a016b16f21
+--- /dev/null
++++ b/sysdeps/generic/inline-tagged-address.h
+@@ -0,0 +1,43 @@
++/* Inline tagged address functions.  Generic version.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <errno.h>
++
++static inline unsigned int
++__get_tagged_address_bits (void)
++{
++  return sizeof (uintptr_t) * 8;
++}
++
++static inline uintptr_t
++__get_tagged_address_mask (void)
++{
++  return (uintptr_t) -1;
++}
++
++static inline void *
++__tag_address (void *addr, unsigned int tag)
++{
++  return addr;
++}
++
++static inline void *
++__untag_address (void *addr)
++{
++  return addr;
++}
+diff --git a/sysdeps/generic/ldsodefs.h b/sysdeps/generic/ldsodefs.h
+index aab7245e93..5fac6f911c 100644
+--- a/sysdeps/generic/ldsodefs.h
++++ b/sysdeps/generic/ldsodefs.h
+@@ -480,6 +480,10 @@ struct rtld_global
+ #else
+   EXTERN int _dl_thread_gscope_count;
+ #endif
++
++  /* If nonzero, the mask for address bits used in address translation
++     is locked.  */
++  EXTERN int _dl_tagged_address_mask_locked;
+ #ifdef SHARED
+ };
+ # define __rtld_global_attribute__
+diff --git a/sysdeps/unix/sysv/linux/i386/libc.abilist b/sysdeps/unix/sysv/linux/i386/libc.abilist
+index ddc5837059..464c8af2ee 100644
+--- a/sysdeps/unix/sysv/linux/i386/libc.abilist
++++ b/sysdeps/unix/sysv/linux/i386/libc.abilist
+@@ -2241,6 +2241,11 @@ GLIBC_2.33 mknod F
+ GLIBC_2.33 mknodat F
+ GLIBC_2.33 stat F
+ GLIBC_2.33 stat64 F
++GLIBC_2.34 get_tagged_address_bits F
++GLIBC_2.34 get_tagged_address_mask F
++GLIBC_2.34 set_tagged_address_mask F
++GLIBC_2.34 tag_address F
++GLIBC_2.34 untag_address F
+ GLIBC_2.4 __confstr_chk F
+ GLIBC_2.4 __fgets_chk F
+ GLIBC_2.4 __fgets_unlocked_chk F
+diff --git a/sysdeps/unix/sysv/linux/x86_64/64/libc.abilist b/sysdeps/unix/sysv/linux/x86_64/64/libc.abilist
+index 2744bba4af..7486bf09bc 100644
+--- a/sysdeps/unix/sysv/linux/x86_64/64/libc.abilist
++++ b/sysdeps/unix/sysv/linux/x86_64/64/libc.abilist
+@@ -2088,6 +2088,11 @@ GLIBC_2.33 mknod F
+ GLIBC_2.33 mknodat F
+ GLIBC_2.33 stat F
+ GLIBC_2.33 stat64 F
++GLIBC_2.34 get_tagged_address_bits F
++GLIBC_2.34 get_tagged_address_mask F
++GLIBC_2.34 set_tagged_address_mask F
++GLIBC_2.34 tag_address F
++GLIBC_2.34 untag_address F
+ GLIBC_2.4 __confstr_chk F
+ GLIBC_2.4 __fgets_chk F
+ GLIBC_2.4 __fgets_unlocked_chk F
+diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/libc.abilist b/sysdeps/unix/sysv/linux/x86_64/x32/libc.abilist
+index ce2f4fb72b..d88202196f 100644
+--- a/sysdeps/unix/sysv/linux/x86_64/x32/libc.abilist
++++ b/sysdeps/unix/sysv/linux/x86_64/x32/libc.abilist
+@@ -2185,3 +2185,8 @@ GLIBC_2.33 mknod F
+ GLIBC_2.33 mknodat F
+ GLIBC_2.33 stat F
+ GLIBC_2.33 stat64 F
++GLIBC_2.34 get_tagged_address_bits F
++GLIBC_2.34 get_tagged_address_mask F
++GLIBC_2.34 set_tagged_address_mask F
++GLIBC_2.34 tag_address F
++GLIBC_2.34 untag_address F
+-- 
+2.31.1
+
diff --git a/0010-x86_64-Correct-THREAD_SETMEM-THREAD_SETMEM_NC-for-mo.patch b/0010-x86_64-Correct-THREAD_SETMEM-THREAD_SETMEM_NC-for-mo.patch
new file mode 100644
index 0000000..562a7b1
--- /dev/null
+++ b/0010-x86_64-Correct-THREAD_SETMEM-THREAD_SETMEM_NC-for-mo.patch
@@ -0,0 +1,143 @@
+From c83edf59d1faa3ea424da02c9531b2c6567d9c12 Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Tue, 16 Mar 2021 07:41:46 -0700
+Subject: [PATCH 10/24] x86_64: Correct THREAD_SETMEM/THREAD_SETMEM_NC for movq
+ [BZ #27591]
+
+config/i386/constraints.md in GCC has
+
+(define_constraint "e"
+  "32-bit signed integer constant, or a symbolic reference known
+   to fit that range (for immediate operands in sign-extending x86-64
+   instructions)."
+  (match_operand 0 "x86_64_immediate_operand"))
+
+Since movq takes a signed 32-bit immediate or a register source operand,
+use "er", instead of "nr"/"ir", constraint for 32-bit signed integer
+constant or register on movq.
+
+Reviewed-by: Carlos O'Donell <carlos@redhat.com>
+(cherry picked from commit b1ec623ed50bb8c7b9b6333fa350c3866dbde87f)
+---
+ sysdeps/x86_64/Makefile           |  2 +
+ sysdeps/x86_64/nptl/tls.h         | 10 ++++-
+ sysdeps/x86_64/tst-x86-64-tls-1.c | 64 +++++++++++++++++++++++++++++++
+ 3 files changed, 74 insertions(+), 2 deletions(-)
+ create mode 100644 sysdeps/x86_64/tst-x86-64-tls-1.c
+
+diff --git a/sysdeps/x86_64/Makefile b/sysdeps/x86_64/Makefile
+index d1d7cb9d2e..06a444b6af 100644
+--- a/sysdeps/x86_64/Makefile
++++ b/sysdeps/x86_64/Makefile
+@@ -183,6 +183,8 @@ ifeq (no,$(build-hardcoded-path-in-tests))
+ tests-container += tst-glibc-hwcaps-cache
+ endif
+ 
++tests-internal += tst-x86-64-tls-1
++
+ endif # $(subdir) == elf
+ 
+ ifeq ($(subdir),csu)
+diff --git a/sysdeps/x86_64/nptl/tls.h b/sysdeps/x86_64/nptl/tls.h
+index 20f0958780..a78c4f4d01 100644
+--- a/sysdeps/x86_64/nptl/tls.h
++++ b/sysdeps/x86_64/nptl/tls.h
+@@ -271,8 +271,11 @@ _Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
+ 		       "i" (offsetof (struct pthread, member)));	      \
+      else /* 8 */							      \
+        {								      \
++	 /* Since movq takes a signed 32-bit immediate or a register source   \
++	    operand, use "er" constraint for 32-bit signed integer constant   \
++	    or register.  */						      \
+ 	 asm volatile ("movq %q0,%%fs:%P1" :				      \
+-		       : IMM_MODE ((uint64_t) cast_to_integer (value)),	      \
++		       : "er" ((uint64_t) cast_to_integer (value)),	      \
+ 			 "i" (offsetof (struct pthread, member)));	      \
+        }})
+ 
+@@ -296,8 +299,11 @@ _Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
+ 		       "r" (idx));					      \
+      else /* 8 */							      \
+        {								      \
++	 /* Since movq takes a signed 32-bit immediate or a register source   \
++	    operand, use "er" constraint for 32-bit signed integer constant   \
++	    or register.  */						      \
+ 	 asm volatile ("movq %q0,%%fs:%P1(,%q2,8)" :			      \
+-		       : IMM_MODE ((uint64_t) cast_to_integer (value)),	      \
++		       : "er" ((uint64_t) cast_to_integer (value)),	      \
+ 			 "i" (offsetof (struct pthread, member[0])),	      \
+ 			 "r" (idx));					      \
+        }})
+diff --git a/sysdeps/x86_64/tst-x86-64-tls-1.c b/sysdeps/x86_64/tst-x86-64-tls-1.c
+new file mode 100644
+index 0000000000..354635884e
+--- /dev/null
++++ b/sysdeps/x86_64/tst-x86-64-tls-1.c
+@@ -0,0 +1,64 @@
++/* Test THREAD_SETMEM and THREAD_SETMEM_NC for IMM64.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <tls.h>
++#include <support/check.h>
++
++static int
++do_test (void)
++{
++  unsigned long long int saved_ssp_base, ssp_base;
++  saved_ssp_base = THREAD_GETMEM (THREAD_SELF, header.ssp_base);
++
++  THREAD_SETMEM (THREAD_SELF, header.ssp_base, (1ULL << 57) - 1);
++  ssp_base = THREAD_GETMEM (THREAD_SELF, header.ssp_base);
++  if (ssp_base != ((1ULL << 57) - 1))
++    FAIL_EXIT1 ("THREAD_SETMEM: 0x%llx != 0x%llx",
++		ssp_base, (1ULL << 57) - 1);
++
++  THREAD_SETMEM (THREAD_SELF, header.ssp_base, -1ULL);
++  ssp_base = THREAD_GETMEM (THREAD_SELF, header.ssp_base);
++  if (ssp_base != -1ULL)
++    FAIL_EXIT1 ("THREAD_SETMEM: 0x%llx != 0x%llx", ssp_base, -1ULL);
++
++  THREAD_SETMEM (THREAD_SELF, header.ssp_base, saved_ssp_base);
++#ifndef __ILP32__
++  struct pthread_key_data *saved_specific, *specific;
++  saved_specific = THREAD_GETMEM_NC (THREAD_SELF, specific, 1);
++
++  uintptr_t value = (1UL << 57) - 1;
++  THREAD_SETMEM_NC (THREAD_SELF, specific, 1,
++		    (struct pthread_key_data *) value);
++  specific = THREAD_GETMEM_NC (THREAD_SELF, specific, 1);
++  if (specific != (struct pthread_key_data *) value)
++    FAIL_EXIT1 ("THREAD_GETMEM_NC: %p != %p",
++		specific, (struct pthread_key_data *) value);
++
++  THREAD_SETMEM_NC (THREAD_SELF, specific, 1,
++		    (struct pthread_key_data *) -1UL);
++  specific = THREAD_GETMEM_NC (THREAD_SELF, specific, 1);
++  if (specific != (struct pthread_key_data *) -1UL)
++    FAIL_EXIT1 ("THREAD_GETMEM_NC: %p != %p",
++		specific, (struct pthread_key_data *) -1UL);
++
++  THREAD_SETMEM_NC (THREAD_SELF, specific, 1, saved_specific);
++#endif
++  return 0;
++}
++
++#include <support/test-driver.c>
+-- 
+2.31.1
+
diff --git a/0011-Add-GNU_PROPERTY_X86_FEATURE_1_LAM_U-48-57.patch b/0011-Add-GNU_PROPERTY_X86_FEATURE_1_LAM_U-48-57.patch
new file mode 100644
index 0000000..b36ff29
--- /dev/null
+++ b/0011-Add-GNU_PROPERTY_X86_FEATURE_1_LAM_U-48-57.patch
@@ -0,0 +1,27 @@
+From 12a9f82e169187e7b3963c9d33bf3573777c9b11 Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Thu, 7 Jan 2021 06:45:56 -0800
+Subject: [PATCH 11/24] Add GNU_PROPERTY_X86_FEATURE_1_LAM_U[48|57]
+
+---
+ elf/elf.h | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+diff --git a/elf/elf.h b/elf/elf.h
+index 9ebd052c8a..7e1d34f433 100644
+--- a/elf/elf.h
++++ b/elf/elf.h
+@@ -1351,6 +1351,10 @@ typedef struct
+ /* This indicates that all executable sections are compatible with
+    SHSTK.  */
+ #define GNU_PROPERTY_X86_FEATURE_1_SHSTK	(1U << 1)
++/* This indicates that all sections are compatible with LAM_U48.  */
++#define GNU_PROPERTY_X86_FEATURE_1_LAM_U48	(1U << 2)
++/* This indicates that all sections are compatible with LAM_U57.  */
++#define GNU_PROPERTY_X86_FEATURE_1_LAM_U57	(1U << 3)
+ 
+ /* Move records.  */
+ typedef struct
+-- 
+2.31.1
+
diff --git a/0012-Initial-enable-lam.patch b/0012-Initial-enable-lam.patch
new file mode 100644
index 0000000..2f25b39
--- /dev/null
+++ b/0012-Initial-enable-lam.patch
@@ -0,0 +1,511 @@
+From 52b68df02f08ed17e5e3f5a19b6a706957c12a81 Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Sat, 9 Jan 2021 08:21:04 -0800
+Subject: [PATCH 12/24] Initial --enable-lam
+
+---
+ config.h.in                  |  8 +++-
+ configure                    | 11 +++++
+ configure.ac                 |  6 +++
+ sysdeps/x86/cet-control.h    | 25 +++++------
+ sysdeps/x86/configure        |  4 +-
+ sysdeps/x86/configure.ac     |  4 +-
+ sysdeps/x86/cpu-features.c   |  4 +-
+ sysdeps/x86/cpu-tunables.c   | 12 +++---
+ sysdeps/x86/dl-cet.c         | 32 +++++++--------
+ sysdeps/x86/dl-procruntime.c |  1 +
+ sysdeps/x86_64/64/Makefile   |  6 +++
+ sysdeps/x86_64/configure     | 80 ++++++++++++++++++++++++++++++++++++
+ sysdeps/x86_64/configure.ac  | 47 +++++++++++++++++++++
+ 13 files changed, 199 insertions(+), 41 deletions(-)
+ create mode 100644 sysdeps/x86_64/64/Makefile
+
+diff --git a/config.h.in b/config.h.in
+index f21bf04e47..31cfc90925 100644
+--- a/config.h.in
++++ b/config.h.in
+@@ -190,6 +190,9 @@
+ /* Define if the linker defines __ehdr_start.  */
+ #undef HAVE_EHDR_START
+ 
++/* Build glibc with x86-64 LAM support.  */
++#define LAM_ENABLED 0
++
+ /*
+  */
+ 
+@@ -270,7 +273,10 @@
+ #define CAN_USE_REGISTER_ASM_EBP 0
+ 
+ /* The default value of x86 CET control.  */
+-#define DEFAULT_DL_X86_CET_CONTROL cet_elf_property
++#define DEFAULT_DL_X86_CET_CONTROL x86_feature_elf_property
++
++/* The default value of x86-64 LAM control.  */
++#define DEFAULT_DL_X86_64_LAM_CONTROL x86_feature_elf_property
+ 
+ /* Define if x86 ISA level should be included in shared libraries.  */
+ #undef INCLUDE_X86_ISA_LEVEL
+diff --git a/configure b/configure
+index 1dc3af60b4..0b124b9762 100755
+--- a/configure
++++ b/configure
+@@ -791,6 +791,7 @@ enable_pt_chown
+ enable_tunables
+ enable_mathvec
+ enable_cet
++enable_lam
+ with_cpu
+ '
+       ac_precious_vars='build_alias
+@@ -1466,6 +1467,8 @@ Optional Features:
+                           depends on architecture]
+   --enable-cet            enable Intel Control-flow Enforcement Technology
+                           (CET), x86 only
++  --enable-lam            enable Intel Linear Address Masking (LAM), x86-64
++                          only
+ 
+ Optional Packages:
+   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+@@ -3791,6 +3794,14 @@ else
+ fi
+ 
+ 
++# Check whether --enable-lam was given.
++if test "${enable_lam+set}" = set; then :
++  enableval=$enable_lam; enable_lam=$enableval
++else
++  enable_lam=no
++fi
++
++
+ # We keep the original values in `$config_*' and never modify them, so we
+ # can write them unchanged into config.make.  Everything else uses
+ # $machine, $vendor, and $os, and changes them whenever convenient.
+diff --git a/configure.ac b/configure.ac
+index dfebb8a7cc..7b5dd14cf8 100644
+--- a/configure.ac
++++ b/configure.ac
+@@ -479,6 +479,12 @@ AC_ARG_ENABLE([cet],
+ 	      [enable_cet=$enableval],
+ 	      [enable_cet=$libc_cv_compiler_default_cet])
+ 
++AC_ARG_ENABLE([lam],
++	      AC_HELP_STRING([--enable-lam],
++			     [enable Intel Linear Address Masking (LAM), x86-64 only]),
++	      [enable_lam=$enableval],
++	      [enable_lam=no])
++
+ # We keep the original values in `$config_*' and never modify them, so we
+ # can write them unchanged into config.make.  Everything else uses
+ # $machine, $vendor, and $os, and changes them whenever convenient.
+diff --git a/sysdeps/x86/cet-control.h b/sysdeps/x86/cet-control.h
+index eabc679908..403d00120e 100644
+--- a/sysdeps/x86/cet-control.h
++++ b/sysdeps/x86/cet-control.h
+@@ -19,23 +19,24 @@
+ #ifndef _CET_CONTROL_H
+ #define _CET_CONTROL_H
+ 
+-/* For each CET feature, IBT and SHSTK, valid control values.  */
+-enum dl_x86_cet_control
++/* For each x86 feature, IBT and SHSTK, valid control values.  */
++enum dl_x86_feature_control_enum
+ {
+-  /* Enable CET features based on ELF property note.  */
+-  cet_elf_property = 0,
+-  /* Always enable CET features.  */
+-  cet_always_on,
+-  /* Always disable CET features.  */
+-  cet_always_off,
+-  /* Enable CET features permissively.  */
+-  cet_permissive
++  /* Enable features based on ELF property note.  */
++  x86_feature_elf_property = 0,
++  /* Always enable features.  */
++  x86_feature_always_on,
++  /* Always disable features.  */
++  x86_feature_always_off,
++  /* Enable features permissively.  */
++  x86_feature_permissive
+ };
+ 
+ struct dl_x86_feature_control
+ {
+-  enum dl_x86_cet_control ibt : 2;
+-  enum dl_x86_cet_control shstk : 2;
++  enum dl_x86_feature_control_enum ibt : 2;
++  enum dl_x86_feature_control_enum shstk : 2;
++  enum dl_x86_feature_control_enum lam : 2;
+ };
+ 
+ #endif /* cet-control.h */
+diff --git a/sysdeps/x86/configure b/sysdeps/x86/configure
+index ead1295c38..f72008587e 100644
+--- a/sysdeps/x86/configure
++++ b/sysdeps/x86/configure
+@@ -60,10 +60,10 @@ $as_echo "$libc_cv_x86_cet_as" >&6; }
+   fi
+ fi
+ if test $enable_cet = yes; then
+-  $as_echo "#define DEFAULT_DL_X86_CET_CONTROL cet_elf_property" >>confdefs.h
++  $as_echo "#define DEFAULT_DL_X86_CET_CONTROL x86_feature_elf_property" >>confdefs.h
+ 
+ elif test $enable_cet = permissive; then
+-  $as_echo "#define DEFAULT_DL_X86_CET_CONTROL cet_permissive" >>confdefs.h
++  $as_echo "#define DEFAULT_DL_X86_CET_CONTROL x86_feature_permissive" >>confdefs.h
+ 
+ fi
+ config_vars="$config_vars
+diff --git a/sysdeps/x86/configure.ac b/sysdeps/x86/configure.ac
+index bca97fdc2f..f24f17c99a 100644
+--- a/sysdeps/x86/configure.ac
++++ b/sysdeps/x86/configure.ac
+@@ -38,9 +38,9 @@ EOF
+   fi
+ fi
+ if test $enable_cet = yes; then
+-  AC_DEFINE(DEFAULT_DL_X86_CET_CONTROL, cet_elf_property)
++  AC_DEFINE(DEFAULT_DL_X86_CET_CONTROL, x86_feature_elf_property)
+ elif test $enable_cet = permissive; then
+-  AC_DEFINE(DEFAULT_DL_X86_CET_CONTROL, cet_permissive)
++  AC_DEFINE(DEFAULT_DL_X86_CET_CONTROL, x86_feature_permissive)
+ fi
+ LIBC_CONFIG_VAR([enable-cet], [$enable_cet])
+ 
+diff --git a/sysdeps/x86/cpu-features.c b/sysdeps/x86/cpu-features.c
+index dfad82f14c..819746ae37 100644
+--- a/sysdeps/x86/cpu-features.c
++++ b/sysdeps/x86/cpu-features.c
+@@ -759,8 +759,8 @@ no_cpuid:
+ 
+ 	  /* Lock CET if IBT or SHSTK is enabled in executable.  Don't
+ 	     lock CET if IBT or SHSTK is enabled permissively.  */
+-	  if (GL(dl_x86_feature_control).ibt != cet_permissive
+-	      && GL(dl_x86_feature_control).shstk != cet_permissive)
++	  if (GL(dl_x86_feature_control).ibt != x86_feature_permissive
++	      && GL(dl_x86_feature_control).shstk != x86_feature_permissive)
+ 	    dl_cet_lock_cet ();
+ 	}
+ # endif
+diff --git a/sysdeps/x86/cpu-tunables.c b/sysdeps/x86/cpu-tunables.c
+index a90df39b78..b36a8c2a08 100644
+--- a/sysdeps/x86/cpu-tunables.c
++++ b/sysdeps/x86/cpu-tunables.c
+@@ -300,12 +300,12 @@ void
+ TUNABLE_CALLBACK (set_x86_ibt) (tunable_val_t *valp)
+ {
+   if (DEFAULT_MEMCMP (valp->strval, "on", sizeof ("on")) == 0)
+-    GL(dl_x86_feature_control).ibt = cet_always_on;
++    GL(dl_x86_feature_control).ibt = x86_feature_always_on;
+   else if (DEFAULT_MEMCMP (valp->strval, "off", sizeof ("off")) == 0)
+-    GL(dl_x86_feature_control).ibt = cet_always_off;
++    GL(dl_x86_feature_control).ibt = x86_feature_always_off;
+   else if (DEFAULT_MEMCMP (valp->strval, "permissive",
+ 			   sizeof ("permissive")) == 0)
+-    GL(dl_x86_feature_control).ibt = cet_permissive;
++    GL(dl_x86_feature_control).ibt = x86_feature_permissive;
+ }
+ 
+ attribute_hidden
+@@ -313,12 +313,12 @@ void
+ TUNABLE_CALLBACK (set_x86_shstk) (tunable_val_t *valp)
+ {
+   if (DEFAULT_MEMCMP (valp->strval, "on", sizeof ("on")) == 0)
+-    GL(dl_x86_feature_control).shstk = cet_always_on;
++    GL(dl_x86_feature_control).shstk = x86_feature_always_on;
+   else if (DEFAULT_MEMCMP (valp->strval, "off", sizeof ("off")) == 0)
+-    GL(dl_x86_feature_control).shstk = cet_always_off;
++    GL(dl_x86_feature_control).shstk = x86_feature_always_off;
+   else if (DEFAULT_MEMCMP (valp->strval, "permissive",
+ 			   sizeof ("permissive")) == 0)
+-    GL(dl_x86_feature_control).shstk = cet_permissive;
++    GL(dl_x86_feature_control).shstk = x86_feature_permissive;
+ }
+ # endif
+ #endif
+diff --git a/sysdeps/x86/dl-cet.c b/sysdeps/x86/dl-cet.c
+index c74e577289..6a9cefd3ea 100644
+--- a/sysdeps/x86/dl-cet.c
++++ b/sysdeps/x86/dl-cet.c
+@@ -38,15 +38,15 @@ static void
+ dl_cet_check (struct link_map *m, const char *program)
+ {
+   /* Check how IBT should be enabled.  */
+-  enum dl_x86_cet_control enable_ibt_type
++  enum dl_x86_feature_control_enum enable_ibt_type
+     = GL(dl_x86_feature_control).ibt;
+   /* Check how SHSTK should be enabled.  */
+-  enum dl_x86_cet_control enable_shstk_type
++  enum dl_x86_feature_control_enum enable_shstk_type
+     = GL(dl_x86_feature_control).shstk;
+ 
+   /* No legacy object check if both IBT and SHSTK are always on.  */
+-  if (enable_ibt_type == cet_always_on
+-      && enable_shstk_type == cet_always_on)
++  if (enable_ibt_type == x86_feature_always_on
++      && enable_shstk_type == x86_feature_always_on)
+     {
+       THREAD_SETMEM (THREAD_SELF, header.feature_1, GL(dl_x86_feature_1));
+       return;
+@@ -67,9 +67,9 @@ dl_cet_check (struct link_map *m, const char *program)
+ 
+       /* Check if IBT and SHSTK are enabled in object.  */
+       bool enable_ibt = (ibt_enabled
+-			 && enable_ibt_type != cet_always_off);
++			 && enable_ibt_type != x86_feature_always_off);
+       bool enable_shstk = (shstk_enabled
+-			   && enable_shstk_type != cet_always_off);
++			   && enable_shstk_type != x86_feature_always_off);
+       if (program)
+ 	{
+ 	  /* Enable IBT and SHSTK only if they are enabled in executable.
+@@ -78,11 +78,11 @@ dl_cet_check (struct link_map *m, const char *program)
+ 	     GLIBC_TUNABLES=glibc.cpu.hwcaps=-IBT,-SHSTK
+ 	   */
+ 	  enable_ibt &= (CPU_FEATURE_USABLE (IBT)
+-			 && (enable_ibt_type == cet_always_on
++			 && (enable_ibt_type == x86_feature_always_on
+ 			     || (m->l_x86_feature_1_and
+ 				 & GNU_PROPERTY_X86_FEATURE_1_IBT) != 0));
+ 	  enable_shstk &= (CPU_FEATURE_USABLE (SHSTK)
+-			   && (enable_shstk_type == cet_always_on
++			   && (enable_shstk_type == x86_feature_always_on
+ 			       || (m->l_x86_feature_1_and
+ 				   & GNU_PROPERTY_X86_FEATURE_1_SHSTK) != 0));
+ 	}
+@@ -115,7 +115,7 @@ dl_cet_check (struct link_map *m, const char *program)
+ 
+ 	      /* IBT is enabled only if it is enabled in executable as
+ 		 well as all shared objects.  */
+-	      enable_ibt &= (enable_ibt_type == cet_always_on
++	      enable_ibt &= (enable_ibt_type == x86_feature_always_on
+ 			     || (l->l_x86_feature_1_and
+ 				 & GNU_PROPERTY_X86_FEATURE_1_IBT) != 0);
+ 	      if (!found_ibt_legacy && enable_ibt != ibt_enabled)
+@@ -126,7 +126,7 @@ dl_cet_check (struct link_map *m, const char *program)
+ 
+ 	      /* SHSTK is enabled only if it is enabled in executable as
+ 		 well as all shared objects.  */
+-	      enable_shstk &= (enable_shstk_type == cet_always_on
++	      enable_shstk &= (enable_shstk_type == x86_feature_always_on
+ 			       || (l->l_x86_feature_1_and
+ 				   & GNU_PROPERTY_X86_FEATURE_1_SHSTK) != 0);
+ 	      if (enable_shstk != shstk_enabled)
+@@ -143,7 +143,7 @@ dl_cet_check (struct link_map *m, const char *program)
+ 	{
+ 	  if (!program)
+ 	    {
+-	      if (enable_ibt_type != cet_permissive)
++	      if (enable_ibt_type != x86_feature_permissive)
+ 		{
+ 		  /* When IBT is enabled, we cannot dlopen a shared
+ 		     object without IBT.  */
+@@ -154,7 +154,7 @@ dl_cet_check (struct link_map *m, const char *program)
+ 				      N_("rebuild shared object with IBT support enabled"));
+ 		}
+ 
+-	      if (enable_shstk_type != cet_permissive)
++	      if (enable_shstk_type != x86_feature_permissive)
+ 		{
+ 		  /* When SHSTK is enabled, we cannot dlopen a shared
+ 		     object without SHSTK.  */
+@@ -165,8 +165,8 @@ dl_cet_check (struct link_map *m, const char *program)
+ 				      N_("rebuild shared object with SHSTK support enabled"));
+ 		}
+ 
+-	      if (enable_ibt_type != cet_permissive
+-		  && enable_shstk_type != cet_permissive)
++	      if (enable_ibt_type != x86_feature_permissive
++		  && enable_shstk_type != x86_feature_permissive)
+ 		return;
+ 	    }
+ 
+@@ -205,9 +205,9 @@ dl_cet_check (struct link_map *m, const char *program)
+       if (program && (ibt_enabled || shstk_enabled))
+ 	{
+ 	  if ((!ibt_enabled
+-	       || enable_ibt_type != cet_permissive)
++	       || enable_ibt_type != x86_feature_permissive)
+ 	      && (!shstk_enabled
+-		  || enable_shstk_type != cet_permissive))
++		  || enable_shstk_type != x86_feature_permissive))
+ 	    {
+ 	      /* Lock CET if IBT or SHSTK is enabled in executable unless
+ 	         IBT or SHSTK is enabled permissively.  */
+diff --git a/sysdeps/x86/dl-procruntime.c b/sysdeps/x86/dl-procruntime.c
+index a2a4ab6a5f..a726eef618 100644
+--- a/sysdeps/x86/dl-procruntime.c
++++ b/sysdeps/x86/dl-procruntime.c
+@@ -67,6 +67,7 @@ PROCINFO_CLASS struct dl_x86_feature_control _dl_x86_feature_control
+ = {
+     .ibt = DEFAULT_DL_X86_CET_CONTROL,
+     .shstk = DEFAULT_DL_X86_CET_CONTROL,
++    .lam = DEFAULT_DL_X86_64_LAM_CONTROL,
+   }
+ # endif
+ # if !defined SHARED || defined PROCINFO_DECL
+diff --git a/sysdeps/x86_64/64/Makefile b/sysdeps/x86_64/64/Makefile
+new file mode 100644
+index 0000000000..798affea1c
+--- /dev/null
++++ b/sysdeps/x86_64/64/Makefile
+@@ -0,0 +1,6 @@
++ifneq ($(enable-lam),no)
++# Mark linker output LAM_U48 compatible.
++lam-LDFLAGS = $(if $($(@F)-no-z-lam-u48),,-Wl,-z,lam-u48)
++sysdep-LDFLAGS += $(lam-LDFLAGS)
++LDFLAGS-rtld += $(lam-LDFLAGS)
++endif
+diff --git a/sysdeps/x86_64/configure b/sysdeps/x86_64/configure
+index 198554d788..e7c7b93991 100644
+--- a/sysdeps/x86_64/configure
++++ b/sysdeps/x86_64/configure
+@@ -140,6 +140,86 @@ $as_echo "$libc_cv_ld_static_pie" >&6; }
+   fi
+ fi
+ 
++# LAM is only supported in 64-bit.
++
++cat confdefs.h - <<_ACEOF >conftest.$ac_ext
++/* end confdefs.h.  */
++
++#ifdef __ILP32__
++# error LAM is not supported.
++#endif
++
++int
++main ()
++{
++
++  ;
++  return 0;
++}
++_ACEOF
++if ac_fn_c_try_compile "$LINENO"; then :
++
++else
++  if test $enable_lam != no; then
++  as_fn_error $? "LAM is not supported for x32" "$LINENO" 5
++fi
++fi
++rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
++
++if test $enable_lam = no; then
++  lam_enabled=0
++else
++  # Check if CET is also enabled.
++  if test $enable_cet = no; then
++    as_fn_error $? "CET must be enabled to support LAM" "$LINENO" 5
++  fi
++  # Check if linker supports LAM.
++  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $LD supports LAM" >&5
++$as_echo_n "checking whether $LD supports LAM... " >&6; }
++if ${libc_cv_x86_64_lam_ld+:} false; then :
++  $as_echo_n "(cached) " >&6
++else
++  cat > conftest.s <<EOF
++	.text
++	.globl lam
++lam:
++	ret
++EOF
++		 libc_cv_x86_64_lam_ld=no
++		 if { ac_try='${CC-cc} -Wl,-z,lam-u48 -shared $CFLAGS conftest.s -o conftest.so 1>&5'
++  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
++  test $ac_status = 0; }; }; then
++		   lam=`LC_ALL=C $READELF -n conftest.so | grep LAM_U48`
++		   if test -n "$lam"; then
++		     libc_cv_x86_64_lam_ld=yes
++		   fi
++		 fi
++		 rm -rf conftest*
++fi
++{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $libc_cv_x86_64_lam_ld" >&5
++$as_echo "$libc_cv_x86_64_lam_ld" >&6; }
++  if test $libc_cv_x86_64_lam_ld = no; then
++    as_fn_error $? "$LD doesn't support LAM" "$LINENO" 5
++  fi
++  lam_enabled=1
++fi
++if test $enable_lam = yes; then
++  $as_echo "#define DEFAULT_DL_X86_64_LAM_CONTROL x86_feature_elf_property" >>confdefs.h
++
++elif test $enable_lam = permissive; then
++  $as_echo "#define DEFAULT_DL_X86_64_LAM_CONTROL x86_feature_permissive" >>confdefs.h
++
++fi
++cat >>confdefs.h <<_ACEOF
++#define LAM_ENABLED $lam_enabled
++_ACEOF
++
++config_vars="$config_vars
++enable-lam = $enable_lam"
++
+ $as_echo "#define PI_STATIC_AND_HIDDEN 1" >>confdefs.h
+ 
+ 
+diff --git a/sysdeps/x86_64/configure.ac b/sysdeps/x86_64/configure.ac
+index ec776274af..b09e2928ea 100644
+--- a/sysdeps/x86_64/configure.ac
++++ b/sysdeps/x86_64/configure.ac
+@@ -78,6 +78,53 @@ rm -f conftest*])
+   fi
+ fi
+ 
++# LAM is only supported in 64-bit.
++AC_COMPILE_IFELSE([AC_LANG_PROGRAM([
++#ifdef __ILP32__
++# error LAM is not supported.
++#endif
++])],,
++if test $enable_lam != no; then
++  AC_MSG_ERROR([LAM is not supported for x32])
++fi)
++
++if test $enable_lam = no; then
++  lam_enabled=0
++else
++  # Check if CET is also enabled.
++  if test $enable_cet = no; then
++    AC_MSG_ERROR([CET must be enabled to support LAM])
++  fi
++  # Check if linker supports LAM.
++  AC_CACHE_CHECK(whether $LD supports LAM,
++		 libc_cv_x86_64_lam_ld, [dnl
++cat > conftest.s <<EOF
++	.text
++	.globl lam
++lam:
++	ret
++EOF
++		 libc_cv_x86_64_lam_ld=no
++		 if AC_TRY_COMMAND([${CC-cc} -Wl,-z,lam-u48 -shared $CFLAGS conftest.s -o conftest.so 1>&AS_MESSAGE_LOG_FD]); then
++		   lam=`LC_ALL=C $READELF -n conftest.so | grep LAM_U48`
++		   if test -n "$lam"; then
++		     libc_cv_x86_64_lam_ld=yes
++		   fi
++		 fi
++		 rm -rf conftest*])
++  if test $libc_cv_x86_64_lam_ld = no; then
++    AC_MSG_ERROR([$LD doesn't support LAM])
++  fi
++  lam_enabled=1
++fi
++if test $enable_lam = yes; then
++  AC_DEFINE(DEFAULT_DL_X86_64_LAM_CONTROL, x86_feature_elf_property)
++elif test $enable_lam = permissive; then
++  AC_DEFINE(DEFAULT_DL_X86_64_LAM_CONTROL, x86_feature_permissive)
++fi
++AC_DEFINE_UNQUOTED(LAM_ENABLED, $lam_enabled)
++LIBC_CONFIG_VAR([enable-lam], [$enable_lam])
++
+ dnl It is always possible to access static and hidden symbols in an
+ dnl position independent way.
+ AC_DEFINE(PI_STATIC_AND_HIDDEN)
+-- 
+2.31.1
+
diff --git a/0013-Rename-dl-cet.-ch-to-dl-feature.-ch.patch b/0013-Rename-dl-cet.-ch-to-dl-feature.-ch.patch
new file mode 100644
index 0000000..1cb9e6a
--- /dev/null
+++ b/0013-Rename-dl-cet.-ch-to-dl-feature.-ch.patch
@@ -0,0 +1,253 @@
+From d00eea1a95bd5c99970e5ebef913ada59d725126 Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Sat, 9 Jan 2021 16:45:24 -0800
+Subject: [PATCH 13/24] Rename dl-cet.[ch] to dl-feature.[ch]
+
+Also rename cet-control.h to feature-control.h
+---
+ sysdeps/unix/sysv/linux/x86/cpu-features.c       |  2 +-
+ .../sysv/linux/x86/{dl-cet.h => dl-feature.h}    |  2 +-
+ sysdeps/x86/Makefile                             |  2 +-
+ sysdeps/x86/cpu-features.c                       |  6 +++---
+ sysdeps/x86/cpu-tunables.c                       |  2 +-
+ sysdeps/x86/{dl-cet.c => dl-feature.c}           | 16 ++++++++--------
+ sysdeps/x86/dl-prop.h                            | 12 ++++++------
+ sysdeps/x86/{cet-control.h => feature-control.h} |  8 ++++----
+ sysdeps/x86/ldsodefs.h                           |  2 +-
+ sysdeps/x86/sysdep.h                             |  2 ++
+ 10 files changed, 28 insertions(+), 26 deletions(-)
+ rename sysdeps/unix/sysv/linux/x86/{dl-cet.h => dl-feature.h} (96%)
+ rename sysdeps/x86/{dl-cet.c => dl-feature.c} (95%)
+ rename sysdeps/x86/{cet-control.h => feature-control.h} (92%)
+
+diff --git a/sysdeps/unix/sysv/linux/x86/cpu-features.c b/sysdeps/unix/sysv/linux/x86/cpu-features.c
+index 76ef99d4a1..775c4c3ac4 100644
+--- a/sysdeps/unix/sysv/linux/x86/cpu-features.c
++++ b/sysdeps/unix/sysv/linux/x86/cpu-features.c
+@@ -16,7 +16,7 @@
+    License along with the GNU C Library; if not, see
+    <https://www.gnu.org/licenses/>.  */
+ 
+-#if CET_ENABLED
++#if X86_FEATURE_ENABLED
+ # include <sys/prctl.h>
+ # include <asm/prctl.h>
+ 
+diff --git a/sysdeps/unix/sysv/linux/x86/dl-cet.h b/sysdeps/unix/sysv/linux/x86/dl-feature.h
+similarity index 96%
+rename from sysdeps/unix/sysv/linux/x86/dl-cet.h
+rename to sysdeps/unix/sysv/linux/x86/dl-feature.h
+index a431b601cc..d1cd35de43 100644
+--- a/sysdeps/unix/sysv/linux/x86/dl-cet.h
++++ b/sysdeps/unix/sysv/linux/x86/dl-feature.h
+@@ -1,4 +1,4 @@
+-/* Linux/x86 CET initializers function.
++/* Linux/x86 feature initializers function.
+    Copyright (C) 2018-2021 Free Software Foundation, Inc.
+ 
+    The GNU C Library is free software; you can redistribute it and/or
+diff --git a/sysdeps/x86/Makefile b/sysdeps/x86/Makefile
+index 3ff6b7b390..343fecf1e8 100644
+--- a/sysdeps/x86/Makefile
++++ b/sysdeps/x86/Makefile
+@@ -100,7 +100,7 @@ endif
+ 
+ ifneq ($(enable-cet),no)
+ ifeq ($(subdir),elf)
+-sysdep-dl-routines += dl-cet
++sysdep-dl-routines += dl-feature
+ 
+ tests += tst-cet-legacy-1 tst-cet-legacy-1a tst-cet-legacy-2 \
+ 	 tst-cet-legacy-2a tst-cet-legacy-3 tst-cet-legacy-4 \
+diff --git a/sysdeps/x86/cpu-features.c b/sysdeps/x86/cpu-features.c
+index 819746ae37..8c214e2fab 100644
+--- a/sysdeps/x86/cpu-features.c
++++ b/sysdeps/x86/cpu-features.c
+@@ -34,8 +34,8 @@ extern void TUNABLE_CALLBACK (set_x86_shstk) (tunable_val_t *)
+ # endif
+ #endif
+ 
+-#if CET_ENABLED
+-# include <dl-cet.h>
++#if X86_FEATURE_ENABLED
++# include <dl-feature.h>
+ #endif
+ 
+ static void
+@@ -712,7 +712,7 @@ no_cpuid:
+     GLRO(dl_platform) = "i586";
+ #endif
+ 
+-#if CET_ENABLED
++#if X86_FEATURE_ENABLED
+ # if HAVE_TUNABLES
+   TUNABLE_GET (x86_ibt, tunable_val_t *,
+ 	       TUNABLE_CALLBACK (set_x86_ibt));
+diff --git a/sysdeps/x86/cpu-tunables.c b/sysdeps/x86/cpu-tunables.c
+index b36a8c2a08..402ed4c32d 100644
+--- a/sysdeps/x86/cpu-tunables.c
++++ b/sysdeps/x86/cpu-tunables.c
+@@ -293,7 +293,7 @@ TUNABLE_CALLBACK (set_hwcaps) (tunable_val_t *valp)
+   while (*p != '\0');
+ }
+ 
+-# if CET_ENABLED
++# if X86_FEATURE_ENABLED
+ 
+ attribute_hidden
+ void
+diff --git a/sysdeps/x86/dl-cet.c b/sysdeps/x86/dl-feature.c
+similarity index 95%
+rename from sysdeps/x86/dl-cet.c
+rename to sysdeps/x86/dl-feature.c
+index 6a9cefd3ea..a2774718cc 100644
+--- a/sysdeps/x86/dl-cet.c
++++ b/sysdeps/x86/dl-feature.c
+@@ -1,4 +1,4 @@
+-/* x86 CET initializers function.
++/* x86 feature initializers function.
+    Copyright (C) 2018-2021 Free Software Foundation, Inc.
+ 
+    The GNU C Library is free software; you can redistribute it and/or
+@@ -19,7 +19,7 @@
+ #include <errno.h>
+ #include <libintl.h>
+ #include <ldsodefs.h>
+-#include <dl-cet.h>
++#include <dl-feature.h>
+ 
+ /* GNU_PROPERTY_X86_FEATURE_1_IBT and GNU_PROPERTY_X86_FEATURE_1_SHSTK
+    are defined in <elf.h>, which are only available for C sources.
+@@ -32,10 +32,10 @@
+ # error GNU_PROPERTY_X86_FEATURE_1_SHSTK != X86_FEATURE_1_SHSTK
+ #endif
+ 
+-/* Check if object M is compatible with CET.  */
++/* Check if object M is compatible with x86 features.  */
+ 
+ static void
+-dl_cet_check (struct link_map *m, const char *program)
++dl_feature_check (struct link_map *m, const char *program)
+ {
+   /* Check how IBT should be enabled.  */
+   enum dl_x86_feature_control_enum enable_ibt_type
+@@ -235,9 +235,9 @@ dl_cet_check (struct link_map *m, const char *program)
+ }
+ 
+ void
+-_dl_cet_open_check (struct link_map *l)
++_dl_feature_open_check (struct link_map *l)
+ {
+-  dl_cet_check (l, NULL);
++  dl_feature_check (l, NULL);
+ }
+ 
+ #ifdef SHARED
+@@ -248,8 +248,8 @@ _dl_cet_open_check (struct link_map *l)
+ 
+ LINKAGE
+ void
+-_dl_cet_check (struct link_map *main_map, const char *program)
++_dl_feature_check (struct link_map *main_map, const char *program)
+ {
+-  dl_cet_check (main_map, program);
++  dl_feature_check (main_map, program);
+ }
+ #endif /* SHARED */
+diff --git a/sysdeps/x86/dl-prop.h b/sysdeps/x86/dl-prop.h
+index 56bd020b3c..5358086a64 100644
+--- a/sysdeps/x86/dl-prop.h
++++ b/sysdeps/x86/dl-prop.h
+@@ -21,9 +21,9 @@
+ 
+ #include <libintl.h>
+ 
+-extern void _dl_cet_check (struct link_map *, const char *)
++extern void _dl_feature_check (struct link_map *, const char *)
+     attribute_hidden;
+-extern void _dl_cet_open_check (struct link_map *)
++extern void _dl_feature_open_check (struct link_map *)
+     attribute_hidden;
+ 
+ static void
+@@ -67,8 +67,8 @@ static inline void __attribute__ ((always_inline))
+ _rtld_main_check (struct link_map *m, const char *program)
+ {
+   dl_isa_level_check (m, program);
+-#if CET_ENABLED
+-  _dl_cet_check (m, program);
++#if X86_FEATURE_ENABLED
++  _dl_feature_check (m, program);
+ #endif
+ }
+ 
+@@ -76,8 +76,8 @@ static inline void __attribute__ ((always_inline))
+ _dl_open_check (struct link_map *m)
+ {
+   dl_isa_level_check (m, NULL);
+-#if CET_ENABLED
+-  _dl_cet_open_check (m);
++#if X86_FEATURE_ENABLED
++  _dl_feature_open_check (m);
+ #endif
+ }
+ 
+diff --git a/sysdeps/x86/cet-control.h b/sysdeps/x86/feature-control.h
+similarity index 92%
+rename from sysdeps/x86/cet-control.h
+rename to sysdeps/x86/feature-control.h
+index 403d00120e..e0664cb777 100644
+--- a/sysdeps/x86/cet-control.h
++++ b/sysdeps/x86/feature-control.h
+@@ -1,4 +1,4 @@
+-/* x86 CET tuning.
++/* x86 feature tuning.
+    This file is part of the GNU C Library.
+    Copyright (C) 2018-2021 Free Software Foundation, Inc.
+ 
+@@ -16,8 +16,8 @@
+    License along with the GNU C Library; if not, see
+    <https://www.gnu.org/licenses/>.  */
+ 
+-#ifndef _CET_CONTROL_H
+-#define _CET_CONTROL_H
++#ifndef _FEATURE_CONTROL_H
++#define _FEATURE_CONTROL_H
+ 
+ /* For each x86 feature, IBT and SHSTK, valid control values.  */
+ enum dl_x86_feature_control_enum
+@@ -39,4 +39,4 @@ struct dl_x86_feature_control
+   enum dl_x86_feature_control_enum lam : 2;
+ };
+ 
+-#endif /* cet-control.h */
++#endif /* feature-control.h */
+diff --git a/sysdeps/x86/ldsodefs.h b/sysdeps/x86/ldsodefs.h
+index b6abe6bdad..ff6b664411 100644
+--- a/sysdeps/x86/ldsodefs.h
++++ b/sysdeps/x86/ldsodefs.h
+@@ -61,7 +61,7 @@ struct La_x32_retval;
+ 				     struct La_x86_64_retval *,		\
+ 				     const char *)
+ 
+-#include <cet-control.h>
++#include <feature-control.h>
+ #include_next <ldsodefs.h>
+ 
+ #endif
+diff --git a/sysdeps/x86/sysdep.h b/sysdeps/x86/sysdep.h
+index 51c069bfe1..500c0b5b1b 100644
+--- a/sysdeps/x86/sysdep.h
++++ b/sysdeps/x86/sysdep.h
+@@ -48,6 +48,8 @@ enum cf_protection_level
+ # define SHSTK_ENABLED	0
+ #endif
+ 
++#define X86_FEATURE_ENABLED (CET_ENABLED | LAM_ENABLED)
++
+ /* Offset for fxsave/xsave area used by _dl_runtime_resolve.  Also need
+    space to preserve RCX, RDX, RSI, RDI, R8, R9 and RAX.  It must be
+    aligned to 16 bytes for fxsave and 64 bytes for xsave.  */
+-- 
+2.31.1
+
diff --git a/0014-x86-Update-prctl.h-to-support-both-CET-and-LAM.patch b/0014-x86-Update-prctl.h-to-support-both-CET-and-LAM.patch
new file mode 100644
index 0000000..8850884
--- /dev/null
+++ b/0014-x86-Update-prctl.h-to-support-both-CET-and-LAM.patch
@@ -0,0 +1,286 @@
+From e23e65173c0bfbb1550b0526f3c3e30cd3913a4d Mon Sep 17 00:00:00 2001
+From: Sunil K Pandey <skpgkp2@gmail.com>
+Date: Sat, 9 Jan 2021 18:21:41 -0800
+Subject: [PATCH 14/24] x86: Update prctl.h to support both CET and LAM
+
+Rename CET functions/variables and add ARCH_X86_FEATURE_1_ENABLE so that
+they can be used for both CET and LAM features.
+---
+ sysdeps/unix/sysv/linux/i386/getcontext.S     |  2 +-
+ sysdeps/unix/sysv/linux/i386/swapcontext.S    |  2 +-
+ sysdeps/unix/sysv/linux/x86/cpu-features.c    | 10 +++----
+ sysdeps/unix/sysv/linux/x86/dl-feature.h      | 12 ++++----
+ .../unix/sysv/linux/x86/include/asm/prctl.h   | 15 ++++++----
+ sysdeps/unix/sysv/linux/x86_64/getcontext.S   |  2 +-
+ sysdeps/unix/sysv/linux/x86_64/swapcontext.S  |  2 +-
+ sysdeps/x86/cpu-features.c                    | 30 +++++++++----------
+ sysdeps/x86/dl-feature.c                      | 20 ++++++-------
+ 9 files changed, 50 insertions(+), 45 deletions(-)
+
+diff --git a/sysdeps/unix/sysv/linux/i386/getcontext.S b/sysdeps/unix/sysv/linux/i386/getcontext.S
+index 61c0195b33..efe42ac61d 100644
+--- a/sysdeps/unix/sysv/linux/i386/getcontext.S
++++ b/sysdeps/unix/sysv/linux/i386/getcontext.S
+@@ -63,7 +63,7 @@ ENTRY(__getcontext)
+ 	   been recorded yet.  */
+ 	sub	$24, %esp
+ 	mov	%esp, %ecx
+-	movl	$ARCH_X86_CET_STATUS, %ebx
++	movl	$ARCH_X86_FEATURE_1_STATUS, %ebx
+ 	movl	$__NR_arch_prctl, %eax
+ 	ENTER_KERNEL
+ 	testl	%eax, %eax
+diff --git a/sysdeps/unix/sysv/linux/i386/swapcontext.S b/sysdeps/unix/sysv/linux/i386/swapcontext.S
+index e9111d5d19..05eddd884d 100644
+--- a/sysdeps/unix/sysv/linux/i386/swapcontext.S
++++ b/sysdeps/unix/sysv/linux/i386/swapcontext.S
+@@ -91,7 +91,7 @@ ENTRY(__swapcontext)
+ 	   been recorded yet.  */
+ 	sub	$24, %esp
+ 	mov	%esp, %ecx
+-	movl	$ARCH_X86_CET_STATUS, %ebx
++	movl	$ARCH_X86_FEATURE_1_STATUS, %ebx
+ 	movl	$__NR_arch_prctl, %eax
+ 	ENTER_KERNEL
+ 	testl	%eax, %eax
+diff --git a/sysdeps/unix/sysv/linux/x86/cpu-features.c b/sysdeps/unix/sysv/linux/x86/cpu-features.c
+index 775c4c3ac4..5a170bc134 100644
+--- a/sysdeps/unix/sysv/linux/x86/cpu-features.c
++++ b/sysdeps/unix/sysv/linux/x86/cpu-features.c
+@@ -21,12 +21,12 @@
+ # include <asm/prctl.h>
+ 
+ static inline int __attribute__ ((always_inline))
+-get_cet_status (void)
++get_feature_1_status (void)
+ {
+-  unsigned long long cet_status[3];
+-  if (INTERNAL_SYSCALL_CALL (arch_prctl, ARCH_X86_CET_STATUS,
+-			     cet_status) == 0)
+-    return cet_status[0];
++  unsigned long long feature_1_status[3];
++  if (INTERNAL_SYSCALL_CALL (arch_prctl, ARCH_X86_FEATURE_1_STATUS,
++			     feature_1_status) == 0)
++    return feature_1_status[0];
+   return 0;
+ }
+ 
+diff --git a/sysdeps/unix/sysv/linux/x86/dl-feature.h b/sysdeps/unix/sysv/linux/x86/dl-feature.h
+index d1cd35de43..6ee5d84486 100644
+--- a/sysdeps/unix/sysv/linux/x86/dl-feature.h
++++ b/sysdeps/unix/sysv/linux/x86/dl-feature.h
+@@ -19,14 +19,16 @@
+ #include <asm/prctl.h>
+ 
+ static inline int __attribute__ ((always_inline))
+-dl_cet_disable_cet (unsigned int cet_feature)
++dl_feature_1_disable (unsigned int feature_1)
+ {
+-  return (int) INTERNAL_SYSCALL_CALL (arch_prctl, ARCH_X86_CET_DISABLE,
+-				      cet_feature);
++  return (int) INTERNAL_SYSCALL_CALL (arch_prctl,
++				      ARCH_X86_FEATURE_1_DISABLE,
++				      feature_1);
+ }
+ 
+ static inline int __attribute__ ((always_inline))
+-dl_cet_lock_cet (void)
++dl_cet_lock (void)
+ {
+-  return (int) INTERNAL_SYSCALL_CALL (arch_prctl, ARCH_X86_CET_LOCK, 0);
++  return (int) INTERNAL_SYSCALL_CALL (arch_prctl,
++				      ARCH_X86_CET_1_LOCK, 0);
+ }
+diff --git a/sysdeps/unix/sysv/linux/x86/include/asm/prctl.h b/sysdeps/unix/sysv/linux/x86/include/asm/prctl.h
+index d58754018b..f3c65b00ce 100644
+--- a/sysdeps/unix/sysv/linux/x86/include/asm/prctl.h
++++ b/sysdeps/unix/sysv/linux/x86/include/asm/prctl.h
+@@ -4,7 +4,7 @@
+ 
+ #include_next <asm/prctl.h>
+ 
+-#ifndef ARCH_X86_CET_STATUS
++#ifndef ARCH_X86_FEATURE_1_STATUS
+ /* CET features:
+    IBT:   GNU_PROPERTY_X86_FEATURE_1_IBT
+    SHSTK: GNU_PROPERTY_X86_FEATURE_1_SHSTK
+@@ -14,9 +14,12 @@
+      shadow stack base address: addr[1].
+      shadow stack size: addr[2].
+  */
+-# define ARCH_X86_CET_STATUS	0x3001
+-/* Disable CET features in unsigned int features.  */
+-# define ARCH_X86_CET_DISABLE	0x3002
++# define ARCH_X86_FEATURE_1_STATUS	0x3001
++/* Disable FEATURE_1 features in unsigned int features.  */
++# define ARCH_X86_FEATURE_1_DISABLE	0x3002
+ /* Lock all CET features.  */
+-# define ARCH_X86_CET_LOCK		0x3003
+-#endif /* ARCH_X86_CET_STATUS */
++# define ARCH_X86_CET_1_LOCK		0x3003
++/* Enable FEATURE_1 features in unsigned int features.  */
++# define ARCH_X86_FEATURE_1_ENABLE	0x3004
++
++#endif /* ARCH_X86_FEATURE_1_STATUS */
+diff --git a/sysdeps/unix/sysv/linux/x86_64/getcontext.S b/sysdeps/unix/sysv/linux/x86_64/getcontext.S
+index aee363b000..e28be78a8c 100644
+--- a/sysdeps/unix/sysv/linux/x86_64/getcontext.S
++++ b/sysdeps/unix/sysv/linux/x86_64/getcontext.S
+@@ -71,7 +71,7 @@ ENTRY(__getcontext)
+ 	   been recorded yet.  */
+ 	sub	$24, %RSP_LP
+ 	mov	%RSP_LP, %RSI_LP
+-	movl	$ARCH_X86_CET_STATUS, %edi
++	movl	$ARCH_X86_FEATURE_1_STATUS, %edi
+ 	movl	$__NR_arch_prctl, %eax
+ 	syscall
+ 	testq	%rax, %rax
+diff --git a/sysdeps/unix/sysv/linux/x86_64/swapcontext.S b/sysdeps/unix/sysv/linux/x86_64/swapcontext.S
+index 16648a6080..475f6ab13e 100644
+--- a/sysdeps/unix/sysv/linux/x86_64/swapcontext.S
++++ b/sysdeps/unix/sysv/linux/x86_64/swapcontext.S
+@@ -115,7 +115,7 @@ ENTRY(__swapcontext)
+ 	   been recorded yet.  */
+ 	sub	$24, %RSP_LP
+ 	mov	%RSP_LP, %RSI_LP
+-	movl	$ARCH_X86_CET_STATUS, %edi
++	movl	$ARCH_X86_FEATURE_1_STATUS, %edi
+ 	movl	$__NR_arch_prctl, %eax
+ 	syscall
+ 	testq	%rax, %rax
+diff --git a/sysdeps/x86/cpu-features.c b/sysdeps/x86/cpu-features.c
+index 8c214e2fab..a668adea72 100644
+--- a/sysdeps/x86/cpu-features.c
++++ b/sysdeps/x86/cpu-features.c
+@@ -720,48 +720,48 @@ no_cpuid:
+ 	       TUNABLE_CALLBACK (set_x86_shstk));
+ # endif
+ 
+-  /* Check CET status.  */
+-  unsigned int cet_status = get_cet_status ();
++  /* Check feature_1 status.  */
++  unsigned int feature_1_status = get_feature_1_status ();
+ 
+-  if ((cet_status & GNU_PROPERTY_X86_FEATURE_1_IBT) == 0)
++  if ((feature_1_status & GNU_PROPERTY_X86_FEATURE_1_IBT) == 0)
+     CPU_FEATURE_UNSET (cpu_features, IBT)
+-  if ((cet_status & GNU_PROPERTY_X86_FEATURE_1_SHSTK) == 0)
++  if ((feature_1_status & GNU_PROPERTY_X86_FEATURE_1_SHSTK) == 0)
+     CPU_FEATURE_UNSET (cpu_features, SHSTK)
+ 
+-  if (cet_status)
++  if (feature_1_status)
+     {
+-      GL(dl_x86_feature_1) = cet_status;
++      GL(dl_x86_feature_1) = feature_1_status;
+ 
+ # ifndef SHARED
+       /* Check if IBT and SHSTK are enabled by kernel.  */
+-      if ((cet_status & GNU_PROPERTY_X86_FEATURE_1_IBT)
+-	  || (cet_status & GNU_PROPERTY_X86_FEATURE_1_SHSTK))
++      if ((feature_1_status & GNU_PROPERTY_X86_FEATURE_1_IBT)
++	  || (feature_1_status & GNU_PROPERTY_X86_FEATURE_1_SHSTK))
+ 	{
+ 	  /* Disable IBT and/or SHSTK if they are enabled by kernel, but
+ 	     disabled by environment variable:
+ 
+ 	     GLIBC_TUNABLES=glibc.cpu.hwcaps=-IBT,-SHSTK
+ 	   */
+-	  unsigned int cet_feature = 0;
++	  unsigned int feature_1 = 0;
+ 	  if (!CPU_FEATURE_USABLE (IBT))
+-	    cet_feature |= GNU_PROPERTY_X86_FEATURE_1_IBT;
++	    feature_1 |= GNU_PROPERTY_X86_FEATURE_1_IBT;
+ 	  if (!CPU_FEATURE_USABLE (SHSTK))
+-	    cet_feature |= GNU_PROPERTY_X86_FEATURE_1_SHSTK;
++	    feature_1 |= GNU_PROPERTY_X86_FEATURE_1_SHSTK;
+ 
+-	  if (cet_feature)
++	  if (feature_1)
+ 	    {
+-	      int res = dl_cet_disable_cet (cet_feature);
++	      int res = dl_feature_1_disable (feature_1);
+ 
+ 	      /* Clear the disabled bits in dl_x86_feature_1.  */
+ 	      if (res == 0)
+-		GL(dl_x86_feature_1) &= ~cet_feature;
++		GL(dl_x86_feature_1) &= ~feature_1;
+ 	    }
+ 
+ 	  /* Lock CET if IBT or SHSTK is enabled in executable.  Don't
+ 	     lock CET if IBT or SHSTK is enabled permissively.  */
+ 	  if (GL(dl_x86_feature_control).ibt != x86_feature_permissive
+ 	      && GL(dl_x86_feature_control).shstk != x86_feature_permissive)
+-	    dl_cet_lock_cet ();
++	    dl_cet_lock ();
+ 	}
+ # endif
+     }
+diff --git a/sysdeps/x86/dl-feature.c b/sysdeps/x86/dl-feature.c
+index a2774718cc..7ff7b614f0 100644
+--- a/sysdeps/x86/dl-feature.c
++++ b/sysdeps/x86/dl-feature.c
+@@ -137,7 +137,7 @@ dl_feature_check (struct link_map *m, const char *program)
+ 	    }
+ 	}
+ 
+-      bool cet_feature_changed = false;
++      bool feature_1_changed = false;
+ 
+       if (enable_ibt != ibt_enabled || enable_shstk != shstk_enabled)
+ 	{
+@@ -172,14 +172,14 @@ dl_feature_check (struct link_map *m, const char *program)
+ 
+ 	  /* Disable IBT and/or SHSTK if they are enabled by kernel, but
+ 	     disabled in executable or shared objects.  */
+-	  unsigned int cet_feature = 0;
++	  unsigned int feature_1 = 0;
+ 
+ 	  if (!enable_ibt)
+-	    cet_feature |= GNU_PROPERTY_X86_FEATURE_1_IBT;
++	    feature_1 |= GNU_PROPERTY_X86_FEATURE_1_IBT;
+ 	  if (!enable_shstk)
+-	    cet_feature |= GNU_PROPERTY_X86_FEATURE_1_SHSTK;
++	    feature_1 |= GNU_PROPERTY_X86_FEATURE_1_SHSTK;
+ 
+-	  int res = dl_cet_disable_cet (cet_feature);
++	  int res = dl_feature_1_disable (feature_1);
+ 	  if (res != 0)
+ 	    {
+ 	      if (program)
+@@ -196,9 +196,9 @@ dl_feature_check (struct link_map *m, const char *program)
+ 	    }
+ 
+ 	  /* Clear the disabled bits in dl_x86_feature_1.  */
+-	  GL(dl_x86_feature_1) &= ~cet_feature;
++	  GL(dl_x86_feature_1) &= ~feature_1;
+ 
+-	  cet_feature_changed = true;
++	  feature_1_changed = true;
+ 	}
+ 
+ #ifdef SHARED
+@@ -211,17 +211,17 @@ dl_feature_check (struct link_map *m, const char *program)
+ 	    {
+ 	      /* Lock CET if IBT or SHSTK is enabled in executable unless
+ 	         IBT or SHSTK is enabled permissively.  */
+-	      int res = dl_cet_lock_cet ();
++	      int res = dl_cet_lock ();
+ 	      if (res != 0)
+ 		_dl_fatal_printf ("%s: can't lock CET\n", program);
+ 	    }
+ 
+ 	  /* Set feature_1 if IBT or SHSTK is enabled in executable.  */
+-	  cet_feature_changed = true;
++	  feature_1_changed = true;
+ 	}
+ #endif
+ 
+-      if (cet_feature_changed)
++      if (feature_1_changed)
+ 	{
+ 	  unsigned int feature_1 = 0;
+ 	  if (enable_ibt)
+-- 
+2.31.1
+
diff --git a/0015-x86-Update-feature-control-and-tunables-for-LAM.patch b/0015-x86-Update-feature-control-and-tunables-for-LAM.patch
new file mode 100644
index 0000000..52b12f2
--- /dev/null
+++ b/0015-x86-Update-feature-control-and-tunables-for-LAM.patch
@@ -0,0 +1,147 @@
+From 37678ea2e9e2c113d0756b2187fe67889db72fa1 Mon Sep 17 00:00:00 2001
+From: Sunil K Pandey <skpgkp2@gmail.com>
+Date: Tue, 12 Jan 2021 10:52:01 -0800
+Subject: [PATCH 15/24] x86: Update feature control and tunables for LAM
+
+1. Add LAM tunables and update feature control for LAM.
+2. Support
+
+$ export GLIBC_TUNABLES=glibc.cpu.x86_64_already=lam_u57
+
+or
+
+$ export GLIBC_TUNABLES=glibc.cpu.x86_64_already=lam_u48
+
+to indicate that LAM_U57/LAM_U48 is already enabled.
+---
+ sysdeps/x86/cpu-tunables.c    | 55 +++++++++++++++++++++++++++++++++++
+ sysdeps/x86/dl-tunables.list  |  9 ++++++
+ sysdeps/x86/feature-control.h | 15 +++++++++-
+ 3 files changed, 78 insertions(+), 1 deletion(-)
+
+diff --git a/sysdeps/x86/cpu-tunables.c b/sysdeps/x86/cpu-tunables.c
+index 402ed4c32d..6f7a9c3b69 100644
+--- a/sysdeps/x86/cpu-tunables.c
++++ b/sysdeps/x86/cpu-tunables.c
+@@ -320,5 +320,60 @@ TUNABLE_CALLBACK (set_x86_shstk) (tunable_val_t *valp)
+ 			   sizeof ("permissive")) == 0)
+     GL(dl_x86_feature_control).shstk = x86_feature_permissive;
+ }
++
++attribute_hidden
++void
++TUNABLE_CALLBACK (set_x86_64_lam) (tunable_val_t *valp)
++{
++  if (DEFAULT_MEMCMP (valp->strval, "on", sizeof ("on")) == 0)
++    GL(dl_x86_feature_control).lam = x86_feature_always_on;
++  else if (DEFAULT_MEMCMP (valp->strval, "off", sizeof ("off")) == 0)
++    GL(dl_x86_feature_control).lam = x86_feature_always_off;
++  else if (DEFAULT_MEMCMP (valp->strval, "permissive",
++			   sizeof ("permissive")) == 0)
++    GL(dl_x86_feature_control).lam = x86_feature_permissive;
++}
++
++attribute_hidden
++void
++TUNABLE_CALLBACK (set_x86_64_lam_size) (tunable_val_t *valp)
++{
++  if (DEFAULT_MEMCMP (valp->strval, "48", sizeof ("48")) == 0)
++    GL(dl_x86_feature_control).lam_size = lam_u48;
++  else if (DEFAULT_MEMCMP (valp->strval, "57", sizeof ("57")) == 0)
++    GL(dl_x86_feature_control).lam_size = lam_u57;
++}
++
++attribute_hidden
++void
++TUNABLE_CALLBACK (set_x86_64_already) (tunable_val_t *valp)
++{
++  const char *p = valp->strval;
++  size_t len;
++
++  do
++    {
++      const char *c;
++      for (c = p; *c != ','; c++)
++	if (*c == '\0')
++	  break;
++
++      len = c - p;
++      if (DEFAULT_MEMCMP (p, "lam_u48", len) == 0)
++	{
++	  GL(dl_x86_feature_control).lam_already = 1;
++	  GL(dl_x86_feature_control).lam_size = lam_u48;
++	  GL(dl_x86_feature_control).lam = x86_feature_always_on;
++	}
++      else if (DEFAULT_MEMCMP (p, "lam_u57", len) == 0)
++	{
++	  GL(dl_x86_feature_control).lam_already = 1;
++	  GL(dl_x86_feature_control).lam_size = lam_u57;
++	  GL(dl_x86_feature_control).lam = x86_feature_always_on;
++	}
++      p = c + 1;
++    }
++  while (*p != '\0');
++}
+ # endif
+ #endif
+diff --git a/sysdeps/x86/dl-tunables.list b/sysdeps/x86/dl-tunables.list
+index dd6e1d65c9..7b7c90496f 100644
+--- a/sysdeps/x86/dl-tunables.list
++++ b/sysdeps/x86/dl-tunables.list
+@@ -27,6 +27,15 @@ glibc {
+     x86_shstk {
+       type: STRING
+     }
++    x86_64_lam {
++      type: STRING
++    }
++    x86_64_lam_size {
++      type: STRING
++    }
++    x86_64_already {
++      type: STRING
++    }
+     x86_non_temporal_threshold {
+       type: SIZE_T
+     }
+diff --git a/sysdeps/x86/feature-control.h b/sysdeps/x86/feature-control.h
+index e0664cb777..000bca0597 100644
+--- a/sysdeps/x86/feature-control.h
++++ b/sysdeps/x86/feature-control.h
+@@ -19,7 +19,7 @@
+ #ifndef _FEATURE_CONTROL_H
+ #define _FEATURE_CONTROL_H
+ 
+-/* For each x86 feature, IBT and SHSTK, valid control values.  */
++/* For each x86 feature, IBT, SHSTK and LAM, valid control values.  */
+ enum dl_x86_feature_control_enum
+ {
+   /* Enable features based on ELF property note.  */
+@@ -32,11 +32,24 @@ enum dl_x86_feature_control_enum
+   x86_feature_permissive
+ };
+ 
++/* Valid LAM size: 48 or 57 */
++enum dl_x86_64_lam_size_enum
++{
++  /* Default LAM size.  */
++  lam_default = 0,
++  /* LAM_U48 is enabled.  */
++  lam_u48,
++  /* LAM_U57 is enabled.  */
++  lam_u57
++};
++
+ struct dl_x86_feature_control
+ {
+   enum dl_x86_feature_control_enum ibt : 2;
+   enum dl_x86_feature_control_enum shstk : 2;
+   enum dl_x86_feature_control_enum lam : 2;
++  enum dl_x86_64_lam_size_enum lam_size : 2;
++  unsigned int lam_already : 1;
+ };
+ 
+ #endif /* feature-control.h */
+-- 
+2.31.1
+
diff --git a/0016-x86-Update-feature-disable-for-LAM.patch b/0016-x86-Update-feature-disable-for-LAM.patch
new file mode 100644
index 0000000..dda65f4
--- /dev/null
+++ b/0016-x86-Update-feature-disable-for-LAM.patch
@@ -0,0 +1,118 @@
+From 2d42aadcbe84175cf412586f70b291f357bfb5a5 Mon Sep 17 00:00:00 2001
+From: Sunil K Pandey <skpgkp2@gmail.com>
+Date: Wed, 13 Jan 2021 13:28:37 -0800
+Subject: [PATCH 16/24] x86: Update feature disable for LAM
+
+Update feature disable for LAM.
+---
+ sysdeps/x86/cpu-features.c | 42 ++++++++++++++++++++++++++++++--------
+ sysdeps/x86/sysdep.h       |  8 ++++++++
+ 2 files changed, 42 insertions(+), 8 deletions(-)
+
+diff --git a/sysdeps/x86/cpu-features.c b/sysdeps/x86/cpu-features.c
+index a668adea72..55bb9e1cbf 100644
+--- a/sysdeps/x86/cpu-features.c
++++ b/sysdeps/x86/cpu-features.c
+@@ -26,11 +26,20 @@
+ extern void TUNABLE_CALLBACK (set_hwcaps) (tunable_val_t *)
+   attribute_hidden;
+ 
+-# if CET_ENABLED
++# if X86_FEATURE_ENABLED
+ extern void TUNABLE_CALLBACK (set_x86_ibt) (tunable_val_t *)
+   attribute_hidden;
+ extern void TUNABLE_CALLBACK (set_x86_shstk) (tunable_val_t *)
+   attribute_hidden;
++
++#  if LAM_ENABLED
++extern void TUNABLE_CALLBACK (set_x86_64_lam) (tunable_val_t *)
++  attribute_hidden;
++extern void TUNABLE_CALLBACK (set_x86_64_lam_size) (tunable_val_t *)
++  attribute_hidden;
++extern void TUNABLE_CALLBACK (set_x86_64_already) (tunable_val_t *)
++  attribute_hidden;
++#  endif
+ # endif
+ #endif
+ 
+@@ -96,6 +105,7 @@ update_usable (struct cpu_features *cpu_features)
+   CPU_FEATURE_SET_USABLE (cpu_features, FZLRM);
+   CPU_FEATURE_SET_USABLE (cpu_features, FSRS);
+   CPU_FEATURE_SET_USABLE (cpu_features, FSRCS);
++  CPU_FEATURE_SET_USABLE (cpu_features, LAM);
+ 
+   /* Can we call xgetbv?  */
+   if (CPU_FEATURES_CPU_P (cpu_features, OSXSAVE))
+@@ -718,6 +728,15 @@ no_cpuid:
+ 	       TUNABLE_CALLBACK (set_x86_ibt));
+   TUNABLE_GET (x86_shstk, tunable_val_t *,
+ 	       TUNABLE_CALLBACK (set_x86_shstk));
++
++#  if LAM_ENABLED
++  TUNABLE_GET (x86_64_lam, tunable_val_t *,
++	       TUNABLE_CALLBACK (set_x86_64_lam));
++  TUNABLE_GET (x86_64_lam_size, tunable_val_t *,
++	       TUNABLE_CALLBACK (set_x86_64_lam_size));
++  TUNABLE_GET (x86_64_already, tunable_val_t *,
++	       TUNABLE_CALLBACK (set_x86_64_already));
++#  endif
+ # endif
+ 
+   /* Check feature_1 status.  */
+@@ -733,20 +752,27 @@ no_cpuid:
+       GL(dl_x86_feature_1) = feature_1_status;
+ 
+ # ifndef SHARED
+-      /* Check if IBT and SHSTK are enabled by kernel.  */
+-      if ((feature_1_status & GNU_PROPERTY_X86_FEATURE_1_IBT)
+-	  || (feature_1_status & GNU_PROPERTY_X86_FEATURE_1_SHSTK))
++      /* Check if features are enabled by kernel.  */
++      if ((feature_1_status
++	   & GNU_PROPERTY_X86_FEATURE_1_MASK) != 0)
+ 	{
+-	  /* Disable IBT and/or SHSTK if they are enabled by kernel, but
++	  /* Disable features if they are enabled by kernel, but
+ 	     disabled by environment variable:
+ 
+-	     GLIBC_TUNABLES=glibc.cpu.hwcaps=-IBT,-SHSTK
++	     GLIBC_TUNABLES=glibc.cpu.hwcaps=-IBT,-SHSTK,-LAM
+ 	   */
+ 	  unsigned int feature_1 = 0;
+ 	  if (!CPU_FEATURE_USABLE (IBT))
+-	    feature_1 |= GNU_PROPERTY_X86_FEATURE_1_IBT;
++	    feature_1 |= (feature_1_status
++			  & GNU_PROPERTY_X86_FEATURE_1_IBT);
+ 	  if (!CPU_FEATURE_USABLE (SHSTK))
+-	    feature_1 |= GNU_PROPERTY_X86_FEATURE_1_SHSTK;
++	    feature_1 |= (feature_1_status
++			  & GNU_PROPERTY_X86_FEATURE_1_SHSTK);
++#  if LAM_ENABLED
++	  if (!CPU_FEATURE_USABLE (LAM))
++	    feature_1 |= (feature_1_status
++			  & GNU_PROPERTY_X86_FEATURE_1_LAM_MASK);
++#  endif
+ 
+ 	  if (feature_1)
+ 	    {
+diff --git a/sysdeps/x86/sysdep.h b/sysdeps/x86/sysdep.h
+index 500c0b5b1b..886486e469 100644
+--- a/sysdeps/x86/sysdep.h
++++ b/sysdeps/x86/sysdep.h
+@@ -50,6 +50,14 @@ enum cf_protection_level
+ 
+ #define X86_FEATURE_ENABLED (CET_ENABLED | LAM_ENABLED)
+ 
++#define GNU_PROPERTY_X86_FEATURE_1_LAM_MASK \
++  (GNU_PROPERTY_X86_FEATURE_1_LAM_U48 \
++   | GNU_PROPERTY_X86_FEATURE_1_LAM_U57)
++#define GNU_PROPERTY_X86_FEATURE_1_MASK \
++  (GNU_PROPERTY_X86_FEATURE_1_IBT \
++   | GNU_PROPERTY_X86_FEATURE_1_SHSTK \
++   | GNU_PROPERTY_X86_FEATURE_1_LAM_MASK)
++
+ /* Offset for fxsave/xsave area used by _dl_runtime_resolve.  Also need
+    space to preserve RCX, RDX, RSI, RDI, R8, R9 and RAX.  It must be
+    aligned to 16 bytes for fxsave and 64 bytes for xsave.  */
+-- 
+2.31.1
+
diff --git a/0017-Disable-LAM-incompatible-string-functions-at-run-tim.patch b/0017-Disable-LAM-incompatible-string-functions-at-run-tim.patch
new file mode 100644
index 0000000..17325fc
--- /dev/null
+++ b/0017-Disable-LAM-incompatible-string-functions-at-run-tim.patch
@@ -0,0 +1,239 @@
+From 481f1b42855d6b24e0ae6b2c20662641bb519f15 Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Sat, 9 Jan 2021 09:11:00 -0800
+Subject: [PATCH 17/24] Disable LAM-incompatible string functions at run-time
+
+1. Add X86_FEATURE_1, LAM_U48_ENABLED_P, LAM_U57_ENABLED_P and
+LAM_ENABLED_P.
+2. Disable ssse3/ssse3-back/avx512-no-vzeroupper memcpy, memmove and
+memcpy for LAM at run-time.
+---
+ sysdeps/x86/sysdep.h                       |  4 ++
+ sysdeps/x86_64/multiarch/ifunc-impl-list.c | 60 +++++++++++++++-------
+ sysdeps/x86_64/multiarch/ifunc-memmove.h   |  6 ++-
+ sysdeps/x86_64/sysdep.h                    | 18 +++++++
+ 4 files changed, 68 insertions(+), 20 deletions(-)
+
+diff --git a/sysdeps/x86/sysdep.h b/sysdeps/x86/sysdep.h
+index 886486e469..5f9b90f655 100644
+--- a/sysdeps/x86/sysdep.h
++++ b/sysdeps/x86/sysdep.h
+@@ -118,6 +118,10 @@ enum cf_protection_level
+ 
+ #define atom_text_section .section ".text.atom", "ax"
+ 
++#else	/* __ASSEMBLER__ */
++
++#define X86_FEATURE_1() THREAD_GETMEM (THREAD_SELF, header.feature_1)
++
+ #endif	/* __ASSEMBLER__ */
+ 
+ #endif	/* _X86_SYSDEP_H */
+diff --git a/sysdeps/x86_64/multiarch/ifunc-impl-list.c b/sysdeps/x86_64/multiarch/ifunc-impl-list.c
+index 15eda47667..4e1e81ceff 100644
+--- a/sysdeps/x86_64/multiarch/ifunc-impl-list.c
++++ b/sysdeps/x86_64/multiarch/ifunc-impl-list.c
+@@ -88,7 +88,8 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
+   /* Support sysdeps/x86_64/multiarch/memmove_chk.c.  */
+   IFUNC_IMPL (i, name, __memmove_chk,
+ 	      IFUNC_IMPL_ADD (array, i, __memmove_chk,
+-			      CPU_FEATURE_USABLE (AVX512F),
++			      (!LAM_ENABLED_P ()
++			       && CPU_FEATURE_USABLE (AVX512F)),
+ 			      __memmove_chk_avx512_no_vzeroupper)
+ 	      IFUNC_IMPL_ADD (array, i, __memmove_chk,
+ 			      CPU_FEATURE_USABLE (AVX512VL),
+@@ -117,10 +118,12 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
+ 			      CPU_FEATURE_USABLE (AVX512VL),
+ 			      __memmove_chk_evex_unaligned_erms)
+ 	      IFUNC_IMPL_ADD (array, i, __memmove_chk,
+-			      CPU_FEATURE_USABLE (SSSE3),
++			      (!LAM_ENABLED_P ()
++			       && CPU_FEATURE_USABLE (SSSE3)),
+ 			      __memmove_chk_ssse3_back)
+ 	      IFUNC_IMPL_ADD (array, i, __memmove_chk,
+-			      CPU_FEATURE_USABLE (SSSE3),
++			      (!LAM_ENABLED_P ()
++			       && CPU_FEATURE_USABLE (SSSE3)),
+ 			      __memmove_chk_ssse3)
+ 	      IFUNC_IMPL_ADD (array, i, __memmove_chk, 1,
+ 			      __memmove_chk_sse2_unaligned)
+@@ -153,7 +156,8 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
+ 			      CPU_FEATURE_USABLE (AVX512VL),
+ 			      __memmove_evex_unaligned_erms)
+ 	      IFUNC_IMPL_ADD (array, i, memmove,
+-			      CPU_FEATURE_USABLE (AVX512F),
++			      (!LAM_ENABLED_P ()
++			       && CPU_FEATURE_USABLE (AVX512F)),
+ 			      __memmove_avx512_no_vzeroupper)
+ 	      IFUNC_IMPL_ADD (array, i, memmove,
+ 			      CPU_FEATURE_USABLE (AVX512VL),
+@@ -161,9 +165,13 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
+ 	      IFUNC_IMPL_ADD (array, i, memmove,
+ 			      CPU_FEATURE_USABLE (AVX512VL),
+ 			      __memmove_avx512_unaligned_erms)
+-	      IFUNC_IMPL_ADD (array, i, memmove, CPU_FEATURE_USABLE (SSSE3),
++	      IFUNC_IMPL_ADD (array, i, memmove,
++			      (!LAM_ENABLED_P ()
++			       && CPU_FEATURE_USABLE (SSSE3)),
+ 			      __memmove_ssse3_back)
+-	      IFUNC_IMPL_ADD (array, i, memmove, CPU_FEATURE_USABLE (SSSE3),
++	      IFUNC_IMPL_ADD (array, i, memmove,
++			      (!LAM_ENABLED_P ()
++			       && CPU_FEATURE_USABLE (SSSE3)),
+ 			      __memmove_ssse3)
+ 	      IFUNC_IMPL_ADD (array, i, memmove, 1, __memmove_erms)
+ 	      IFUNC_IMPL_ADD (array, i, memmove, 1,
+@@ -779,7 +787,8 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
+   /* Support sysdeps/x86_64/multiarch/memcpy_chk.c.  */
+   IFUNC_IMPL (i, name, __memcpy_chk,
+ 	      IFUNC_IMPL_ADD (array, i, __memcpy_chk,
+-			      CPU_FEATURE_USABLE (AVX512F),
++			      (!LAM_ENABLED_P ()
++			       && CPU_FEATURE_USABLE (AVX512F)),
+ 			      __memcpy_chk_avx512_no_vzeroupper)
+ 	      IFUNC_IMPL_ADD (array, i, __memcpy_chk,
+ 			      CPU_FEATURE_USABLE (AVX512VL),
+@@ -808,10 +817,12 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
+ 			      CPU_FEATURE_USABLE (AVX512VL),
+ 			      __memcpy_chk_evex_unaligned_erms)
+ 	      IFUNC_IMPL_ADD (array, i, __memcpy_chk,
+-			      CPU_FEATURE_USABLE (SSSE3),
++			      (!LAM_ENABLED_P ()
++			       && CPU_FEATURE_USABLE (SSSE3)),
+ 			      __memcpy_chk_ssse3_back)
+ 	      IFUNC_IMPL_ADD (array, i, __memcpy_chk,
+-			      CPU_FEATURE_USABLE (SSSE3),
++			      (!LAM_ENABLED_P ()
++			       && CPU_FEATURE_USABLE (SSSE3)),
+ 			      __memcpy_chk_ssse3)
+ 	      IFUNC_IMPL_ADD (array, i, __memcpy_chk, 1,
+ 			      __memcpy_chk_sse2_unaligned)
+@@ -843,12 +854,17 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
+ 	      IFUNC_IMPL_ADD (array, i, memcpy,
+ 			      CPU_FEATURE_USABLE (AVX512VL),
+ 			      __memcpy_evex_unaligned_erms)
+-	      IFUNC_IMPL_ADD (array, i, memcpy, CPU_FEATURE_USABLE (SSSE3),
++	      IFUNC_IMPL_ADD (array, i, memcpy,
++			      (!LAM_ENABLED_P ()
++			       && CPU_FEATURE_USABLE (SSSE3)),
+ 			      __memcpy_ssse3_back)
+-	      IFUNC_IMPL_ADD (array, i, memcpy, CPU_FEATURE_USABLE (SSSE3),
++	      IFUNC_IMPL_ADD (array, i, memcpy,
++			      (!LAM_ENABLED_P ()
++			       && CPU_FEATURE_USABLE (SSSE3)),
+ 			      __memcpy_ssse3)
+ 	      IFUNC_IMPL_ADD (array, i, memcpy,
+-			      CPU_FEATURE_USABLE (AVX512F),
++			      (!LAM_ENABLED_P ()
++			       && CPU_FEATURE_USABLE (AVX512F)),
+ 			      __memcpy_avx512_no_vzeroupper)
+ 	      IFUNC_IMPL_ADD (array, i, memcpy,
+ 			      CPU_FEATURE_USABLE (AVX512VL),
+@@ -865,7 +881,8 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
+   /* Support sysdeps/x86_64/multiarch/mempcpy_chk.c.  */
+   IFUNC_IMPL (i, name, __mempcpy_chk,
+ 	      IFUNC_IMPL_ADD (array, i, __mempcpy_chk,
+-			      CPU_FEATURE_USABLE (AVX512F),
++			      (!LAM_ENABLED_P ()
++			       && CPU_FEATURE_USABLE (AVX512F)),
+ 			      __mempcpy_chk_avx512_no_vzeroupper)
+ 	      IFUNC_IMPL_ADD (array, i, __mempcpy_chk,
+ 			      CPU_FEATURE_USABLE (AVX512VL),
+@@ -894,10 +911,12 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
+ 			      CPU_FEATURE_USABLE (AVX512VL),
+ 			      __mempcpy_chk_evex_unaligned_erms)
+ 	      IFUNC_IMPL_ADD (array, i, __mempcpy_chk,
+-			      CPU_FEATURE_USABLE (SSSE3),
++			      (!LAM_ENABLED_P ()
++			       && CPU_FEATURE_USABLE (SSSE3)),
+ 			      __mempcpy_chk_ssse3_back)
+ 	      IFUNC_IMPL_ADD (array, i, __mempcpy_chk,
+-			      CPU_FEATURE_USABLE (SSSE3),
++			      (!LAM_ENABLED_P ()
++			       && CPU_FEATURE_USABLE (SSSE3)),
+ 			      __mempcpy_chk_ssse3)
+ 	      IFUNC_IMPL_ADD (array, i, __mempcpy_chk, 1,
+ 			      __mempcpy_chk_sse2_unaligned)
+@@ -910,7 +929,8 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
+   /* Support sysdeps/x86_64/multiarch/mempcpy.c.  */
+   IFUNC_IMPL (i, name, mempcpy,
+ 	      IFUNC_IMPL_ADD (array, i, mempcpy,
+-			      CPU_FEATURE_USABLE (AVX512F),
++			      (!LAM_ENABLED_P ()
++			       && CPU_FEATURE_USABLE (AVX512F)),
+ 			      __mempcpy_avx512_no_vzeroupper)
+ 	      IFUNC_IMPL_ADD (array, i, mempcpy,
+ 			      CPU_FEATURE_USABLE (AVX512VL),
+@@ -938,9 +958,13 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
+ 	      IFUNC_IMPL_ADD (array, i, mempcpy,
+ 			      CPU_FEATURE_USABLE (AVX512VL),
+ 			      __mempcpy_evex_unaligned_erms)
+-	      IFUNC_IMPL_ADD (array, i, mempcpy, CPU_FEATURE_USABLE (SSSE3),
++	      IFUNC_IMPL_ADD (array, i, mempcpy,
++			      (!LAM_ENABLED_P ()
++			       && CPU_FEATURE_USABLE (SSSE3)),
+ 			      __mempcpy_ssse3_back)
+-	      IFUNC_IMPL_ADD (array, i, mempcpy, CPU_FEATURE_USABLE (SSSE3),
++	      IFUNC_IMPL_ADD (array, i, mempcpy,
++			      (!LAM_ENABLED_P ()
++			       && CPU_FEATURE_USABLE (SSSE3)),
+ 			      __mempcpy_ssse3)
+ 	      IFUNC_IMPL_ADD (array, i, mempcpy, 1,
+ 			      __mempcpy_sse2_unaligned)
+diff --git a/sysdeps/x86_64/multiarch/ifunc-memmove.h b/sysdeps/x86_64/multiarch/ifunc-memmove.h
+index a14718a970..bb280d2da3 100644
+--- a/sysdeps/x86_64/multiarch/ifunc-memmove.h
++++ b/sysdeps/x86_64/multiarch/ifunc-memmove.h
+@@ -64,7 +64,8 @@ IFUNC_SELECTOR (void)
+ 	  return OPTIMIZE (avx512_unaligned);
+ 	}
+ 
+-      return OPTIMIZE (avx512_no_vzeroupper);
++      if (!LAM_ENABLED_P ())
++	return OPTIMIZE (avx512_no_vzeroupper);
+     }
+ 
+   if (CPU_FEATURES_ARCH_P (cpu_features, AVX_Fast_Unaligned_Load))
+@@ -94,7 +95,8 @@ IFUNC_SELECTOR (void)
+ 	}
+     }
+ 
+-  if (!CPU_FEATURE_USABLE_P (cpu_features, SSSE3)
++  if (LAM_ENABLED_P ()
++      || !CPU_FEATURE_USABLE_P (cpu_features, SSSE3)
+       || CPU_FEATURES_ARCH_P (cpu_features, Fast_Unaligned_Copy))
+     {
+       if (CPU_FEATURE_USABLE_P (cpu_features, ERMS))
+diff --git a/sysdeps/x86_64/sysdep.h b/sysdeps/x86_64/sysdep.h
+index 7bebdeb210..e18ba62662 100644
+--- a/sysdeps/x86_64/sysdep.h
++++ b/sysdeps/x86_64/sysdep.h
+@@ -146,6 +146,24 @@ lose:									      \
+ #define R14_LP	"r14"
+ #define R15_LP	"r15"
+ 
++#if BUILD_PIE_DEFAULT
++/* NB: This may be used in IFUNC selector to relocate static PIE before
++   TCB is initialized.  */
++# define LAM_U48_ENABLED_P() LAM_ENABLED
++# define LAM_U57_ENABLED_P() LAM_ENABLED
++# define LAM_ENABLED_P() LAM_ENABLED
++#else
++# define LAM_U48_ENABLED_P() \
++  (LAM_ENABLED \
++   && (X86_FEATURE_1 () & GNU_PROPERTY_X86_FEATURE_1_LAM_U48) != 0)
++# define LAM_U57_ENABLED_P() \
++  (LAM_ENABLED \
++   && (X86_FEATURE_1 () & GNU_PROPERTY_X86_FEATURE_1_LAM_U57) != 0)
++# define LAM_ENABLED_P() \
++  (LAM_ENABLED \
++   && (X86_FEATURE_1 () & GNU_PROPERTY_X86_FEATURE_1_LAM_MASK) != 0)
++#endif
++
+ #endif	/* __ASSEMBLER__ */
+ 
+ #endif	/* _X86_64_SYSDEP_H */
+-- 
+2.31.1
+
diff --git a/0018-x86-Modularize-sysdeps-x86-dl-feature.c.patch b/0018-x86-Modularize-sysdeps-x86-dl-feature.c.patch
new file mode 100644
index 0000000..2aced09
--- /dev/null
+++ b/0018-x86-Modularize-sysdeps-x86-dl-feature.c.patch
@@ -0,0 +1,516 @@
+From 715283cd2d08cd54e4885a177f74054778e92b98 Mon Sep 17 00:00:00 2001
+From: Joao Moreira <joao.moreira@intel.com>
+Date: Mon, 11 Jan 2021 17:44:22 -0800
+Subject: [PATCH 18/24] x86: Modularize sysdeps/x86/dl-feature.c
+
+Improve readability and make maintenance easier for dl-feature.c by
+modularizing sysdeps/x86/dl-feature.c
+---
+ sysdeps/x86/dl-feature.c | 460 ++++++++++++++++++++++++---------------
+ 1 file changed, 283 insertions(+), 177 deletions(-)
+
+diff --git a/sysdeps/x86/dl-feature.c b/sysdeps/x86/dl-feature.c
+index 7ff7b614f0..6054f00d49 100644
+--- a/sysdeps/x86/dl-feature.c
++++ b/sysdeps/x86/dl-feature.c
+@@ -24,7 +24,7 @@
+ /* GNU_PROPERTY_X86_FEATURE_1_IBT and GNU_PROPERTY_X86_FEATURE_1_SHSTK
+    are defined in <elf.h>, which are only available for C sources.
+    X86_FEATURE_1_IBT and X86_FEATURE_1_SHSTK are defined in <sysdep.h>
+-   which are available for both C and asm sources.  They must match.   */
++   which are available for both C and asm sources.  They must match.  */
+ #if GNU_PROPERTY_X86_FEATURE_1_IBT != X86_FEATURE_1_IBT
+ # error GNU_PROPERTY_X86_FEATURE_1_IBT != X86_FEATURE_1_IBT
+ #endif
+@@ -32,206 +32,312 @@
+ # error GNU_PROPERTY_X86_FEATURE_1_SHSTK != X86_FEATURE_1_SHSTK
+ #endif
+ 
+-/* Check if object M is compatible with x86 features.  */
++struct dl_feature_info
++{
++  const char *program;
++
++  /* Check how IBT and SHSTK should be enabled.  */
++  enum dl_x86_feature_control_enum enable_ibt_type;
++  enum dl_x86_feature_control_enum enable_shstk_type;
++
++  /* If IBT and SHSTK were previously enabled.  */
++  unsigned int feature_1_enabled;
++
++  /* If IBT and SHSTK should be enabled.  */
++  unsigned int enable_feature_1;
++
++  /* If there are any legacy shared object.  */
++  unsigned int feature_1_legacy;
++
++  /* Which shared object is the first legacy shared object.  */
++  unsigned int feature_1_legacy_ibt;
++  unsigned int feature_1_legacy_shstk;
++};
++
++/* Check if the object M and its dependencies are legacy object.  */
+ 
+ static void
+-dl_feature_check (struct link_map *m, const char *program)
++dl_check_legacy_object (struct link_map *m,
++			struct dl_feature_info *info)
+ {
+-  /* Check how IBT should be enabled.  */
+-  enum dl_x86_feature_control_enum enable_ibt_type
+-    = GL(dl_x86_feature_control).ibt;
+-  /* Check how SHSTK should be enabled.  */
+-  enum dl_x86_feature_control_enum enable_shstk_type
+-    = GL(dl_x86_feature_control).shstk;
+-
+-  /* No legacy object check if both IBT and SHSTK are always on.  */
+-  if (enable_ibt_type == x86_feature_always_on
+-      && enable_shstk_type == x86_feature_always_on)
++  unsigned int i;
++  struct link_map *l = NULL;
++
++  i = m->l_searchlist.r_nlist;
++  while (i-- > 0)
+     {
+-      THREAD_SETMEM (THREAD_SELF, header.feature_1, GL(dl_x86_feature_1));
+-      return;
+-    }
++      /* Check each shared object to see if IBT and SHSTK are enabled.  */
++      l = m->l_initfini[i];
+ 
+-  /* Check if IBT is enabled by kernel.  */
+-  bool ibt_enabled
+-    = (GL(dl_x86_feature_1) & GNU_PROPERTY_X86_FEATURE_1_IBT) != 0;
+-  /* Check if SHSTK is enabled by kernel.  */
+-  bool shstk_enabled
+-    = (GL(dl_x86_feature_1) & GNU_PROPERTY_X86_FEATURE_1_SHSTK) != 0;
++      if (l->l_init_called)
++        continue;
+ 
+-  if (ibt_enabled || shstk_enabled)
+-    {
+-      struct link_map *l = NULL;
+-      unsigned int ibt_legacy = 0, shstk_legacy = 0;
+-      bool found_ibt_legacy = false, found_shstk_legacy = false;
+-
+-      /* Check if IBT and SHSTK are enabled in object.  */
+-      bool enable_ibt = (ibt_enabled
+-			 && enable_ibt_type != x86_feature_always_off);
+-      bool enable_shstk = (shstk_enabled
+-			   && enable_shstk_type != x86_feature_always_off);
+-      if (program)
++#ifdef SHARED
++      /* Skip check for ld.so since it has the features enabled.  The
++         features will be disabled later if they are not enabled in
++	 executable.  */
++      if (l == &GL(dl_rtld_map)
++          || l->l_real == &GL(dl_rtld_map)
++          || (info->program != NULL && l == m))
++         continue;
++#endif
++
++      /* IBT and SHSTK set only if enabled in executable and all DSOs.
++	 NB: x86_feature_always_on is handled outside of the loop.  */
++      info->enable_feature_1 &= ((l->l_x86_feature_1_and
++				  & GNU_PROPERTY_X86_FEATURE_1_MASK)
++				 | ~GNU_PROPERTY_X86_FEATURE_1_MASK);
++      if ((info->feature_1_legacy
++	   & GNU_PROPERTY_X86_FEATURE_1_IBT) == 0
++	  && ((info->enable_feature_1
++	       & GNU_PROPERTY_X86_FEATURE_1_IBT)
++	      != (info->feature_1_enabled
++		  & GNU_PROPERTY_X86_FEATURE_1_IBT)))
+ 	{
+-	  /* Enable IBT and SHSTK only if they are enabled in executable.
+-	     NB: IBT and SHSTK may be disabled by environment variable:
+-
+-	     GLIBC_TUNABLES=glibc.cpu.hwcaps=-IBT,-SHSTK
+-	   */
+-	  enable_ibt &= (CPU_FEATURE_USABLE (IBT)
+-			 && (enable_ibt_type == x86_feature_always_on
+-			     || (m->l_x86_feature_1_and
+-				 & GNU_PROPERTY_X86_FEATURE_1_IBT) != 0));
+-	  enable_shstk &= (CPU_FEATURE_USABLE (SHSTK)
+-			   && (enable_shstk_type == x86_feature_always_on
+-			       || (m->l_x86_feature_1_and
+-				   & GNU_PROPERTY_X86_FEATURE_1_SHSTK) != 0));
++	  info->feature_1_legacy_ibt = i;
++	  info->feature_1_legacy |= GNU_PROPERTY_X86_FEATURE_1_IBT;
+ 	}
+ 
+-      /* ld.so is CET-enabled by kernel.  But shared objects may not
+-	 support IBT nor SHSTK.  */
+-      if (enable_ibt || enable_shstk)
+-	{
+-	  unsigned int i;
++      if ((info->feature_1_legacy
++	   & GNU_PROPERTY_X86_FEATURE_1_SHSTK) == 0
++	  && ((info->enable_feature_1
++	       & GNU_PROPERTY_X86_FEATURE_1_SHSTK)
++	      != (info->feature_1_enabled
++		  & GNU_PROPERTY_X86_FEATURE_1_SHSTK)))
++        {
++	  info->feature_1_legacy_shstk = i;
++	  info->feature_1_legacy |= GNU_PROPERTY_X86_FEATURE_1_SHSTK;
++        }
++    }
+ 
+-	  i = m->l_searchlist.r_nlist;
+-	  while (i-- > 0)
+-	    {
+-	      /* Check each shared object to see if IBT and SHSTK are
+-		 enabled.  */
+-	      l = m->l_initfini[i];
++  /* Handle x86_feature_always_on.  */
++  if ((info->feature_1_enabled
++       & GNU_PROPERTY_X86_FEATURE_1_IBT) != 0
++      && info->enable_ibt_type == x86_feature_always_on)
++    {
++      info->feature_1_legacy &= ~GNU_PROPERTY_X86_FEATURE_1_IBT;
++      info->enable_feature_1 |= GNU_PROPERTY_X86_FEATURE_1_IBT;
++    }
+ 
+-	      if (l->l_init_called)
+-		continue;
++  if ((info->feature_1_enabled
++       & GNU_PROPERTY_X86_FEATURE_1_SHSTK) != 0
++      && info->enable_shstk_type == x86_feature_always_on)
++    {
++      info->feature_1_legacy &= ~GNU_PROPERTY_X86_FEATURE_1_SHSTK;
++      info->enable_feature_1 |= GNU_PROPERTY_X86_FEATURE_1_SHSTK;
++    }
++}
+ 
+ #ifdef SHARED
+-	      /* Skip CET check for ld.so since ld.so is CET-enabled.
+-		 CET will be disabled later if CET isn't enabled in
+-		 executable.  */
+-	      if (l == &GL(dl_rtld_map)
+-		  ||  l->l_real == &GL(dl_rtld_map)
+-		  || (program && l == m))
+-		continue;
++/* Enable IBT and SHSTK only if they are enabled in executable.  Set
++   feature bits properly at the start of the program.  */
++
++static void
++dl_feature_check_startup (struct link_map *m,
++			  struct dl_feature_info *info)
++{
++  /* NB: IBT and SHSTK may be disabled by environment variable:
++
++     GLIBC_TUNABLES=glibc.cpu.hwcaps=-IBT,-SHSTK.
++   */
++  if (CPU_FEATURE_USABLE (IBT))
++    {
++      if (info->enable_ibt_type == x86_feature_always_on)
++	info->enable_feature_1 |= GNU_PROPERTY_X86_FEATURE_1_IBT;
++      else
++	info->enable_feature_1 &= ((m->l_x86_feature_1_and
++				    & GNU_PROPERTY_X86_FEATURE_1_IBT)
++				   | ~GNU_PROPERTY_X86_FEATURE_1_IBT);
++    }
++  else
++    info->enable_feature_1 &= ~GNU_PROPERTY_X86_FEATURE_1_IBT;
++
++  if (CPU_FEATURE_USABLE (SHSTK))
++    {
++      if (info->enable_shstk_type == x86_feature_always_on)
++	info->enable_feature_1 |= GNU_PROPERTY_X86_FEATURE_1_SHSTK;
++      else
++	info->enable_feature_1 &= ((m->l_x86_feature_1_and
++				    & GNU_PROPERTY_X86_FEATURE_1_SHSTK)
++				   | ~GNU_PROPERTY_X86_FEATURE_1_SHSTK);
++    }
++  else
++    info->enable_feature_1 &= ~GNU_PROPERTY_X86_FEATURE_1_SHSTK;
++
++  if (info->enable_feature_1 != 0)
++    dl_check_legacy_object (m, info);
++
++  unsigned int disable_feature_1
++    = info->enable_feature_1 ^ info->feature_1_enabled;
++  if (disable_feature_1 != 0)
++    {
++      /* Disable features in the kernel because of legacy objects or
++	 x86_feature_always_off.  */
++      if (dl_feature_1_disable (disable_feature_1) != 0)
++	_dl_fatal_printf ("%s: can't disable x86 Features\n",
++			  info->program);
++
++      /* Clear the disabled bits.  Sync dl_x86_feature_1 and
++         info->feature_1_enabled with info->enable_feature_1.  */
++      info->feature_1_enabled = info->enable_feature_1;
++      GL(dl_x86_feature_1) = info->enable_feature_1;
++    }
++
++  if (HAS_CPU_FEATURE (IBT) && HAS_CPU_FEATURE (SHSTK))
++    {
++      /* Don't lock CET on CPU with CET if IBT or SHSTK are enabled
++	 permissively.  */
++      unsigned int cet_lock = 0;
++      bool ibt_enabled = ((info->feature_1_enabled
++			   & GNU_PROPERTY_X86_FEATURE_1_IBT) != 0);
++      if ((ibt_enabled
++	   && info->enable_ibt_type != x86_feature_permissive)
++	  || !ibt_enabled)
++	cet_lock |= GNU_PROPERTY_X86_FEATURE_1_IBT;
++
++      bool shstk_enabled = ((info->feature_1_enabled
++			     & GNU_PROPERTY_X86_FEATURE_1_SHSTK) != 0);
++      if ((shstk_enabled
++	   && info->enable_shstk_type != x86_feature_permissive)
++	  || !shstk_enabled)
++	cet_lock |= GNU_PROPERTY_X86_FEATURE_1_SHSTK;
++
++      if (cet_lock != 0 && dl_cet_lock () != 0)
++	_dl_fatal_printf ("%s: can't lock CET\n", info->program);
++    }
++
++  THREAD_SETMEM (THREAD_SELF, header.feature_1, GL(dl_x86_feature_1));
++}
+ #endif
+ 
+-	      /* IBT is enabled only if it is enabled in executable as
+-		 well as all shared objects.  */
+-	      enable_ibt &= (enable_ibt_type == x86_feature_always_on
+-			     || (l->l_x86_feature_1_and
+-				 & GNU_PROPERTY_X86_FEATURE_1_IBT) != 0);
+-	      if (!found_ibt_legacy && enable_ibt != ibt_enabled)
+-		{
+-		  found_ibt_legacy = true;
+-		  ibt_legacy = i;
+-		}
+-
+-	      /* SHSTK is enabled only if it is enabled in executable as
+-		 well as all shared objects.  */
+-	      enable_shstk &= (enable_shstk_type == x86_feature_always_on
+-			       || (l->l_x86_feature_1_and
+-				   & GNU_PROPERTY_X86_FEATURE_1_SHSTK) != 0);
+-	      if (enable_shstk != shstk_enabled)
+-		{
+-		  found_shstk_legacy = true;
+-		  shstk_legacy = i;
+-		}
+-	    }
+-	}
++/* Check feature bits when dlopening the shared object M.  */
++
++static void
++dl_feature_check_dlopen (struct link_map *m,
++			 struct dl_feature_info *info)
++{
++  /* Check if there are any legacy objects loaded.  */
++  if (info->enable_feature_1 != 0)
++    {
++      dl_check_legacy_object (m, info);
+ 
+-      bool feature_1_changed = false;
++      /* Skip if there are no legacy shared objects loaded.  */
++      if (info->feature_1_legacy == 0)
++	return;
++    }
+ 
+-      if (enable_ibt != ibt_enabled || enable_shstk != shstk_enabled)
+-	{
+-	  if (!program)
+-	    {
+-	      if (enable_ibt_type != x86_feature_permissive)
+-		{
+-		  /* When IBT is enabled, we cannot dlopen a shared
+-		     object without IBT.  */
+-		  if (found_ibt_legacy)
+-		    _dl_signal_error (0,
+-				      m->l_initfini[ibt_legacy]->l_name,
+-				      "dlopen",
+-				      N_("rebuild shared object with IBT support enabled"));
+-		}
+-
+-	      if (enable_shstk_type != x86_feature_permissive)
+-		{
+-		  /* When SHSTK is enabled, we cannot dlopen a shared
+-		     object without SHSTK.  */
+-		  if (found_shstk_legacy)
+-		    _dl_signal_error (0,
+-				      m->l_initfini[shstk_legacy]->l_name,
+-				      "dlopen",
+-				      N_("rebuild shared object with SHSTK support enabled"));
+-		}
+-
+-	      if (enable_ibt_type != x86_feature_permissive
+-		  && enable_shstk_type != x86_feature_permissive)
+-		return;
+-	    }
+-
+-	  /* Disable IBT and/or SHSTK if they are enabled by kernel, but
+-	     disabled in executable or shared objects.  */
+-	  unsigned int feature_1 = 0;
+-
+-	  if (!enable_ibt)
+-	    feature_1 |= GNU_PROPERTY_X86_FEATURE_1_IBT;
+-	  if (!enable_shstk)
+-	    feature_1 |= GNU_PROPERTY_X86_FEATURE_1_SHSTK;
+-
+-	  int res = dl_feature_1_disable (feature_1);
+-	  if (res != 0)
+-	    {
+-	      if (program)
+-		_dl_fatal_printf ("%s: can't disable CET\n", program);
+-	      else
+-		{
+-		  if (found_ibt_legacy)
+-		    l = m->l_initfini[ibt_legacy];
+-		  else
+-		    l = m->l_initfini[shstk_legacy];
+-		  _dl_signal_error (-res, l->l_name, "dlopen",
+-				    N_("can't disable CET"));
+-		}
+-	    }
+-
+-	  /* Clear the disabled bits in dl_x86_feature_1.  */
+-	  GL(dl_x86_feature_1) &= ~feature_1;
+-
+-	  feature_1_changed = true;
+-	}
++  unsigned int disable_feature_1 = 0;
++  unsigned int legacy_obj = 0;
++  const char *msg = NULL;
+ 
+-#ifdef SHARED
+-      if (program && (ibt_enabled || shstk_enabled))
++  if ((info->feature_1_enabled
++       & GNU_PROPERTY_X86_FEATURE_1_IBT) != 0
++      && (info->feature_1_legacy
++	  & GNU_PROPERTY_X86_FEATURE_1_IBT) != 0)
++    {
++      if (info->enable_ibt_type != x86_feature_permissive)
+ 	{
+-	  if ((!ibt_enabled
+-	       || enable_ibt_type != x86_feature_permissive)
+-	      && (!shstk_enabled
+-		  || enable_shstk_type != x86_feature_permissive))
+-	    {
+-	      /* Lock CET if IBT or SHSTK is enabled in executable unless
+-	         IBT or SHSTK is enabled permissively.  */
+-	      int res = dl_cet_lock ();
+-	      if (res != 0)
+-		_dl_fatal_printf ("%s: can't lock CET\n", program);
+-	    }
+-
+-	  /* Set feature_1 if IBT or SHSTK is enabled in executable.  */
+-	  feature_1_changed = true;
++	  legacy_obj = info->feature_1_legacy_ibt;
++	  msg = N_("rebuild shared object with IBT support enabled");
+ 	}
+-#endif
++      else
++        disable_feature_1 |= GNU_PROPERTY_X86_FEATURE_1_IBT;
++    }
+ 
+-      if (feature_1_changed)
++  /* Check the next feature only if there is no error.  */
++  if (msg == NULL
++      && (info->feature_1_enabled
++	  & GNU_PROPERTY_X86_FEATURE_1_SHSTK) != 0
++      && (info->feature_1_legacy
++	  & GNU_PROPERTY_X86_FEATURE_1_SHSTK) != 0)
++    {
++      if (info->enable_shstk_type != x86_feature_permissive)
+ 	{
+-	  unsigned int feature_1 = 0;
+-	  if (enable_ibt)
+-	    feature_1 |= GNU_PROPERTY_X86_FEATURE_1_IBT;
+-	  if (enable_shstk)
+-	    feature_1 |= GNU_PROPERTY_X86_FEATURE_1_SHSTK;
+-	  struct pthread *self = THREAD_SELF;
+-	  THREAD_SETMEM (self, header.feature_1, feature_1);
++	  legacy_obj = info->feature_1_legacy_shstk;
++	  msg = N_("rebuild shared object with SHSTK support enabled");
+ 	}
++      else
++        disable_feature_1 |= GNU_PROPERTY_X86_FEATURE_1_SHSTK;
++    }
++
++  /* If there is an error, long jump back to the caller.  */
++  if (msg != NULL)
++    _dl_signal_error (0, m->l_initfini[legacy_obj]->l_name, "dlopen",
++		      msg);
++
++  if (disable_feature_1 != 0)
++    {
++      int res = dl_feature_1_disable (disable_feature_1);
++      if (res)
++        {
++	  if ((disable_feature_1
++	       & GNU_PROPERTY_X86_FEATURE_1_IBT) != 0)
++	    msg = N_("can't disable IBT");
++	  else
++	    msg = N_("can't disable SHSTK");
++	  /* Long jump back to the caller on error.  */
++	  _dl_signal_error (-res, m->l_initfini[legacy_obj]->l_name,
++			    "dlopen", msg);
++       }
++
++      /* Clear the disabled bits in dl_x86_feature_1.  */
++      GL(dl_x86_feature_1) &= ~disable_feature_1;
++
++      THREAD_SETMEM (THREAD_SELF, header.feature_1,
++		     GL(dl_x86_feature_1));
++    }
++}
++
++static void
++dl_feature_check (struct link_map *m, const char *program)
++{
++  struct dl_feature_info info;
++
++  /* Check how IBT and SHSTK should be enabled. */
++  info.enable_ibt_type = GL(dl_x86_feature_control).ibt;
++  info.enable_shstk_type = GL(dl_x86_feature_control).shstk;
++
++  info.feature_1_enabled = GL(dl_x86_feature_1);
++
++  /* No legacy object check if IBT and SHSTK are always on.  */
++  if (info.enable_ibt_type == x86_feature_always_on
++      && info.enable_shstk_type == x86_feature_always_on)
++    {
++#ifdef SHARED
++      /* Set it only during startup.  */
++      if (program != NULL)
++	THREAD_SETMEM (THREAD_SELF, header.feature_1,
++		       info.feature_1_enabled);
++#endif
++      return;
+     }
++
++  /* Check if IBT and SHSTK were enabled by kernel.  */
++  if (info.feature_1_enabled == 0)
++    return;
++
++  info.program = program;
++
++  /* Check which features should be enabled.  */
++  info.enable_feature_1 = 0;
++  if (info.enable_ibt_type != x86_feature_always_off)
++    info.enable_feature_1 |= (info.feature_1_enabled
++			      & GNU_PROPERTY_X86_FEATURE_1_IBT);
++  if (info.enable_shstk_type != x86_feature_always_off)
++    info.enable_feature_1 |= (info.feature_1_enabled
++			      & GNU_PROPERTY_X86_FEATURE_1_SHSTK);
++
++  /* Start with no legacy objects.  */
++  info.feature_1_legacy = 0;
++  info.feature_1_legacy_ibt = 0;
++  info.feature_1_legacy_shstk = 0;
++
++#ifdef SHARED
++  if (program)
++    dl_feature_check_startup (m, &info);
++  else
++#endif
++    dl_feature_check_dlopen (m, &info);
+ }
+ 
+ void
+-- 
+2.31.1
+
diff --git a/0019-x86-Enable-LAM-feature.patch b/0019-x86-Enable-LAM-feature.patch
new file mode 100644
index 0000000..285c1ec
--- /dev/null
+++ b/0019-x86-Enable-LAM-feature.patch
@@ -0,0 +1,975 @@
+From bf92d5af39f7e58ae9aef8d0cd7209e9b51a406a Mon Sep 17 00:00:00 2001
+From: Sunil K Pandey <skpgkp2@gmail.com>
+Date: Sun, 24 Jan 2021 19:20:14 -0800
+Subject: [PATCH 19/24] x86: Enable LAM feature
+
+Enable LAM feature and add LAM feature enable function.
+
+Support
+
+export GLIBC_TUNABLES=glibc.cpu.x86_64_lam_size=57:glibc.cpu.x86_64_already=lam
+
+to indicate that LAM_U57 is already enabled.  Do nothing only if we
+are asked to enable LAM_U57 and it has been enabled already.
+
+1. set_tagged_address_mask shouldn't be allowed after pthread_create is
+called.  Otherwise different threads may have different masks for the
+same address space.
+2. After set_tagged_address_mask is called, don't allow it to be called
+again to change the tagged address mask.  Otherwise, the previously
+tagged addresses may not work anymore.
+---
+ sysdeps/unix/sysv/linux/x86/cpu-features.c  |   2 +-
+ sysdeps/unix/sysv/linux/x86/dl-feature.h    |   7 +
+ sysdeps/x86/bits/tagged-address.h           |  32 ++
+ sysdeps/x86/cpu-features.c                  |   8 +-
+ sysdeps/x86/dl-feature.c                    | 337 ++++++++++++++++++--
+ sysdeps/x86/dl-prop.h                       |  11 +-
+ sysdeps/x86/feature-control.h               |  40 +++
+ sysdeps/x86/nptl/tls-setup.h                |   3 +
+ sysdeps/x86/sysdep.h                        |   4 +
+ sysdeps/x86_64/64/inline-tagged-address.h   |  66 ++++
+ sysdeps/x86_64/64/set-tagged-address-mask.c | 114 +++++++
+ sysdeps/x86_64/nptl/tcb-offsets.sym         |   3 +
+ sysdeps/x86_64/nptl/tls.h                   |  30 ++
+ 13 files changed, 629 insertions(+), 28 deletions(-)
+ create mode 100644 sysdeps/x86/bits/tagged-address.h
+ create mode 100644 sysdeps/x86_64/64/inline-tagged-address.h
+ create mode 100644 sysdeps/x86_64/64/set-tagged-address-mask.c
+
+diff --git a/sysdeps/unix/sysv/linux/x86/cpu-features.c b/sysdeps/unix/sysv/linux/x86/cpu-features.c
+index 5a170bc134..cc3346d501 100644
+--- a/sysdeps/unix/sysv/linux/x86/cpu-features.c
++++ b/sysdeps/unix/sysv/linux/x86/cpu-features.c
+@@ -35,7 +35,7 @@ static inline void
+ x86_setup_tls (void)
+ {
+   __libc_setup_tls ();
+-  THREAD_SETMEM (THREAD_SELF, header.feature_1, GL(dl_x86_feature_1));
++  dl_update_x86_feature_1 (GL(dl_x86_feature_1));
+ }
+ 
+ #  define ARCH_SETUP_TLS() x86_setup_tls ()
+diff --git a/sysdeps/unix/sysv/linux/x86/dl-feature.h b/sysdeps/unix/sysv/linux/x86/dl-feature.h
+index 6ee5d84486..eedd9a06c6 100644
+--- a/sysdeps/unix/sysv/linux/x86/dl-feature.h
++++ b/sysdeps/unix/sysv/linux/x86/dl-feature.h
+@@ -32,3 +32,10 @@ dl_cet_lock (void)
+   return (int) INTERNAL_SYSCALL_CALL (arch_prctl,
+ 				      ARCH_X86_CET_1_LOCK, 0);
+ }
++
++static inline int __attribute__ ((always_inline))
++dl_feature_1_enable (unsigned int feature_1)
++{
++  return (int) INTERNAL_SYSCALL_CALL (arch_prctl, ARCH_X86_FEATURE_1_ENABLE,
++				      feature_1);
++}
+diff --git a/sysdeps/x86/bits/tagged-address.h b/sysdeps/x86/bits/tagged-address.h
+new file mode 100644
+index 0000000000..4a00e4a6f1
+--- /dev/null
++++ b/sysdeps/x86/bits/tagged-address.h
+@@ -0,0 +1,32 @@
++/* Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#ifndef _BITS_TAGGED_ADDRESS_H
++#define _BITS_TAGGED_ADDRESS_H 1
++
++#ifndef _SYS_TAGGED_ADDRESS_H
++# error "Never include this file directly.  Use <sys/tagged-address.h> instead"
++#endif
++
++/* Non-zero if constant address BITS is a valid tagged address bits.  */
++#if defined __x86_64__ && !defined __ILP32__
++# define TAGGED_ADDRESS_VALID_BITS(BITS) ((BITS) == 48 || (BITS) == 57)
++#else
++# define TAGGED_ADDRESS_VALID_BITS(BITS) 0
++#endif
++
++#endif /* <bits/tagged-address.h> */
+diff --git a/sysdeps/x86/cpu-features.c b/sysdeps/x86/cpu-features.c
+index 55bb9e1cbf..ec06a728c7 100644
+--- a/sysdeps/x86/cpu-features.c
++++ b/sysdeps/x86/cpu-features.c
+@@ -747,11 +747,15 @@ no_cpuid:
+   if ((feature_1_status & GNU_PROPERTY_X86_FEATURE_1_SHSTK) == 0)
+     CPU_FEATURE_UNSET (cpu_features, SHSTK)
+ 
++# ifndef SHARED
++  feature_1_status = _dl_sync_x86_feature_1 (feature_1_status);
++# endif
++
+   if (feature_1_status)
+     {
++# ifdef SHARED
+       GL(dl_x86_feature_1) = feature_1_status;
+-
+-# ifndef SHARED
++# else
+       /* Check if features are enabled by kernel.  */
+       if ((feature_1_status
+ 	   & GNU_PROPERTY_X86_FEATURE_1_MASK) != 0)
+diff --git a/sysdeps/x86/dl-feature.c b/sysdeps/x86/dl-feature.c
+index 6054f00d49..1243b38b6f 100644
+--- a/sysdeps/x86/dl-feature.c
++++ b/sysdeps/x86/dl-feature.c
+@@ -20,6 +20,14 @@
+ #include <libintl.h>
+ #include <ldsodefs.h>
+ #include <dl-feature.h>
++#ifdef SHARED
++# define DL_SYNC_X86_FEATURE_1_LINKAGE static
++# define DL_SYNC_X86_FEATURE_1_PARM , const char *program
++#else
++# define DL_SYNC_X86_FEATURE_1_LINKAGE
++# define DL_SYNC_X86_FEATURE_1_PARM
++# include <stdio.h>    /* For __libc_fatal.  */
++#endif
+ 
+ /* GNU_PROPERTY_X86_FEATURE_1_IBT and GNU_PROPERTY_X86_FEATURE_1_SHSTK
+    are defined in <elf.h>, which are only available for C sources.
+@@ -36,22 +44,27 @@ struct dl_feature_info
+ {
+   const char *program;
+ 
+-  /* Check how IBT and SHSTK should be enabled.  */
++  /* Check how IBT, SHSTK and LAM should be enabled.  */
+   enum dl_x86_feature_control_enum enable_ibt_type;
+   enum dl_x86_feature_control_enum enable_shstk_type;
++  enum dl_x86_feature_control_enum enable_lam_type;
+ 
+-  /* If IBT and SHSTK were previously enabled.  */
++  /* If IBT, SHSTK and LAM were previously enabled.  */
+   unsigned int feature_1_enabled;
+ 
+-  /* If IBT and SHSTK should be enabled.  */
++  /* If IBT, SHSTK and LAM should be enabled.  */
+   unsigned int enable_feature_1;
+ 
++  /* LAM compatibility of all loaded objects.  */
++  unsigned int feature_1_lam;
++
+   /* If there are any legacy shared object.  */
+   unsigned int feature_1_legacy;
+ 
+   /* Which shared object is the first legacy shared object.  */
+   unsigned int feature_1_legacy_ibt;
+   unsigned int feature_1_legacy_shstk;
++  unsigned int feature_1_legacy_lam;
+ };
+ 
+ /* Check if the object M and its dependencies are legacy object.  */
+@@ -82,8 +95,11 @@ dl_check_legacy_object (struct link_map *m,
+          continue;
+ #endif
+ 
+-      /* IBT and SHSTK set only if enabled in executable and all DSOs.
+-	 NB: x86_feature_always_on is handled outside of the loop.  */
++      /* LAM compatibility of loaded objects.  */
++      info->feature_1_lam &= l->l_x86_feature_1_and;
++
++      /* IBT, SHSTK and LAM set only if enabled in executable and all
++         DSOs.  NB: always_on is handled outside of the loop.  */
+       info->enable_feature_1 &= ((l->l_x86_feature_1_and
+ 				  & GNU_PROPERTY_X86_FEATURE_1_MASK)
+ 				 | ~GNU_PROPERTY_X86_FEATURE_1_MASK);
+@@ -108,9 +124,25 @@ dl_check_legacy_object (struct link_map *m,
+ 	  info->feature_1_legacy_shstk = i;
+ 	  info->feature_1_legacy |= GNU_PROPERTY_X86_FEATURE_1_SHSTK;
+         }
++
++#if LAM_ENABLED
++      if ((info->feature_1_legacy
++	   & GNU_PROPERTY_X86_FEATURE_1_LAM_MASK) == 0)
++	{
++	  unsigned int lam_enabled
++	    = (info->feature_1_enabled
++	       & GNU_PROPERTY_X86_FEATURE_1_LAM_MASK);
++	  if ((info->enable_feature_1
++	       & GNU_PROPERTY_X86_FEATURE_1_LAM_MASK) != lam_enabled)
++	    {
++	      info->feature_1_legacy_lam = i;
++	      info->feature_1_legacy |= lam_enabled;
++	    }
++	}
++#endif
+     }
+ 
+-  /* Handle x86_feature_always_on.  */
++  /* Handle always_on.  */
+   if ((info->feature_1_enabled
+        & GNU_PROPERTY_X86_FEATURE_1_IBT) != 0
+       && info->enable_ibt_type == x86_feature_always_on)
+@@ -126,11 +158,79 @@ dl_check_legacy_object (struct link_map *m,
+       info->feature_1_legacy &= ~GNU_PROPERTY_X86_FEATURE_1_SHSTK;
+       info->enable_feature_1 |= GNU_PROPERTY_X86_FEATURE_1_SHSTK;
+     }
++
++#ifdef LAM_ENABLED
++  if ((info->feature_1_enabled
++       & GNU_PROPERTY_X86_FEATURE_1_LAM_MASK) != 0
++      && info->enable_lam_type == x86_feature_always_on)
++    {
++      info->feature_1_legacy &= ~GNU_PROPERTY_X86_FEATURE_1_LAM_MASK;
++      /* Clear the LAM mask first.  */
++      info->enable_feature_1 &= ~GNU_PROPERTY_X86_FEATURE_1_LAM_MASK;
++      info->enable_feature_1 |= (info->feature_1_enabled
++				 & GNU_PROPERTY_X86_FEATURE_1_LAM_MASK);
++    }
++#endif
+ }
+ 
+ #ifdef SHARED
+-/* Enable IBT and SHSTK only if they are enabled in executable.  Set
+-   feature bits properly at the start of the program.  */
++/* During startup, check LAM compatibility on executable and all
++   loaded objects.  always_off disables LAM.  always_on ignores
++   LAM compatibility on executable and all loaded objects.  */
++
++static void
++dl_check_lam (struct link_map *m, struct dl_feature_info *info)
++{
++# if LAM_ENABLED
++  if ((info->feature_1_enabled
++       & GNU_PROPERTY_X86_FEATURE_1_LAM_MASK) == 0
++      || info->enable_lam_type == x86_feature_always_on)
++    return;
++
++  /* LAM compatibility on executable and all loaded objects.  */
++  unsigned int enable_lam = (m->l_x86_feature_1_and
++			     & info->feature_1_lam
++			     & GNU_PROPERTY_X86_FEATURE_1_LAM_MASK);
++  /* Do nothing in following combination.
++     enable_feature_1  enable_lam
++     LAM_U48           LAM_U48
++     LAM_U57           LAM_U57
++     LAM_U57           LAM_U48(As per LAM psABI LAM_U48 ==> LAM_U57)
++  */
++  if (enable_lam == 0)
++    {
++      /* If executable and all loaded objects aren't LAM compatible,
++	 disable LAM and sync dl_x86_feature_1 later.  */
++      info->enable_feature_1 &= ~GNU_PROPERTY_X86_FEATURE_1_LAM_MASK;
++    }
++  else if ((info->enable_feature_1
++	    & GNU_PROPERTY_X86_FEATURE_1_LAM_U48) != 0
++	   && ((enable_lam & GNU_PROPERTY_X86_FEATURE_1_LAM_U57) != 0))
++    {
++      /* If executable and all loaded objects are LAM_U57 compatible,
++	 but not LAM_U48 compatible, and LAM_U48 is enabled, enable
++	 LAM_U57 instead.  NB: LAM_U48 will be disabled when LAM_U57
++	 is enabled.  */
++      if (dl_feature_1_enable (GNU_PROPERTY_X86_FEATURE_1_LAM_U57)
++	  != 0)
++	_dl_fatal_printf ("%s: can't enable LAM_U57\n",
++			  info->program);
++
++      /* NB: info->enable_feature_1 and info->feature_1_enabled can
++	 be different here.  */
++      info->enable_feature_1 |= GNU_PROPERTY_X86_FEATURE_1_LAM_U57;
++      info->enable_feature_1 &= ~GNU_PROPERTY_X86_FEATURE_1_LAM_U48;
++      info->feature_1_enabled |= GNU_PROPERTY_X86_FEATURE_1_LAM_U57;
++      info->feature_1_enabled &= ~GNU_PROPERTY_X86_FEATURE_1_LAM_U48;
++
++      /* Sync dl_x86_feature_1 with info->feature_1_enabled.  */
++      GL(dl_x86_feature_1) = info->feature_1_enabled;
++    }
++# endif
++}
++
++/* Enable features only if they are enabled in executable.  Set feature
++   bits properly at the start of the program.  */
+ 
+ static void
+ dl_feature_check_startup (struct link_map *m,
+@@ -164,8 +264,13 @@ dl_feature_check_startup (struct link_map *m,
+   else
+     info->enable_feature_1 &= ~GNU_PROPERTY_X86_FEATURE_1_SHSTK;
+ 
++  /* Check LAM compatibility before deciding how LAM should be enabled.
++     LAM always_on is handled in dl_check_legacy_object.  */
+   if (info->enable_feature_1 != 0)
+-    dl_check_legacy_object (m, info);
++    {
++      dl_check_legacy_object (m, info);
++      dl_check_lam (m, info);
++    }
+ 
+   unsigned int disable_feature_1
+     = info->enable_feature_1 ^ info->feature_1_enabled;
+@@ -177,8 +282,8 @@ dl_feature_check_startup (struct link_map *m,
+ 	_dl_fatal_printf ("%s: can't disable x86 Features\n",
+ 			  info->program);
+ 
+-      /* Clear the disabled bits.  Sync dl_x86_feature_1 and
+-         info->feature_1_enabled with info->enable_feature_1.  */
++      /* Sync dl_x86_feature_1 and info->feature_1_enabled with
++         info->enable_feature_1.  */
+       info->feature_1_enabled = info->enable_feature_1;
+       GL(dl_x86_feature_1) = info->enable_feature_1;
+     }
+@@ -206,7 +311,7 @@ dl_feature_check_startup (struct link_map *m,
+ 	_dl_fatal_printf ("%s: can't lock CET\n", info->program);
+     }
+ 
+-  THREAD_SETMEM (THREAD_SELF, header.feature_1, GL(dl_x86_feature_1));
++  dl_update_x86_feature_1 (GL(dl_x86_feature_1));
+ }
+ #endif
+ 
+@@ -260,6 +365,24 @@ dl_feature_check_dlopen (struct link_map *m,
+         disable_feature_1 |= GNU_PROPERTY_X86_FEATURE_1_SHSTK;
+     }
+ 
++#if LAM_ENABLED
++  if (msg == NULL
++      && ((info->feature_1_enabled
++	   & GNU_PROPERTY_X86_FEATURE_1_LAM_MASK) != 0)
++      && ((info->feature_1_legacy
++	   & GNU_PROPERTY_X86_FEATURE_1_LAM_MASK) != 0))
++    {
++      /* Disable LAM since the object isn't LAM compatible.  */
++      if (info->enable_lam_type != x86_feature_permissive)
++	{
++	  legacy_obj = info->feature_1_legacy_lam;
++	  msg = N_("rebuild shared object with LAM support enabled");
++	}
++      else
++	disable_feature_1 |= GNU_PROPERTY_X86_FEATURE_1_LAM_MASK;
++    }
++#endif
++
+   /* If there is an error, long jump back to the caller.  */
+   if (msg != NULL)
+     _dl_signal_error (0, m->l_initfini[legacy_obj]->l_name, "dlopen",
+@@ -273,46 +396,204 @@ dl_feature_check_dlopen (struct link_map *m,
+ 	  if ((disable_feature_1
+ 	       & GNU_PROPERTY_X86_FEATURE_1_IBT) != 0)
+ 	    msg = N_("can't disable IBT");
+-	  else
++	  else if ((disable_feature_1
++	       & GNU_PROPERTY_X86_FEATURE_1_SHSTK) != 0)
+ 	    msg = N_("can't disable SHSTK");
++	  /* Disable LAM case.  */
++	  else if ((disable_feature_1
++	       & GNU_PROPERTY_X86_FEATURE_1_LAM_MASK) != 0)
++	    msg = N_("can't disable LAM");
++	  /* Disable LAM_U48 case.  */
++	  else
++	    msg = N_("can't disable LAM_U48");
++
+ 	  /* Long jump back to the caller on error.  */
+ 	  _dl_signal_error (-res, m->l_initfini[legacy_obj]->l_name,
+ 			    "dlopen", msg);
+        }
+ 
+-      /* Clear the disabled bits in dl_x86_feature_1.  */
+-      GL(dl_x86_feature_1) &= ~disable_feature_1;
++      /* Clear the disabled bits.  */
++      info->feature_1_enabled &= ~disable_feature_1;
+ 
+-      THREAD_SETMEM (THREAD_SELF, header.feature_1,
+-		     GL(dl_x86_feature_1));
++      /* Sync dl_x86_feature_1 with info->feature_1_enabled.  */
++      GL(dl_x86_feature_1) = info->feature_1_enabled;
++      dl_update_x86_feature_1 (info->feature_1_enabled);
+     }
+ }
+ 
++#if LAM_ENABLED && HAVE_TUNABLES
++/* Enable LAM for user.  This function return 0 if it successfully
++   enable LAM for user.  In case of failure, it returns EPERM, ENODEV or
++   EOPNOTSUPP.  */
++
++static int
++_dl_enable_lam_for_user (unsigned int lam_enabled)
++{
++  unsigned int enable_lam = lam_enabled;
++  bool try_lam_u57 = false;
++  bool lam_already_enabled = !!GL(dl_x86_feature_control).lam_already;
++
++  /* LAM size != lam_default indicates that LAM size is set via
++     tunables.  */
++  switch (GL(dl_x86_feature_control).lam_size)
++    {
++    case lam_default:
++      /* If LAM isn't enabled by kernel and user doesn't specify LAM
++	 size, default to LAM_U48.  If LAM_U48 can't be enabled, try
++	 LAM_U57.  */
++      if (enable_lam == 0)
++	{
++	  enable_lam = GNU_PROPERTY_X86_FEATURE_1_LAM_U48;
++	  try_lam_u57 = true;
++	}
++      break;
++    case lam_u48:
++      /* LAM_U48 is enabled by glibc LAM size tunables.  */
++      enable_lam = GNU_PROPERTY_X86_FEATURE_1_LAM_U48;
++      break;
++    case lam_u57:
++      /* LAM_U57 is enabled by glibc LAM size tunables.  */
++      enable_lam = GNU_PROPERTY_X86_FEATURE_1_LAM_U57;
++      break;
++    }
++
++  if (lam_enabled != enable_lam)
++    {
++      if (!lam_already_enabled)
++	{
++	  /* Enable LAM if needed.  */
++	  if (!HAS_CPU_FEATURE (LAM))
++	    return ENODEV;
++
++	  int res = dl_feature_1_enable (enable_lam);
++	  if (res != 0)
++	    {
++	      if (try_lam_u57)
++		{
++		  enable_lam = GNU_PROPERTY_X86_FEATURE_1_LAM_U57;
++		  res = dl_feature_1_enable (enable_lam);
++		  if (res == 0)
++		    goto done;
++		}
++
++	      return -res;
++	    }
++	}
++
++done:
++      /* Update dl_x86_feature_1.  Clear the LAM mask first.  */
++      GL(dl_x86_feature_1) &= ~GNU_PROPERTY_X86_FEATURE_1_LAM_MASK;
++      GL(dl_x86_feature_1) |= enable_lam;
++    }
++
++  return 0;
++}
++#endif
++
++/* Sync dl_x86_feature_1 with the feature enabled argument and tunables.
++   Returns the updated enabled feature mask.  */
++DL_SYNC_X86_FEATURE_1_LINKAGE int
++_dl_sync_x86_feature_1 (unsigned int feature_1_enabled
++			DL_SYNC_X86_FEATURE_1_PARM)
++{
++#if LAM_ENABLED && HAVE_TUNABLES
++  /* LAM size tunables only takes effect if LAM feature type is
++     x86_feature_always_on.  For all other types, LAM size tunables
++     will be silently ignored.
++
++     NB: LAM in static executable can be disabled by
++
++     GLIBC_TUNABLES=glibc.cpu.hwcaps=-LAM
++   */
++  int status;
++
++  if (GL(dl_x86_feature_control).lam == x86_feature_always_off)
++    {
++      /* User requests to disable LAM.  */
++      if ((feature_1_enabled
++	   & GNU_PROPERTY_X86_FEATURE_1_LAM_MASK) != 0)
++	{
++	  status = dl_feature_1_disable
++	    (GNU_PROPERTY_X86_FEATURE_1_LAM_MASK);
++	  if (status != 0)
++# ifdef SHARED
++	    _dl_fatal_printf ("%s: can't disable LAM\n", program);
++# else
++	    __libc_fatal ("Can't disable LAM\n");
++# endif
++	  /* Sync dl_x86_feature_1 and feature_1_enabled.  */
++	  feature_1_enabled
++	    &= ~GNU_PROPERTY_X86_FEATURE_1_LAM_MASK;
++	  GL(dl_x86_feature_1) = feature_1_enabled;
++	}
++    }
++  else if (GL(dl_x86_feature_control).lam == x86_feature_always_on)
++    {
++      status = _dl_enable_lam_for_user (feature_1_enabled);
++      if (status != 0)
++	{
++# ifdef SHARED
++	  if (status == ENODEV)
++	    _dl_fatal_printf ("%s: CPU is not LAM capable\n",
++			      program);
++	  else
++	    _dl_fatal_printf ("%s: can't enable LAM: %d\n",
++			      program, status);
++# else
++	  if (status == ENODEV)
++	    __libc_fatal ("CPU is not LAM capable\n");
++	  else
++	    __libc_fatal ("Can't enable LAM: %d\n");
++# endif
++	}
++      /* Sync feature_1_enabled with dl_x86_feature_1.  */
++      feature_1_enabled = GL(dl_x86_feature_1);
++    }
++#else
++  /* Sync dl_x86_feature_1 with feature_1_enabled.  */
++  GL(dl_x86_feature_1) = feature_1_enabled;
++#endif
++  return feature_1_enabled;
++}
++
+ static void
+ dl_feature_check (struct link_map *m, const char *program)
+ {
+   struct dl_feature_info info;
+ 
+-  /* Check how IBT and SHSTK should be enabled. */
++  /* Check how IBT, SHSTK and LAM should be enabled.  */
+   info.enable_ibt_type = GL(dl_x86_feature_control).ibt;
+   info.enable_shstk_type = GL(dl_x86_feature_control).shstk;
++  info.enable_lam_type = GL(dl_x86_feature_control).lam;
+ 
+   info.feature_1_enabled = GL(dl_x86_feature_1);
+ 
+-  /* No legacy object check if IBT and SHSTK are always on.  */
++#ifdef SHARED
++  if (program != NULL)
++    {
++      /* x86_feature_elf_property and x86_feature_permissive are handled
++	 in dl_feature_check_startup which is called later.  */
++
++      info.feature_1_enabled = _dl_sync_x86_feature_1
++	(info.feature_1_enabled, program);
++    }
++#endif
++
++  /* No legacy object check if IBT, SHSTK and LAM are always on.  */
+   if (info.enable_ibt_type == x86_feature_always_on
+-      && info.enable_shstk_type == x86_feature_always_on)
++      && info.enable_shstk_type == x86_feature_always_on
++      && (!LAM_ENABLED
++	  || info.enable_lam_type == x86_feature_always_on))
+     {
+ #ifdef SHARED
+-      /* Set it only during startup.  */
++      /* Update x86_feature_1 only during startup.  */
+       if (program != NULL)
+-	THREAD_SETMEM (THREAD_SELF, header.feature_1,
+-		       info.feature_1_enabled);
++	dl_update_x86_feature_1 (info.feature_1_enabled);
+ #endif
+       return;
+     }
+ 
+-  /* Check if IBT and SHSTK were enabled by kernel.  */
++  /* Check if IBT, SHSTK and LAM were enabled by kernel.  */
+   if (info.feature_1_enabled == 0)
+     return;
+ 
+@@ -326,11 +607,19 @@ dl_feature_check (struct link_map *m, const char *program)
+   if (info.enable_shstk_type != x86_feature_always_off)
+     info.enable_feature_1 |= (info.feature_1_enabled
+ 			      & GNU_PROPERTY_X86_FEATURE_1_SHSTK);
++  if (info.enable_lam_type != x86_feature_always_off)
++    info.enable_feature_1 |= (info.feature_1_enabled
++			      & GNU_PROPERTY_X86_FEATURE_1_LAM_MASK);
+ 
+   /* Start with no legacy objects.  */
+   info.feature_1_legacy = 0;
+   info.feature_1_legacy_ibt = 0;
+   info.feature_1_legacy_shstk = 0;
++  info.feature_1_legacy_lam = 0;
++
++  /* Start with LAM compatible.  */
++  info.feature_1_lam = (info.feature_1_enabled
++			& GNU_PROPERTY_X86_FEATURE_1_LAM_MASK);
+ 
+ #ifdef SHARED
+   if (program)
+diff --git a/sysdeps/x86/dl-prop.h b/sysdeps/x86/dl-prop.h
+index 5358086a64..1b5777e6c2 100644
+--- a/sysdeps/x86/dl-prop.h
++++ b/sysdeps/x86/dl-prop.h
+@@ -156,7 +156,16 @@ _dl_process_property_note (struct link_map *l, const ElfW(Nhdr) *note,
+ 				  "GNU_PROPERTY_X86_ISA_1_NEEDED > "
+ 				  "GNU_PROPERTY_X86_FEATURE_1_AND");
+ 		  if (type == GNU_PROPERTY_X86_FEATURE_1_AND)
+-		    feature_1_and = *(unsigned int *) ptr;
++		    {
++		      feature_1_and = *(unsigned int *) ptr;
++#if LAM_ENABLED
++		      /* LAM_U48 implies LAM_U57.  */
++		      if ((feature_1_and
++			   & GNU_PROPERTY_X86_FEATURE_1_LAM_U48) != 0)
++			feature_1_and
++			  |= GNU_PROPERTY_X86_FEATURE_1_LAM_U57;
++#endif
++		    }
+ 		  else
+ 		    {
+ 		      isa_1_needed = *(unsigned int *) ptr;
+diff --git a/sysdeps/x86/feature-control.h b/sysdeps/x86/feature-control.h
+index 000bca0597..46764ac4fb 100644
+--- a/sysdeps/x86/feature-control.h
++++ b/sysdeps/x86/feature-control.h
+@@ -19,6 +19,8 @@
+ #ifndef _FEATURE_CONTROL_H
+ #define _FEATURE_CONTROL_H
+ 
++#include <tls.h>
++
+ /* For each x86 feature, IBT, SHSTK and LAM, valid control values.  */
+ enum dl_x86_feature_control_enum
+ {
+@@ -52,4 +54,42 @@ struct dl_x86_feature_control
+   unsigned int lam_already : 1;
+ };
+ 
++#ifndef SHARED
++extern int _dl_sync_x86_feature_1 (unsigned int)
++  __attribute__ ((visibility ("hidden")));
++#endif
++
++# if X86_FEATURE_ENABLED
++static inline void
++dl_update_x86_feature_1 (unsigned int feature_1)
++{
++  THREAD_SETMEM (THREAD_SELF, header.feature_1, feature_1);
++
++# if LAM_ENABLED
++  /* Update header.lam_address_bits and header.lam_mask based on
++     FEATURE_1.  */
++  unsigned lam_address_bits;
++  uintptr_t lam_mask;
++  if ((feature_1 & GNU_PROPERTY_X86_FEATURE_1_LAM_U48) != 0)
++    {
++      lam_address_bits = 48;
++      lam_mask = (1ULL << 48) - 1;
++    }
++  else if ((feature_1 & GNU_PROPERTY_X86_FEATURE_1_LAM_U57) != 0)
++    {
++      lam_address_bits = 57;
++      lam_mask = (1ULL << 57) - 1;
++    }
++  else
++    {
++      /* Hardware doesn't support LAM or it's disabled.  */
++      lam_address_bits = 64;
++      lam_mask = -1;
++    }
++  THREAD_SETMEM (THREAD_SELF, header.lam_address_bits, lam_address_bits);
++  THREAD_SETMEM (THREAD_SELF, header.lam_mask, lam_mask);
++# endif
++}
++#endif
++
+ #endif /* feature-control.h */
+diff --git a/sysdeps/x86/nptl/tls-setup.h b/sysdeps/x86/nptl/tls-setup.h
+index d922439dd7..8bbbda022b 100644
+--- a/sysdeps/x86/nptl/tls-setup.h
++++ b/sysdeps/x86/nptl/tls-setup.h
+@@ -20,4 +20,7 @@ static inline void __attribute__ ((always_inline))
+ tls_setup_tcbhead (struct pthread *pd)
+ {
+   pd->header.feature_1 = THREAD_GETMEM (THREAD_SELF, header.feature_1);
++#if LAM_ENABLED
++  pd->header.lam_mask = THREAD_GETMEM (THREAD_SELF, header.lam_mask);
++#endif
+ }
+diff --git a/sysdeps/x86/sysdep.h b/sysdeps/x86/sysdep.h
+index 5f9b90f655..3c00eb0788 100644
+--- a/sysdeps/x86/sysdep.h
++++ b/sysdeps/x86/sysdep.h
+@@ -57,6 +57,10 @@ enum cf_protection_level
+   (GNU_PROPERTY_X86_FEATURE_1_IBT \
+    | GNU_PROPERTY_X86_FEATURE_1_SHSTK \
+    | GNU_PROPERTY_X86_FEATURE_1_LAM_MASK)
++/* This macro defines valid feature bits for the option,
++   ARCH_X86_FEATURE_1_ENABLE, in arch_prctl.  */
++#define GNU_PROPERTY_X86_FEATURE_1_ENABLE_MASK \
++  GNU_PROPERTY_X86_FEATURE_1_LAM_MASK
+ 
+ /* Offset for fxsave/xsave area used by _dl_runtime_resolve.  Also need
+    space to preserve RCX, RDX, RSI, RDI, R8, R9 and RAX.  It must be
+diff --git a/sysdeps/x86_64/64/inline-tagged-address.h b/sysdeps/x86_64/64/inline-tagged-address.h
+new file mode 100644
+index 0000000000..ba2b9d77cf
+--- /dev/null
++++ b/sysdeps/x86_64/64/inline-tagged-address.h
+@@ -0,0 +1,66 @@
++/* Inline tagged address functions.  x86-64 version.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#if LAM_ENABLED
++# include <errno.h>
++# include <tls.h>
++
++static inline unsigned int
++__get_tagged_address_bits (void)
++{
++  return THREAD_GETMEM (THREAD_SELF, header.lam_address_bits);
++}
++
++static inline uintptr_t
++__get_tagged_address_mask (void)
++{
++  return THREAD_GETMEM (THREAD_SELF, header.lam_mask);
++}
++
++static inline void *
++tag_address_helper (void *addr, unsigned int tag, uintptr_t mask,
++		    unsigned int shift)
++{
++  uintptr_t val = (uintptr_t) addr;
++  val &= mask;
++  val |= ((uintptr_t) tag) << shift;
++  return (void *) val;
++}
++
++static inline void *
++__tag_address (void *addr, unsigned int tag)
++{
++  unsigned int shift = THREAD_GETMEM (THREAD_SELF,
++				      header.lam_address_bits);
++  if (shift == 64)
++    return addr;
++  uintptr_t lam_mask = THREAD_GETMEM (THREAD_SELF, header.lam_mask);
++  return tag_address_helper (addr, tag, lam_mask, shift);
++}
++
++static inline void *
++__untag_address (void *addr)
++{
++  uintptr_t val = (uintptr_t) addr;
++  uintptr_t lam_mask = THREAD_GETMEM (THREAD_SELF, header.lam_mask);
++  val &= lam_mask;
++  return (void *) val;
++}
++#else
++# include_next <inline-tagged-address.h>
++#endif
+diff --git a/sysdeps/x86_64/64/set-tagged-address-mask.c b/sysdeps/x86_64/64/set-tagged-address-mask.c
+new file mode 100644
+index 0000000000..563d798c5f
+--- /dev/null
++++ b/sysdeps/x86_64/64/set-tagged-address-mask.c
+@@ -0,0 +1,114 @@
++/* Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <stdbool.h>
++#include <elf.h>
++#include <errno.h>
++#include <ldsodefs.h>
++#include <dl-feature.h>
++#include <sys/tagged-address.h>
++
++/* Set the mask for address bits used in address translation.  Return 0
++   on success.  Return -1 on error.  */
++
++int
++set_tagged_address_mask (uintptr_t mask)
++{
++  if (GL(dl_tagged_address_mask_locked) != 0)
++    {
++      __set_errno (EPERM);
++      return -1;
++    }
++
++  /* set_tagged_address_mask can only be called once.  */
++  GL(dl_tagged_address_mask_locked) = 1;
++
++#if LAM_ENABLED
++  bool enable_mask;
++  unsigned int x86_feature_1 = GL(dl_x86_feature_1);
++  unsigned int feature_1 = x86_feature_1;
++
++  /* Check if address mask should be disabled.  */
++  if (mask == (uintptr_t) -1)
++    enable_mask = false;
++  else
++    {
++      /* Check for invalid address mask.  */
++      if (mask == TAGGED_ADDRESS_MASK (48))
++	feature_1 = GNU_PROPERTY_X86_FEATURE_1_LAM_U48;
++      else if (mask == TAGGED_ADDRESS_MASK (57))
++	feature_1 = GNU_PROPERTY_X86_FEATURE_1_LAM_U57;
++      else
++	{
++	  __set_errno (EINVAL);
++	  return -1;
++	}
++      enable_mask = true;
++    }
++
++  int res = 0;
++
++  if (enable_mask)
++    {
++      /* Do nothing only if we are asked to enable LAM_U57 and it has
++	 been enabled already.  */
++      if (feature_1 != GNU_PROPERTY_X86_FEATURE_1_LAM_U57
++	  || GL(dl_x86_feature_control).lam_already == 0
++	  || GL(dl_x86_feature_control).lam_size != lam_u57)
++	res = dl_feature_1_enable (feature_1);
++    }
++  else
++    {
++      /* Do nothing if LAM isn't enabled.  */
++      if ((feature_1 & GNU_PROPERTY_X86_FEATURE_1_LAM_MASK) != 0)
++	res = dl_feature_1_disable (feature_1);
++    }
++
++  if (res != 0)
++    {
++      __set_errno (-res);
++      return -1;
++    }
++
++  if ((feature_1 & GNU_PROPERTY_X86_FEATURE_1_LAM_MASK) != 0)
++    {
++      /* Clear the LAM mask first.   */
++      x86_feature_1 &= ~GNU_PROPERTY_X86_FEATURE_1_LAM_MASK;
++      if (enable_mask)
++	x86_feature_1 |= feature_1;
++    }
++  else
++    {
++      if (enable_mask)
++	x86_feature_1 |= feature_1;
++      else
++	x86_feature_1 &= ~feature_1;
++    }
++
++  GL(dl_x86_feature_1) = x86_feature_1;
++  dl_update_x86_feature_1 (x86_feature_1);
++
++  return 0;
++#else
++  /* Only NOP is allowed.  */
++  if (mask == __get_tagged_address_mask ())
++    return 0;
++
++  __set_errno (ENOSYS);
++  return -1;
++#endif
++}
+diff --git a/sysdeps/x86_64/nptl/tcb-offsets.sym b/sysdeps/x86_64/nptl/tcb-offsets.sym
+index 2bbd563a6c..af789ef6ad 100644
+--- a/sysdeps/x86_64/nptl/tcb-offsets.sym
++++ b/sysdeps/x86_64/nptl/tcb-offsets.sym
+@@ -13,6 +13,9 @@ MULTIPLE_THREADS_OFFSET	offsetof (tcbhead_t, multiple_threads)
+ POINTER_GUARD		offsetof (tcbhead_t, pointer_guard)
+ FEATURE_1_OFFSET	offsetof (tcbhead_t, feature_1)
+ SSP_BASE_OFFSET		offsetof (tcbhead_t, ssp_base)
++#ifndef __ILP32__
++LAM_MASK_OFFSET		offsetof (tcbhead_t, lam_mask)
++#endif
+ 
+ -- Not strictly offsets, but these values are also used in the TCB.
+ TCB_CANCELED_BITMASK	 CANCELED_BITMASK
+diff --git a/sysdeps/x86_64/nptl/tls.h b/sysdeps/x86_64/nptl/tls.h
+index a78c4f4d01..c41fad7374 100644
+--- a/sysdeps/x86_64/nptl/tls.h
++++ b/sysdeps/x86_64/nptl/tls.h
+@@ -55,7 +55,16 @@ typedef struct
+      Bit 1: X86_FEATURE_1_SHSTK.
+    */
+   unsigned int feature_1;
++# ifdef __ILP32__
+   int __glibc_unused1;
++# else
++  /* Linear Address Masking (LAM) address bits:
++      None   : 64
++      LAM_U48: 48
++      LAM_U57: 57
++   */
++  unsigned int lam_address_bits;
++# endif
+   /* Reservation of some values for the TM ABI.  */
+   void *__private_tm[4];
+   /* GCC split stack support.  */
+@@ -66,7 +75,17 @@ typedef struct
+      like AddressSanitizer, depend on the size of tcbhead_t.  */
+   __128bits __glibc_unused2[8][4] __attribute__ ((aligned (32)));
+ 
++# ifdef __ILP32__
+   void *__padding[8];
++# else
++  /* Linear Address Masking (LAM) mask:
++      None   : -1ULL
++      LAM_U48: ((1ULL << 48) - 1)
++      LAM_U57: ((1ULL << 57) - 1)
++   */
++  uintptr_t lam_mask;
++  void *__padding[7];
++# endif
+ } tcbhead_t;
+ 
+ # ifdef __ILP32__
+@@ -138,6 +157,15 @@ _Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
+ # define GET_DTV(descr) \
+   (((tcbhead_t *) (descr))->dtv)
+ 
++/* Initialize lam_address_bits to 64 and lam_mask to -1 since the initial
++   value of feature_1 is 0.  */
++# if LAM_ENABLED
++#  define TLS_INIT_LAM(head) \
++  (head)->lam_address_bits = 64; \
++  (head)->lam_mask = -1;
++# else
++#  define TLS_INIT_LAM(head)
++# endif
+ 
+ /* Code to initially initialize the thread pointer.  This might need
+    special attention since 'errno' is not yet available and if the
+@@ -154,6 +182,8 @@ _Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
+      /* For now the thread descriptor is at the same address.  */	      \
+      _head->self = _thrdescr;						      \
+ 									      \
++     TLS_INIT_LAM (_head);						      \
++									      \
+      /* It is a simple syscall to set the %fs value for the thread.  */	      \
+      asm volatile ("syscall"						      \
+ 		   : "=a" (_result)					      \
+-- 
+2.31.1
+
diff --git a/0020-Backport-x86-Enable-LAM-feature.patch b/0020-Backport-x86-Enable-LAM-feature.patch
new file mode 100644
index 0000000..8593213
--- /dev/null
+++ b/0020-Backport-x86-Enable-LAM-feature.patch
@@ -0,0 +1,268 @@
+From 533c885353ccd253222dce902744e42be6eaca20 Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Sat, 30 Jan 2021 20:55:57 -0800
+Subject: [PATCH 20/24] Backport x86: Enable LAM feature
+
+1. Remove <sys/tagged-address.h> manual.
+2. Move functions provided in <sys/tagged-address.h> from libc.so to
+libc_nonshared.a.  Removed them from misc/Versions and libc.abilist
+files.
+3. Use the global errno in set-tagged-address-mask.c.
+4. Remove __GI_memmove, __GI_memset and __GI_memcpy from
+set-tagged-address-mask.oS in libc_nonshared.a.
+---
+ manual/Makefile                               |  3 +-
+ manual/ctype.texi                             |  2 +-
+ manual/memory.texi                            |  2 +-
+ manual/tagged-address.texi                    | 67 -------------------
+ misc/Versions                                 |  7 --
+ misc/set-tagged-address-mask.c                |  6 ++
+ sysdeps/generic/symbol-hacks.h                |  2 +
+ sysdeps/unix/sysv/linux/i386/libc.abilist     |  5 --
+ .../unix/sysv/linux/x86_64/64/libc.abilist    |  5 --
+ .../unix/sysv/linux/x86_64/x32/libc.abilist   |  5 --
+ sysdeps/x86/Makefile                          |  9 +++
+ sysdeps/x86_64/64/set-tagged-address-mask.c   |  6 ++
+ 12 files changed, 26 insertions(+), 93 deletions(-)
+ delete mode 100644 manual/tagged-address.texi
+
+diff --git a/manual/Makefile b/manual/Makefile
+index 08df2daa6b..e83444341e 100644
+--- a/manual/Makefile
++++ b/manual/Makefile
+@@ -34,8 +34,7 @@ info: $(objpfx)libc.info
+ endif
+ 
+ chapters = $(addsuffix .texi, \
+-		       intro errno memory tagged-address ctype string	\
+-		       charset locale					\
++		       intro errno memory ctype string charset locale	\
+ 		       message search pattern io stdio llio filesys	\
+ 		       pipe socket terminal syslog math arith time	\
+ 		       resource setjmp signal startup process ipc job	\
+diff --git a/manual/ctype.texi b/manual/ctype.texi
+index 28af73ff0e..d0618c5c38 100644
+--- a/manual/ctype.texi
++++ b/manual/ctype.texi
+@@ -1,4 +1,4 @@
+-@node Character Handling, String and Array Utilities, Tagged Address, Top
++@node Character Handling, String and Array Utilities, Memory, Top
+ @c %MENU% Character testing and conversion functions
+ @chapter Character Handling
+ 
+diff --git a/manual/memory.texi b/manual/memory.texi
+index 4791c7c464..b2cc65228a 100644
+--- a/manual/memory.texi
++++ b/manual/memory.texi
+@@ -1,4 +1,4 @@
+-@node Memory, Tagged Address, Error Reporting, Top
++@node Memory, Character Handling, Error Reporting, Top
+ @chapter Virtual Memory Allocation And Paging
+ @c %MENU% Allocating virtual memory and controlling paging
+ @cindex memory allocation
+diff --git a/manual/tagged-address.texi b/manual/tagged-address.texi
+deleted file mode 100644
+index 703c38a15d..0000000000
+--- a/manual/tagged-address.texi
++++ /dev/null
+@@ -1,67 +0,0 @@
+-@node Tagged Address, Character Handling, Memory, Top
+-@c %MENU% Tagged address functions and macros
+-@chapter Tagged Address
+-
+-By default, the number of the address bits used in address translation
+-is the number of address bits.  But it can be changed by ARM Top-byte
+-Ignore (TBI) or Intel Linear Address Masking (LAM).
+-
+-@Theglibc{} provides several functions and macros in the header file
+-@file{sys/tagged-address.h} to manipulate tagged address bits, which is
+-the number of the address bits used in address translation.
+-@pindex sys/tagged-address.h
+-
+-@deftypefun {unsigned int} get_tagged_address_bits (void)
+-@standards{GNU, sys/tagged-address.h}
+-@safety{@prelim{}@mtsafe{}@assafe{}@acsafe{}}
+-Get the current address bits used in address translation.  The return
+-value is @code{0} if tag bits are not the highest bits in addresses.  The
+-return value is the number of address bits when tagged address is
+-unsupported.
+-@end deftypefun
+-
+-@deftypefun uintptr_t get_tagged_address_mask (void)
+-@standards{GNU, sys/tagged-address.h}
+-@safety{@prelim{}@mtsafe{}@assafe{}@acsafe{}}
+-Get the current mask for address bits used in address translation.  If a
+-bit is set in the return value, this bit is used in address translation.
+-The return value is @code{-1} when all bits are used in address
+-translation.
+-@end deftypefun
+-
+-@deftypefun int set_tagged_address_mask (uintptr_t @var{mask})
+-@standards{GNU, sys/tagged-address.h}
+-@safety{@prelim{}@mtsafe{}@assafe{}@acsafe{}}
+-Set the mask for address bits used in address translation to @var{mask}.
+-Only bits set in @var{mask} will be used in address translation.  The
+-return value is @code{0} on success and @code{-1} on failure.  This
+-function can be called only once before @code{main}.  The possible
+-@code{errno} error conditions are @code{ENODEV}, @code{EPERM},
+-@code{EINVAL}, and @code{ENOSYS}.
+-@end deftypefun
+-
+-@deftypefun {void *} tag_address (void *@var{addr}, unsigned int @var{tag})
+-@standards{GNU, sys/tagged-address.h}
+-@safety{@prelim{}@mtsafe{}@assafe{}@acsafe{}}
+-Return the address of @var{addr} with the tag value @var{tag} stored
+-in the untranslated bits.  Overflow of @var{tag} in the untranslated
+-bits are ignored.
+-@end deftypefun
+-
+-@deftypefun {void *} untag_address (void *@var{addr})
+-@standards{GNU, sys/tagged-address.h}
+-@safety{@prelim{}@mtsafe{}@assafe{}@acsafe{}}
+-Return the address of @var{addr} with all zero untranslated bits.
+-@end deftypefun
+-
+-@deftypefn Macro int TAGGED_ADDRESS_VALID_BITS (@var{bits})
+-This macro returns a nonzero value (true) if @var{bits} is a valid
+-constant number of the lower address bits which can be used in address
+-translation.
+-@end deftypefn
+-
+-@deftypefn Macro {const uintptr_t} TAGGED_ADDRESS_MASK (@var{bits})
+-This macro returns a nonzero value which can be passed to
+-@code{set_tagged_address_mask} to specify the lower address @var{bits}
+-for address translation.
+-@end deftypefn
+diff --git a/misc/Versions b/misc/Versions
+index 9e9ded4d5c..95666f6548 100644
+--- a/misc/Versions
++++ b/misc/Versions
+@@ -164,13 +164,6 @@ libc {
+   GLIBC_2.32 {
+     __libc_single_threaded;
+   }
+-  GLIBC_2.34 {
+-    get_tagged_address_bits;
+-    get_tagged_address_mask;
+-    set_tagged_address_mask;
+-    tag_address;
+-    untag_address;
+-  }
+   GLIBC_PRIVATE {
+     __madvise;
+     __mktemp;
+diff --git a/misc/set-tagged-address-mask.c b/misc/set-tagged-address-mask.c
+index 2e1e2f2343..8eed3efc16 100644
+--- a/misc/set-tagged-address-mask.c
++++ b/misc/set-tagged-address-mask.c
+@@ -18,6 +18,12 @@
+ #include <sys/tagged-address.h>
+ #include <ldsodefs.h>
+ 
++/* NB: Use the global errno in libc_nonshared.a.  */
++#undef errno
++extern __thread int errno;
++#undef __set_errno
++#define __set_errno(n) errno = n
++
+ /* Set the mask for address bits used in address translation.  Return 0
+    on success.  Return -1 on error.  */
+ 
+diff --git a/sysdeps/generic/symbol-hacks.h b/sysdeps/generic/symbol-hacks.h
+index 3586e6ed38..713bed28e0 100644
+--- a/sysdeps/generic/symbol-hacks.h
++++ b/sysdeps/generic/symbol-hacks.h
+@@ -1,9 +1,11 @@
+ /* Some compiler optimizations may transform loops into memset/memmove
+    calls and without proper declaration it may generate PLT calls.  */
+ #if !defined __ASSEMBLER__ && IS_IN (libc) && defined SHARED
++# ifndef DISABLE_MEMFUNC_SYMBOL_HACK
+ asm ("memmove = __GI_memmove");
+ asm ("memset = __GI_memset");
+ asm ("memcpy = __GI_memcpy");
++# endif
+ 
+ /* Some targets do not use __stack_chk_fail_local.  In libc.so,
+    redirect __stack_chk_fail to a hidden reference
+diff --git a/sysdeps/unix/sysv/linux/i386/libc.abilist b/sysdeps/unix/sysv/linux/i386/libc.abilist
+index 464c8af2ee..ddc5837059 100644
+--- a/sysdeps/unix/sysv/linux/i386/libc.abilist
++++ b/sysdeps/unix/sysv/linux/i386/libc.abilist
+@@ -2241,11 +2241,6 @@ GLIBC_2.33 mknod F
+ GLIBC_2.33 mknodat F
+ GLIBC_2.33 stat F
+ GLIBC_2.33 stat64 F
+-GLIBC_2.34 get_tagged_address_bits F
+-GLIBC_2.34 get_tagged_address_mask F
+-GLIBC_2.34 set_tagged_address_mask F
+-GLIBC_2.34 tag_address F
+-GLIBC_2.34 untag_address F
+ GLIBC_2.4 __confstr_chk F
+ GLIBC_2.4 __fgets_chk F
+ GLIBC_2.4 __fgets_unlocked_chk F
+diff --git a/sysdeps/unix/sysv/linux/x86_64/64/libc.abilist b/sysdeps/unix/sysv/linux/x86_64/64/libc.abilist
+index 7486bf09bc..2744bba4af 100644
+--- a/sysdeps/unix/sysv/linux/x86_64/64/libc.abilist
++++ b/sysdeps/unix/sysv/linux/x86_64/64/libc.abilist
+@@ -2088,11 +2088,6 @@ GLIBC_2.33 mknod F
+ GLIBC_2.33 mknodat F
+ GLIBC_2.33 stat F
+ GLIBC_2.33 stat64 F
+-GLIBC_2.34 get_tagged_address_bits F
+-GLIBC_2.34 get_tagged_address_mask F
+-GLIBC_2.34 set_tagged_address_mask F
+-GLIBC_2.34 tag_address F
+-GLIBC_2.34 untag_address F
+ GLIBC_2.4 __confstr_chk F
+ GLIBC_2.4 __fgets_chk F
+ GLIBC_2.4 __fgets_unlocked_chk F
+diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/libc.abilist b/sysdeps/unix/sysv/linux/x86_64/x32/libc.abilist
+index d88202196f..ce2f4fb72b 100644
+--- a/sysdeps/unix/sysv/linux/x86_64/x32/libc.abilist
++++ b/sysdeps/unix/sysv/linux/x86_64/x32/libc.abilist
+@@ -2185,8 +2185,3 @@ GLIBC_2.33 mknod F
+ GLIBC_2.33 mknodat F
+ GLIBC_2.33 stat F
+ GLIBC_2.33 stat64 F
+-GLIBC_2.34 get_tagged_address_bits F
+-GLIBC_2.34 get_tagged_address_mask F
+-GLIBC_2.34 set_tagged_address_mask F
+-GLIBC_2.34 tag_address F
+-GLIBC_2.34 untag_address F
+diff --git a/sysdeps/x86/Makefile b/sysdeps/x86/Makefile
+index 343fecf1e8..6c3b626d5c 100644
+--- a/sysdeps/x86/Makefile
++++ b/sysdeps/x86/Makefile
+@@ -239,3 +239,12 @@ tests += \
+ tests-static += \
+   tst-sysconf-cache-linesize-static
+ endif
++
++ifeq ($(subdir),misc)
++# NB: Put <sys/tagged-address.h> in libc_nonshared.a to avoid version
++# GLIBC_2.34 dependency in glibc 2.33 backport.
++static-only-routines += tagged-address set-tagged-address-mask
++# NB: Compile <sys/tagged-address.h> in libc_nonshared.a with -DSHARED
++# to access GL(dl_x86_feature_1) in ld.so.
++CPPFLAGS-set-tagged-address-mask.oS += -DSHARED -DDISABLE_MEMFUNC_SYMBOL_HACK
++endif
+diff --git a/sysdeps/x86_64/64/set-tagged-address-mask.c b/sysdeps/x86_64/64/set-tagged-address-mask.c
+index 563d798c5f..249c158fa8 100644
+--- a/sysdeps/x86_64/64/set-tagged-address-mask.c
++++ b/sysdeps/x86_64/64/set-tagged-address-mask.c
+@@ -22,6 +22,12 @@
+ #include <dl-feature.h>
+ #include <sys/tagged-address.h>
+ 
++/* NB: Use the global errno in libc_nonshared.a.  */
++#undef errno
++extern __thread int errno;
++#undef __set_errno
++#define __set_errno(n) errno = n
++
+ /* Set the mask for address bits used in address translation.  Return 0
+    on success.  Return -1 on error.  */
+ 
+-- 
+2.31.1
+
diff --git a/0021-x86-Make-memmove-LAM-compliant.patch b/0021-x86-Make-memmove-LAM-compliant.patch
new file mode 100644
index 0000000..f69690b
--- /dev/null
+++ b/0021-x86-Make-memmove-LAM-compliant.patch
@@ -0,0 +1,131 @@
+From 766184154a5ea67b0721daa785ab8573f2e1a1fb Mon Sep 17 00:00:00 2001
+From: Sunil K Pandey <skpgkp2@gmail.com>
+Date: Fri, 29 Jan 2021 10:07:32 -0800
+Subject: [PATCH 21/24] x86: Make memmove LAM compliant
+
+Fix memmove pointer comparison for LAM enabling.
+---
+ .../multiarch/memmove-vec-unaligned-erms.S    | 61 +++++++++++++++++++
+ 1 file changed, 61 insertions(+)
+
+diff --git a/sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S b/sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
+index 5e4a071f16..9943865232 100644
+--- a/sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
++++ b/sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
+@@ -246,12 +246,28 @@ ENTRY (__memmove_erms)
+ 	jz	2f
+ L(start_movsb):
+ 	mov	%RDX_LP, %RCX_LP
++#  if LAM_ENABLED && !IS_IN (rtld)
++	movq	%rsi, %r10
++	movq	%rdi, %r11
++	andq	%fs:LAM_MASK_OFFSET, %r10
++	andq	%fs:LAM_MASK_OFFSET, %r11
++	cmpq	%r10, %r11
++#  else
+ 	cmp	%RSI_LP, %RDI_LP
++#  endif
+ 	jb	1f
+ 	/* Source == destination is less common.  */
+ 	je	2f
+ 	lea	(%rsi,%rcx), %RDX_LP
++#  if LAM_ENABLED && !IS_IN (rtld)
++	/* R11 is RDI with LAM mask applied.  RDI unmasking is skipped
++	   since there is no chage from previous mask computation.  */
++	movq	%rdx, %r10
++	andq	%fs:LAM_MASK_OFFSET, %r10
++	cmpq	%r10, %r11
++#  else
+ 	cmp	%RDX_LP, %RDI_LP
++#  endif
+ 	jb	L(movsb_backward)
+ 1:
+ 	rep movsb
+@@ -316,23 +332,53 @@ L(return):
+ L(movsb):
+ 	cmp     __x86_rep_movsb_stop_threshold(%rip), %RDX_LP
+ 	jae	L(more_8x_vec)
++# if LAM_ENABLED && !IS_IN (rtld)
++	movq	%rsi, %r8
++	movq	%rdi, %rcx
++	andq	%fs:LAM_MASK_OFFSET, %r8
++	andq	%fs:LAM_MASK_OFFSET, %rcx
++	cmpq	%r8, %rcx
++# else
+ 	cmpq	%rsi, %rdi
++# endif
+ 	jb	1f
+ 	/* Source == destination is less common.  */
+ 	je	L(nop)
+ 	leaq	(%rsi,%rdx), %r9
++# if LAM_ENABLED && !IS_IN (rtld)
++	/* RCX is RDI with LAM mask applied.  RDI unmasking is skipped
++	   since there is no chage from previous mask computation.  */
++	movq	%r9, %r10
++	andq	%fs:LAM_MASK_OFFSET, %r10
++	cmpq	%r10, %rcx
++# else
+ 	cmpq	%r9, %rdi
++# endif
+ 	/* Avoid slow backward REP MOVSB.  */
+ 	jb	L(more_8x_vec_backward)
+ # if AVOID_SHORT_DISTANCE_REP_MOVSB
++#  if LAM_ENABLED && !IS_IN (rtld)
++	/* R8 is RSI with LAM mask applied.  RCX is RDI with LAM mask
++	   appplied.  RSI and RDI unmasking are skipped since there are
++	   no changes from previous computation.  */
++	subq	%r8, %rcx
++#  else
+ 	movq	%rdi, %rcx
+ 	subq	%rsi, %rcx
++#  endif
+ 	jmp	2f
+ # endif
+ 1:
+ # if AVOID_SHORT_DISTANCE_REP_MOVSB
+ 	movq	%rsi, %rcx
++#  if LAM_ENABLED && !IS_IN (rtld)
++	movq	%rdi, %r10
++	andq	%fs:LAM_MASK_OFFSET, %r10
++	andq	%fs:LAM_MASK_OFFSET, %rcx
++	subq	%r10, %rcx
++#  else
+ 	subq	%rdi, %rcx
++#  endif
+ 2:
+ /* Avoid "rep movsb" if RCX, the distance between source and destination,
+    is N*4GB + [1..63] with N >= 0.  */
+@@ -461,7 +507,15 @@ L(more_8x_vec):
+ 	/* Entry if rdx is greater than non-temporal threshold but there
+        is overlap.  */
+ L(more_8x_vec_check):
++#if LAM_ENABLED && !IS_IN (rtld)
++	movq	%rsi, %r8
++	movq	%rdi, %r10
++	andq	%fs:LAM_MASK_OFFSET, %r8
++	andq	%fs:LAM_MASK_OFFSET, %r10
++	cmpq	%r8, %r10
++#else
+ 	cmpq	%rsi, %rdi
++#endif
+ 	ja	L(more_8x_vec_backward)
+ 	/* Source == destination is less common.  */
+ 	je	L(nop)
+@@ -567,7 +621,14 @@ L(large_memcpy_2x):
+ 	/* Compute absolute value of difference between source and
+ 	   destination.  */
+ 	movq	%rdi, %r9
++# if LAM_ENABLED && !IS_IN (rtld)
++	movq	%rsi, %r8
++	andq	%fs:LAM_MASK_OFFSET, %r8
++	andq	%fs:LAM_MASK_OFFSET, %r9
++	subq	%r8, %r9
++# else
+ 	subq	%rsi, %r9
++# endif
+ 	movq	%r9, %r8
+ 	leaq	-1(%r9), %rcx
+ 	sarq	$63, %r8
+-- 
+2.31.1
+
diff --git a/0022-Use-sys-tagged-address.h-in-some-LAM-tests.patch b/0022-Use-sys-tagged-address.h-in-some-LAM-tests.patch
new file mode 100644
index 0000000..f8e549e
--- /dev/null
+++ b/0022-Use-sys-tagged-address.h-in-some-LAM-tests.patch
@@ -0,0 +1,936 @@
+From 81cfc410bc6a0cf68f2303fd4900cf5e385b8532 Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Sat, 30 Jan 2021 20:21:23 -0800
+Subject: [PATCH 22/24] Use <sys/tagged-address.h> in some LAM tests
+
+1. Use address_with_tag () to tag addresses in string/test-memmove.c.
+2. Add tst-lam-1, tst-lam-1-static, tst-lam-2, tst-lam-3, tst-lam-4 and
+tst-lam-4-static.
+3. Add LAM_U57/LAM_U48/Legacy dlopen shared object compatibility tests.
+---
+ string/test-memmove.c                         | 16 +++-
+ sysdeps/x86_64/64/Makefile                    | 68 +++++++++++++++++
+ sysdeps/x86_64/64/tst-lam-1-static.c          |  1 +
+ sysdeps/x86_64/64/tst-lam-1.c                 | 74 +++++++++++++++++++
+ sysdeps/x86_64/64/tst-lam-2.c                 | 28 +++++++
+ sysdeps/x86_64/64/tst-lam-3.c                 | 28 +++++++
+ sysdeps/x86_64/64/tst-lam-4-static.c          |  1 +
+ sysdeps/x86_64/64/tst-lam-4.c                 | 51 +++++++++++++
+ sysdeps/x86_64/64/tst-lam-disabled.h          | 58 +++++++++++++++
+ sysdeps/x86_64/64/tst-lam-legacy-mod-1.c      | 26 +++++++
+ sysdeps/x86_64/64/tst-lam-u48-mod-1.c         | 28 +++++++
+ sysdeps/x86_64/64/tst-lam-u57-1.c             | 27 +++++++
+ sysdeps/x86_64/64/tst-lam-u57-1.h             | 60 +++++++++++++++
+ sysdeps/x86_64/64/tst-lam-u57-2.c             | 27 +++++++
+ sysdeps/x86_64/64/tst-lam-u57-3.c             | 27 +++++++
+ sysdeps/x86_64/64/tst-lam-u57-mod-1.c         | 30 ++++++++
+ sysdeps/x86_64/64/tst-lam-u57-mod-1.h         | 26 +++++++
+ sysdeps/x86_64/64/tst-lam-u57-pre.c           | 23 ++++++
+ sysdeps/x86_64/64/tst-lam-u57.sh              | 46 ++++++++++++
+ .../x86_64/64/tst-set-mask-lam-disabled-1.h   | 34 +++++++++
+ sysdeps/x86_64/64/tst-set-mask-lam-u57-1.h    | 34 +++++++++
+ 21 files changed, 712 insertions(+), 1 deletion(-)
+ create mode 100644 sysdeps/x86_64/64/tst-lam-1-static.c
+ create mode 100644 sysdeps/x86_64/64/tst-lam-1.c
+ create mode 100644 sysdeps/x86_64/64/tst-lam-2.c
+ create mode 100644 sysdeps/x86_64/64/tst-lam-3.c
+ create mode 100644 sysdeps/x86_64/64/tst-lam-4-static.c
+ create mode 100644 sysdeps/x86_64/64/tst-lam-4.c
+ create mode 100644 sysdeps/x86_64/64/tst-lam-disabled.h
+ create mode 100644 sysdeps/x86_64/64/tst-lam-legacy-mod-1.c
+ create mode 100644 sysdeps/x86_64/64/tst-lam-u48-mod-1.c
+ create mode 100644 sysdeps/x86_64/64/tst-lam-u57-1.c
+ create mode 100644 sysdeps/x86_64/64/tst-lam-u57-1.h
+ create mode 100644 sysdeps/x86_64/64/tst-lam-u57-2.c
+ create mode 100644 sysdeps/x86_64/64/tst-lam-u57-3.c
+ create mode 100644 sysdeps/x86_64/64/tst-lam-u57-mod-1.c
+ create mode 100644 sysdeps/x86_64/64/tst-lam-u57-mod-1.h
+ create mode 100644 sysdeps/x86_64/64/tst-lam-u57-pre.c
+ create mode 100755 sysdeps/x86_64/64/tst-lam-u57.sh
+ create mode 100644 sysdeps/x86_64/64/tst-set-mask-lam-disabled-1.h
+ create mode 100644 sysdeps/x86_64/64/tst-set-mask-lam-u57-1.h
+
+diff --git a/string/test-memmove.c b/string/test-memmove.c
+index 2e3ce75b9b..e2c3d7a0ed 100644
+--- a/string/test-memmove.c
++++ b/string/test-memmove.c
+@@ -24,6 +24,7 @@
+ # define TEST_NAME "memmove"
+ #endif
+ #include "test-string.h"
++#include <sys/tagged-address.h>
+ #include <support/test-driver.h>
+ 
+ char *simple_memmove (char *, const char *, size_t);
+@@ -52,7 +53,9 @@ inhibit_loop_to_libcall
+ simple_memmove (char *dst, const char *src, size_t n)
+ {
+   char *ret = dst;
+-  if (src < dst)
++  char *dst_without_tag = untag_address (dst);
++  char *src_without_tag = untag_address ((char *) src);
++  if (src_without_tag < dst_without_tag)
+     {
+       dst += n;
+       src += n;
+@@ -69,6 +72,9 @@ static void
+ do_one_test (impl_t *impl, char *dst, char *src, const char *orig_src,
+ 	     size_t len)
+ {
++  dst = tag_address (dst, 1);
++  src = tag_address (src, 2);
++
+   /* This also clears the destination buffer set by the previous run.  */
+   memcpy (src, orig_src, len);
+ #ifdef TEST_BCOPY
+@@ -161,6 +167,10 @@ do_random_tests (void)
+ 
+       p1 = buf1 + page_size - size;
+       p2 = buf2 + page_size - size;
++
++      p1 = tag_address (p1, 3);
++      p2 = tag_address (p2, 4);
++
+       c = random () & 255;
+       srcend = align1 + len + 256;
+       if (srcend > size)
+@@ -271,6 +281,8 @@ do_test2 (void)
+   size_t arr_size = bytes_move / sizeof (uint32_t);
+   size_t i;
+ 
++  large_buf = tag_address (large_buf, 5);
++
+   FOR_EACH_IMPL (impl, 0)
+     {
+       for (i = 0; i < arr_size; i++)
+@@ -278,6 +290,8 @@ do_test2 (void)
+ 
+       uint32_t * dst = &large_buf[33];
+ 
++      dst = tag_address (dst, 6);
++
+ #ifdef TEST_BCOPY
+       CALL (impl, (char *) large_buf, (char *) dst, bytes_move);
+ #else
+diff --git a/sysdeps/x86_64/64/Makefile b/sysdeps/x86_64/64/Makefile
+index 798affea1c..369522302e 100644
+--- a/sysdeps/x86_64/64/Makefile
++++ b/sysdeps/x86_64/64/Makefile
+@@ -4,3 +4,71 @@ lam-LDFLAGS = $(if $($(@F)-no-z-lam-u48),,-Wl,-z,lam-u48)
+ sysdep-LDFLAGS += $(lam-LDFLAGS)
+ LDFLAGS-rtld += $(lam-LDFLAGS)
+ endif
++
++ifeq ($(subdir),elf)
++tests += \
++  tst-lam-1 \
++  tst-lam-2 \
++  tst-lam-3 \
++  tst-lam-4 \
++  tst-lam-1-static \
++  tst-lam-4-static
++tests-static += \
++  tst-lam-1-static \
++  tst-lam-4-static
++
++ifneq ($(enable-lam),no)
++ifneq (no,$(have-tunables))
++tests += \
++  tst-lam-u57-pre \
++  tst-lam-u57-1 \
++  tst-lam-u57-2 \
++  tst-lam-u57-3
++
++modules-names += \
++  tst-lam-u48-mod-1 \
++  tst-lam-u57-mod-1 \
++  tst-lam-legacy-mod-1
++
++tst-lam-u57-1-no-z-lam-u48 = yes
++tst-lam-u57-2-no-z-lam-u48 = yes
++tst-lam-u57-3-no-z-lam-u48 = yes
++tst-lam-u57-mod-1.so-no-z-lam-u48 = yes
++tst-lam-legacy-mod-1.so-no-z-lam-u48 = yes
++LDFLAGS-tst-lam-u57-1 = -Wl,-z,lam-u57
++LDFLAGS-tst-lam-u57-2 = -Wl,-z,lam-u57
++LDFLAGS-tst-lam-u57-3 = -Wl,-z,lam-u57
++LDFLAGS-tst-lam-u57-mod-1.so = -Wl,-z,lam-u57
++
++tst-lam-u57-1-ENV = GLIBC_TUNABLES=glibc.cpu.x86_64_lam=on:glibc.cpu.x86_64_lam_size=57
++$(objpfx)tst-lam-u57-1: $(libdl)
++$(objpfx)tst-lam-u57-1.out: $(..)sysdeps/x86_64/64/tst-lam-u57.sh \
++			    $(objpfx)tst-lam-u57-1 \
++			    $(objpfx)tst-lam-u57-pre \
++			    $(objpfx)tst-lam-u57-mod-1.so
++	$(SHELL) $< $(common-objpfx) '$(test-wrapper-env)' \
++		 '$(run-program-env)' '$(word 2,$^)'; \
++	$(evaluate-test)
++
++tst-lam-u57-2-ENV = GLIBC_TUNABLES=glibc.cpu.x86_64_lam=on:glibc.cpu.x86_64_lam_size=57
++$(objpfx)tst-lam-u57-2: $(libdl)
++$(objpfx)tst-lam-u57-2.out: $(..)sysdeps/x86_64/64/tst-lam-u57.sh \
++			    $(objpfx)tst-lam-u57-2 \
++			    $(objpfx)tst-lam-u57-pre \
++			    $(objpfx)tst-lam-u48-mod-1.so
++	$(SHELL) $< $(common-objpfx) '$(test-wrapper-env)' \
++		 '$(run-program-env)' '$(word 2,$^)'; \
++	$(evaluate-test)
++
++tst-lam-u57-3-ENV = GLIBC_TUNABLES=glibc.cpu.x86_64_lam=on:glibc.cpu.x86_64_lam_size=57
++$(objpfx)tst-lam-u57-3: $(libdl)
++$(objpfx)tst-lam-u57-3.out: $(..)sysdeps/x86_64/64/tst-lam-u57.sh \
++			    $(objpfx)tst-lam-u57-3 \
++			    $(objpfx)tst-lam-u57-pre \
++			    $(objpfx)tst-lam-legacy-mod-1.so
++	$(SHELL) $< $(common-objpfx) '$(test-wrapper-env)' \
++		 '$(run-program-env)' '$(word 2,$^)'; \
++	$(evaluate-test)
++endif
++endif
++endif
+diff --git a/sysdeps/x86_64/64/tst-lam-1-static.c b/sysdeps/x86_64/64/tst-lam-1-static.c
+new file mode 100644
+index 0000000000..cc94049d7b
+--- /dev/null
++++ b/sysdeps/x86_64/64/tst-lam-1-static.c
+@@ -0,0 +1 @@
++#include "tst-lam-1.c"
+diff --git a/sysdeps/x86_64/64/tst-lam-1.c b/sysdeps/x86_64/64/tst-lam-1.c
+new file mode 100644
+index 0000000000..e6754c6a24
+--- /dev/null
++++ b/sysdeps/x86_64/64/tst-lam-1.c
+@@ -0,0 +1,74 @@
++/* Check that LAM can't be enabled by mistake.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <config.h>
++#include <stdlib.h>
++#include <errno.h>
++#include <sys/tagged-address.h>
++#include <support/test-driver.h>
++#include <support/check.h>
++
++/* Verify that the mask for address bits can't be set when LAM isn't
++   enabled.  If LAM is enabled, skip test since errno may not be to
++   set ENOSYS when set_tagged_address_mask fails.  */
++
++static void
++init_0 (void)
++{
++  if (LAM_ENABLED)
++    exit (EXIT_UNSUPPORTED);
++
++  if (set_tagged_address_mask (TAGGED_ADDRESS_MASK (48)) != -1
++      || errno != ENOSYS)
++    FAIL_EXIT1 ("set_tagged_address_mask should fail with ENOSYS (%m)");
++
++  if (set_tagged_address_mask (TAGGED_ADDRESS_MASK (57)) != -1
++      || errno != EPERM)
++    FAIL_EXIT1 ("set_tagged_address_mask should fail with EPERM (%m)");
++
++  if (set_tagged_address_mask ((uintptr_t) -1) != -1
++      || errno != EPERM)
++    FAIL_EXIT1 ("set_tagged_address_mask should fail with EPERM (%m)");
++}
++
++static void (*init_array []) (void)
++  __attribute__ ((used, section (".init_array"), aligned (sizeof (void *)))) =
++{
++  &init_0,
++};
++
++static int
++do_test (void)
++{
++  int status = EXIT_SUCCESS;
++  if (set_tagged_address_mask (TAGGED_ADDRESS_MASK (48)) != -1
++      || errno != EPERM)
++    status = EXIT_FAILURE;
++
++  if (set_tagged_address_mask (TAGGED_ADDRESS_MASK (57)) != -1
++      || errno != EPERM)
++    status = EXIT_FAILURE;
++
++  if (set_tagged_address_mask ((uintptr_t) -1) != -1
++      || errno != EPERM)
++    status = EXIT_FAILURE;
++
++  return status;
++}
++
++#include <support/test-driver.c>
+diff --git a/sysdeps/x86_64/64/tst-lam-2.c b/sysdeps/x86_64/64/tst-lam-2.c
+new file mode 100644
+index 0000000000..2e99a10803
+--- /dev/null
++++ b/sysdeps/x86_64/64/tst-lam-2.c
+@@ -0,0 +1,28 @@
++/* Check LAM_U48 tagged address with LAM disabled.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include "tst-lam-disabled.h"
++
++static int
++do_test (void)
++{
++  return do_test_1 (48);
++}
++
++#define EXPECTED_SIGNAL (SIGSEGV)
++#include <support/test-driver.c>
+diff --git a/sysdeps/x86_64/64/tst-lam-3.c b/sysdeps/x86_64/64/tst-lam-3.c
+new file mode 100644
+index 0000000000..e8dfb33e34
+--- /dev/null
++++ b/sysdeps/x86_64/64/tst-lam-3.c
+@@ -0,0 +1,28 @@
++/* Check LAM_U57 tagged address with LAM disabled.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include "tst-lam-disabled.h"
++
++static int
++do_test (void)
++{
++  return do_test_1 (57);
++}
++
++#define EXPECTED_SIGNAL (SIGSEGV)
++#include <support/test-driver.c>
+diff --git a/sysdeps/x86_64/64/tst-lam-4-static.c b/sysdeps/x86_64/64/tst-lam-4-static.c
+new file mode 100644
+index 0000000000..2285bfd116
+--- /dev/null
++++ b/sysdeps/x86_64/64/tst-lam-4-static.c
+@@ -0,0 +1 @@
++#include "tst-lam-4.c"
+diff --git a/sysdeps/x86_64/64/tst-lam-4.c b/sysdeps/x86_64/64/tst-lam-4.c
+new file mode 100644
+index 0000000000..ebc8d55bca
+--- /dev/null
++++ b/sysdeps/x86_64/64/tst-lam-4.c
+@@ -0,0 +1,51 @@
++/* Check that LAM_U57 tagged address works on CPU with LAM.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <stdio.h>
++#include <stdlib.h>
++#include <string.h>
++#include <sys/mman.h>
++#include <sys/tagged-address.h>
++#include <support/test-driver.h>
++#include <support/xunistd.h>
++#include <tst-set-mask-lam-u57-1.h>
++
++#define TEST_STRING \
++  "Check that LAM_U57 tagged address works on CPU with LAM."
++
++static int
++do_test (void)
++{
++  size_t pagesize = xsysconf (_SC_PAGESIZE);
++  char *ptr = (char *) xmmap (NULL, pagesize, PROT_READ | PROT_WRITE,
++			      MAP_ANONYMOUS | MAP_PRIVATE, -1);
++  char *tagged_ptr_1 = tag_address (ptr, 5);
++  char *tagged_ptr_2 = tag_address (ptr, 4);
++
++  memcpy (tagged_ptr_1, TEST_STRING, sizeof (TEST_STRING));
++
++  if (memcmp (tagged_ptr_1, ptr, sizeof (TEST_STRING)) != 0)
++    return EXIT_FAILURE;
++
++  if (memcmp (tagged_ptr_1, tagged_ptr_2, sizeof (TEST_STRING)) != 0)
++    return EXIT_FAILURE;
++
++  return EXIT_SUCCESS;
++}
++
++#include <support/test-driver.c>
+diff --git a/sysdeps/x86_64/64/tst-lam-disabled.h b/sysdeps/x86_64/64/tst-lam-disabled.h
+new file mode 100644
+index 0000000000..995b0cf501
+--- /dev/null
++++ b/sysdeps/x86_64/64/tst-lam-disabled.h
+@@ -0,0 +1,58 @@
++/* Check tagged address without LAM support.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <stdio.h>
++#include <stdlib.h>
++#include <string.h>
++#include <sys/mman.h>
++#include <sys/tagged-address.h>
++#include <support/test-driver.h>
++#include <support/xsignal.h>
++#include <support/xunistd.h>
++#include <tst-set-mask-lam-disabled-1.h>
++
++#define TEST_STRING \
++  "Check LAM tagged address with LAM disable."
++
++static inline void *
++address_with_tag (void *addr, unsigned int shift, unsigned int tag)
++{
++  uintptr_t val = (uintptr_t) addr;
++  val |= ((uintptr_t) tag) << shift;
++  return (void *) val;
++}
++
++static int
++do_test_1 (unsigned int shift)
++{
++  size_t pagesize = xsysconf (_SC_PAGESIZE);
++  char *ptr = (char *) xmmap (NULL, pagesize, PROT_READ | PROT_WRITE,
++			      MAP_ANONYMOUS | MAP_PRIVATE, -1);
++  char *tagged_ptr_1 = address_with_tag (ptr, shift, 5);
++  char *tagged_ptr_2 = address_with_tag (ptr, shift, 4);
++
++  memcpy (tagged_ptr_1, TEST_STRING, sizeof (TEST_STRING));
++
++  if (memcmp (tagged_ptr_1, ptr, sizeof (TEST_STRING)) != 0)
++    return EXIT_FAILURE;
++
++  if (memcmp (tagged_ptr_1, tagged_ptr_2, sizeof (TEST_STRING)) != 0)
++    return EXIT_FAILURE;
++
++  return EXIT_FAILURE;
++}
+diff --git a/sysdeps/x86_64/64/tst-lam-legacy-mod-1.c b/sysdeps/x86_64/64/tst-lam-legacy-mod-1.c
+new file mode 100644
+index 0000000000..067a399679
+--- /dev/null
++++ b/sysdeps/x86_64/64/tst-lam-legacy-mod-1.c
+@@ -0,0 +1,26 @@
++/* Check LAM_U57 executable compatibility with legacy shared object.
++   This file creates legacy shared object tst-lam-legacy-mod-1.so.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++static void *
++address_without_tag (void *addr)
++{
++  return addr;
++}
++
++#include "tst-lam-u57-mod-1.h"
+diff --git a/sysdeps/x86_64/64/tst-lam-u48-mod-1.c b/sysdeps/x86_64/64/tst-lam-u48-mod-1.c
+new file mode 100644
+index 0000000000..e2036041ab
+--- /dev/null
++++ b/sysdeps/x86_64/64/tst-lam-u48-mod-1.c
+@@ -0,0 +1,28 @@
++/* Check LAM_U57 executable compatibility with LAM_U48 shared object.
++   This file creates LAM_U48 shared object tst-lam-u48-mod-1.so.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <sys/tagged-address.h>
++
++static void *
++address_without_tag (void *addr)
++{
++  return untag_address (addr);
++}
++
++#include "tst-lam-u57-mod-1.h"
+diff --git a/sysdeps/x86_64/64/tst-lam-u57-1.c b/sysdeps/x86_64/64/tst-lam-u57-1.c
+new file mode 100644
+index 0000000000..fd42ca009a
+--- /dev/null
++++ b/sysdeps/x86_64/64/tst-lam-u57-1.c
+@@ -0,0 +1,27 @@
++/* Check LAM_U57 executable with LAM_U57 shared object compatibility.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include "tst-lam-u57-1.h"
++
++static int
++do_test (void)
++{
++  return do_test_1 ("tst-lam-u57-mod-1.so", 0);
++}
++
++#include <support/test-driver.c>
+diff --git a/sysdeps/x86_64/64/tst-lam-u57-1.h b/sysdeps/x86_64/64/tst-lam-u57-1.h
+new file mode 100644
+index 0000000000..9abe17c28a
+--- /dev/null
++++ b/sysdeps/x86_64/64/tst-lam-u57-1.h
+@@ -0,0 +1,60 @@
++/* Check LAM_U57 executable with LAM_U57/LAM_U48 shared object
++   compatibility.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <dlfcn.h>
++#include <sys/mman.h>
++#include <support/test-driver.h>
++#include <support/xunistd.h>
++#include <support/check.h>
++#include <sys/tagged-address.h>
++#include <tst-set-mask-lam-u57-1.h>
++
++static int
++do_test_1 (const char *modname, int expected)
++{
++  int (*fp) (char *, char *);
++  void *h;
++
++  h = dlopen (modname, RTLD_LAZY);
++  if (h == NULL)
++    {
++      const char *err = dlerror ();
++      FAIL_EXIT1 ("dlopen '%s' error: %s\n", modname, err);
++    }
++
++  fp = dlsym (h, "lam_test");
++  if (fp == NULL)
++    FAIL_EXIT1 ("cannot get symbol 'lam_test': %s\n", dlerror ());
++
++  size_t pagesize = xsysconf (_SC_PAGESIZE);
++  char *ptr = (char *) xmmap (NULL, pagesize, PROT_READ | PROT_WRITE,
++			      MAP_ANONYMOUS | MAP_PRIVATE, -1);
++
++  char *tagged_ptr_1 = tag_address (ptr, 5);
++  char *tagged_ptr_2 = tag_address (ptr, 4);
++
++  int res = fp (tagged_ptr_1, tagged_ptr_2);
++  if (res != expected)
++    FAIL_EXIT1 ("lam_test in %s failed: %d != %d\n",
++		modname, expected, res);
++
++  dlclose (h);
++
++  return 0;
++}
+diff --git a/sysdeps/x86_64/64/tst-lam-u57-2.c b/sysdeps/x86_64/64/tst-lam-u57-2.c
+new file mode 100644
+index 0000000000..a59ab5b27c
+--- /dev/null
++++ b/sysdeps/x86_64/64/tst-lam-u57-2.c
+@@ -0,0 +1,27 @@
++/* Check LAM_U57 executable with LAM_U48 shared object compatibility.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include "tst-lam-u57-1.h"
++
++static int
++do_test (void)
++{
++  return do_test_1 ("tst-lam-u48-mod-1.so", 0);
++}
++
++#include <support/test-driver.c>
+diff --git a/sysdeps/x86_64/64/tst-lam-u57-3.c b/sysdeps/x86_64/64/tst-lam-u57-3.c
+new file mode 100644
+index 0000000000..852309e2f3
+--- /dev/null
++++ b/sysdeps/x86_64/64/tst-lam-u57-3.c
+@@ -0,0 +1,27 @@
++/* Check LAM_U57 executable with LAM_U48 shared object compatibility.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include "tst-lam-u57-1.h"
++
++static int
++do_test (void)
++{
++  return do_test_1 ("tst-lam-legacy-mod-1.so", 1);
++}
++
++#include <support/test-driver.c>
+diff --git a/sysdeps/x86_64/64/tst-lam-u57-mod-1.c b/sysdeps/x86_64/64/tst-lam-u57-mod-1.c
+new file mode 100644
+index 0000000000..6d55c8d434
+--- /dev/null
++++ b/sysdeps/x86_64/64/tst-lam-u57-mod-1.c
+@@ -0,0 +1,30 @@
++/* Check LAM_U57 executable compatibility with LAM_U57 shared object.
++   This file creates LAM_U57 shared object tst-lam-u57-mod-1.so.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <stdint.h>
++
++static void *
++address_without_tag (void *addr)
++{
++  uintptr_t val = (uintptr_t) addr;
++  val &= (((uintptr_t) 1) << 57) -1;
++  return (void *) val;
++}
++
++#include "tst-lam-u57-mod-1.h"
+diff --git a/sysdeps/x86_64/64/tst-lam-u57-mod-1.h b/sysdeps/x86_64/64/tst-lam-u57-mod-1.h
+new file mode 100644
+index 0000000000..2ab250c68c
+--- /dev/null
++++ b/sysdeps/x86_64/64/tst-lam-u57-mod-1.h
+@@ -0,0 +1,26 @@
++/* Check compatibility of LAM_U57 executable with LAM_U48/LAM_U57 shared
++   object.
++   Copyright (C) 2018-2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++int
++lam_test (char *ptr1, char *ptr2)
++{
++  char *ptr1_without_tag = address_without_tag (ptr1);
++  char *ptr2_without_tag = address_without_tag (ptr2);
++  return ptr1_without_tag > ptr2_without_tag ? 1 : 0;
++}
+diff --git a/sysdeps/x86_64/64/tst-lam-u57-pre.c b/sysdeps/x86_64/64/tst-lam-u57-pre.c
+new file mode 100644
+index 0000000000..076d9c0360
+--- /dev/null
++++ b/sysdeps/x86_64/64/tst-lam-u57-pre.c
+@@ -0,0 +1,23 @@
++/* This file is used for LAM pre test for machine LAM capability.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++int
++main (void)
++{
++  return 0;
++}
+diff --git a/sysdeps/x86_64/64/tst-lam-u57.sh b/sysdeps/x86_64/64/tst-lam-u57.sh
+new file mode 100755
+index 0000000000..e9fa5c7e97
+--- /dev/null
++++ b/sysdeps/x86_64/64/tst-lam-u57.sh
+@@ -0,0 +1,46 @@
++#!/bin/sh
++# Test wrapper to run LAM test.
++# Copyright (C) 2000-2021 Free Software Foundation, Inc.
++# This file is part of the GNU C Library.
++
++# The GNU C Library is free software; you can redistribute it and/or
++# modify it under the terms of the GNU Lesser General Public
++# License as published by the Free Software Foundation; either
++# version 2.1 of the License, or (at your option) any later version.
++
++# The GNU C Library is distributed in the hope that it will be useful,
++# but WITHOUT ANY WARRANTY; without even the implied warranty of
++# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++# Lesser General Public License for more details.
++
++# You should have received a copy of the GNU Lesser General Public
++# License along with the GNU C Library; if not, see
++# <https://www.gnu.org/licenses/>.
++
++set -e
++
++common_objpfx=$1
++test_wrapper_env=$2
++run_program_env=$3
++run_program=$4
++
++# Run dummy test to check if machine is LAM capable.
++${test_wrapper_env} \
++${run_program_env} \
++LD_LIBRARY_PATH=${common_objpfx}. \
++  ${common_objpfx}elf/ld.so ${common_objpfx}elf/tst-lam-u57-pre \
++    > ${run_program}.out
++
++ret=$?
++if [ $ret -ne 0 ]; then
++  exit 77
++fi
++
++# Run actual LAM test.
++${test_wrapper_env} \
++${run_program_env} \
++LD_LIBRARY_PATH=${common_objpfx}.:${common_objpfx}dlfcn \
++  ${common_objpfx}elf/ld.so ${run_program} \
++    > ${run_program}.out
++
++exit $?
+diff --git a/sysdeps/x86_64/64/tst-set-mask-lam-disabled-1.h b/sysdeps/x86_64/64/tst-set-mask-lam-disabled-1.h
+new file mode 100644
+index 0000000000..6ba541db2d
+--- /dev/null
++++ b/sysdeps/x86_64/64/tst-set-mask-lam-disabled-1.h
+@@ -0,0 +1,34 @@
++/* Set LAM mask disabled.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <errno.h>
++#include <stdlib.h>
++
++static void
++init_0 (void)
++{
++  /* Disable LAM mask.  */
++  if (set_tagged_address_mask ((uintptr_t) -1) != 0)
++    exit (EXIT_UNSUPPORTED);
++}
++
++static void (*init_array []) (void)
++  __attribute__ ((used, section (".init_array"), aligned (sizeof (void *)))) =
++{
++  &init_0,
++};
+diff --git a/sysdeps/x86_64/64/tst-set-mask-lam-u57-1.h b/sysdeps/x86_64/64/tst-set-mask-lam-u57-1.h
+new file mode 100644
+index 0000000000..6a815d2569
+--- /dev/null
++++ b/sysdeps/x86_64/64/tst-set-mask-lam-u57-1.h
+@@ -0,0 +1,34 @@
++/* Set LAM mask to U57.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <errno.h>
++#include <stdlib.h>
++
++static void
++init_0 (void)
++{
++  /* Enable LAM_U57.  */
++  if (set_tagged_address_mask (TAGGED_ADDRESS_MASK (57)) != 0)
++    exit (EXIT_UNSUPPORTED);
++}
++
++static void (*init_array []) (void)
++  __attribute__ ((used, section (".init_array"), aligned (sizeof (void *)))) =
++{
++  &init_0,
++};
+-- 
+2.31.1
+
diff --git a/0023-Add-test-memmove-lam_u57.c.patch b/0023-Add-test-memmove-lam_u57.c.patch
new file mode 100644
index 0000000..e96974f
--- /dev/null
+++ b/0023-Add-test-memmove-lam_u57.c.patch
@@ -0,0 +1,85 @@
+From 360dbe8784a56b8755542b9d7f1faf0abafe2fcd Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Sun, 31 Jan 2021 16:36:52 -0800
+Subject: [PATCH 23/24] Add test-memmove-lam_u57.c
+
+---
+ string/test-memmove.c                    |  6 ++++-
+ sysdeps/x86_64/64/Makefile               |  5 ++++
+ sysdeps/x86_64/64/test-memmove-lam_u57.c | 33 ++++++++++++++++++++++++
+ 3 files changed, 43 insertions(+), 1 deletion(-)
+ create mode 100644 sysdeps/x86_64/64/test-memmove-lam_u57.c
+
+diff --git a/string/test-memmove.c b/string/test-memmove.c
+index e2c3d7a0ed..5dcc207aa6 100644
+--- a/string/test-memmove.c
++++ b/string/test-memmove.c
+@@ -314,8 +314,12 @@ do_test2 (void)
+   munmap ((void *) large_buf, size);
+ }
+ 
++#ifndef TEST_MAIN_FUNCTION
++# define TEST_MAIN_FUNCTION test_main
++#endif
++
+ int
+-test_main (void)
++TEST_MAIN_FUNCTION (void)
+ {
+   size_t i;
+ 
+diff --git a/sysdeps/x86_64/64/Makefile b/sysdeps/x86_64/64/Makefile
+index 369522302e..77dbd47796 100644
+--- a/sysdeps/x86_64/64/Makefile
++++ b/sysdeps/x86_64/64/Makefile
+@@ -72,3 +72,8 @@ $(objpfx)tst-lam-u57-3.out: $(..)sysdeps/x86_64/64/tst-lam-u57.sh \
+ endif
+ endif
+ endif
++
++ifeq ($(subdir),string)
++tests += \
++  test-memmove-lam_u57
++endif
+diff --git a/sysdeps/x86_64/64/test-memmove-lam_u57.c b/sysdeps/x86_64/64/test-memmove-lam_u57.c
+new file mode 100644
+index 0000000000..b15e9315b4
+--- /dev/null
++++ b/sysdeps/x86_64/64/test-memmove-lam_u57.c
+@@ -0,0 +1,33 @@
++/* Tetst memmove with LAM_U57 tagged address on CPU with LAM.
++   Copyright (C) 2021 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <https://www.gnu.org/licenses/>.  */
++
++#include <sys/tagged-address.h>
++#include <support/test-driver.h>
++#include <tst-set-mask-lam-u57-1.h>
++
++extern int do_test_main (void);
++
++int
++test_main (void)
++{
++  return do_test_main ();
++}
++
++#define TEST_MAIN_FUNCTION do_test_main
++
++#include <test-memmove.c>
+-- 
+2.31.1
+
diff --git a/0024-Improve-string-test-memmove.c-coverage.patch b/0024-Improve-string-test-memmove.c-coverage.patch
new file mode 100644
index 0000000..9df99bb
--- /dev/null
+++ b/0024-Improve-string-test-memmove.c-coverage.patch
@@ -0,0 +1,83 @@
+From 1a5bc6545816fd59de00161aa5043afb6a4f69cf Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Mon, 1 Feb 2021 17:23:12 -0800
+Subject: [PATCH 24/24] Improve string/test-memmove.c coverage
+
+Update string/test-memmove.c to cover 16KB copy.
+---
+ string/test-memmove.c | 52 +++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 52 insertions(+)
+
+diff --git a/string/test-memmove.c b/string/test-memmove.c
+index 5dcc207aa6..ed252edcd9 100644
+--- a/string/test-memmove.c
++++ b/string/test-memmove.c
+@@ -314,6 +314,56 @@ do_test2 (void)
+   munmap ((void *) large_buf, size);
+ }
+ 
++static void
++do_test3 (void)
++{
++  /* Copy 16KB data.  */
++  size_t bytes_move = 16384;
++  size_t size = 16384 * 3;
++  uint32_t *buf;
++
++  buf = mmap (NULL, size, PROT_READ | PROT_WRITE,
++	      MAP_PRIVATE | MAP_ANON, -1, 0);
++
++  buf = tag_address (buf, 5);
++
++  if (buf == MAP_FAILED)
++    error (EXIT_UNSUPPORTED, errno, "mmap failed");
++
++  size_t arr_size = bytes_move / sizeof (uint32_t);
++  size_t i;
++
++  FOR_EACH_IMPL (impl, 0)
++    {
++      for (i = 0; i < arr_size; i++)
++        buf[i] = (uint32_t) i;
++
++      uint32_t *dst = &buf[arr_size + 3];
++
++      dst = tag_address (dst, 6);
++
++#ifdef TEST_BCOPY
++      CALL (impl, (char *) buf, (char *) dst, bytes_move);
++#else
++      CALL (impl, (char *) dst, (char *) buf, bytes_move);
++#endif
++
++      for (i = 0; i < arr_size; i++)
++	{
++	  if (dst[i] != (uint32_t) i)
++	    {
++	      error (0, 0,
++		     "Wrong result in function %s dst \"%p\" src \"%p\" offset \"%zd\"",
++		     impl->name, dst, buf, i);
++	      ret = 1;
++	      break;
++	    }
++	}
++    }
++
++  munmap ((void *) buf, size);
++}
++
+ #ifndef TEST_MAIN_FUNCTION
+ # define TEST_MAIN_FUNCTION test_main
+ #endif
+@@ -360,6 +410,8 @@ TEST_MAIN_FUNCTION (void)
+ 
+   do_test2 ();
+ 
++  do_test3 ();
++
+   return ret;
+ }
+ 
+-- 
+2.31.1
+
diff --git a/glibc.spec b/glibc.spec
index 75cdd2e..a054eea 100644
--- a/glibc.spec
+++ b/glibc.spec
@@ -239,6 +239,30 @@ Patch100028: 0002-x86-Optimize-memcmp-evex-movbe.S.patch
 Patch100029: 0003-x86-Improve-memset-vec-unaligned-erms.S.patch
 Patch100030: 0001-x86-Improve-memmove-vec-unaligned-erms.S.patch
 
+Patch200001: 0001-x86-Replace-ARCH_CET_ALLOC_SHSTK-with-PROT_SHSTK.patch
+Patch200002: 0002-x86-Add-tst-sigreturn-1.c-from-Linux-kernel.patch
+Patch200003: 0003-Add-cast_to_pointer-to-cast-an-integer-to-void-point.patch
+Patch200004: 0004-Add-an-internal-wrapper-for-clone-clone2-and-clone3.patch
+Patch200005: 0005-nptl-Always-pass-stack-size-to-create_thread.patch
+Patch200006: 0006-x86-64-Add-the-clone3-wrapper.patch
+Patch200007: 0007-Add-static-tests-for-__clone_internal.patch
+Patch200008: 0008-GLIBC_PRIVATE-Export-__clone_internal.patch
+Patch200009: 0009-sys-tagged-address.h-An-API-for-tagged-address.patch
+Patch200010: 0010-x86_64-Correct-THREAD_SETMEM-THREAD_SETMEM_NC-for-mo.patch
+Patch200011: 0011-Add-GNU_PROPERTY_X86_FEATURE_1_LAM_U-48-57.patch
+Patch200012: 0012-Initial-enable-lam.patch
+Patch200013: 0013-Rename-dl-cet.-ch-to-dl-feature.-ch.patch
+Patch200014: 0014-x86-Update-prctl.h-to-support-both-CET-and-LAM.patch
+Patch200015: 0015-x86-Update-feature-control-and-tunables-for-LAM.patch
+Patch200016: 0016-x86-Update-feature-disable-for-LAM.patch
+Patch200017: 0017-Disable-LAM-incompatible-string-functions-at-run-tim.patch
+Patch200018: 0018-x86-Modularize-sysdeps-x86-dl-feature.c.patch
+Patch200019: 0019-x86-Enable-LAM-feature.patch
+Patch200020: 0020-Backport-x86-Enable-LAM-feature.patch
+Patch200021: 0021-x86-Make-memmove-LAM-compliant.patch
+Patch200022: 0022-Use-sys-tagged-address.h-in-some-LAM-tests.patch
+Patch200023: 0023-Add-test-memmove-lam_u57.c.patch
+Patch200024: 0024-Improve-string-test-memmove.c-coverage.patch
 
 ##############################################################################
 # Continued list of core "glibc" package information:
@@ -1208,6 +1232,9 @@ build()
 %ifarch x86_64 x32 %{ix86}
 	       --enable-cet \
 %endif
+%ifarch x86_64
+	       --enable-lam \
+%endif
 %ifarch %{ix86}
 		--disable-multi-arch \
 %endif
-- 
2.31.1

