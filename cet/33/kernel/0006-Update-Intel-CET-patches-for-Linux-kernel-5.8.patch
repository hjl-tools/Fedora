From db3140222e96898c507f9641f46793cc5293ed11 Mon Sep 17 00:00:00 2001
From: "H.J. Lu" <hjl.tools@gmail.com>
Date: Wed, 12 Aug 2020 12:40:39 -0700
Subject: [PATCH 6/8] Update Intel CET patches for Linux kernel 5.8

---
 ...ocumentation-x86-Add-CET-description.patch |  48 ++-
 ...ename-validate_xstate_header-to-vali.patch |  98 -----
 ...Add-CET-CPU-feature-flags-for-Contro.patch |  10 +-
 ...efine-new-macros-for-supervisor-and-.patch | 184 ---------
 ...ntroduce-CET-MSR-XSAVES-supervisor-s.patch |  32 +-
 ...eparate-user-and-supervisor-xfeature.patch | 353 ------------------
 ...Add-control-protection-fault-handler.patch |  93 ++---
 ...e-Introduce-XSAVES-supervisor-states.patch |  85 -----
 ...d-Kconfig-option-for-user-mode-Shado.patch |   8 +-
 ...efine-new-functions-for-clearing-fpr.patch | 184 ---------
 ...pdate-sanitize_restored_xstate-for-s.patch | 138 -------
 ...Change-_PAGE_DIRTY-to-_PAGE_DIRTY_HW.patch |  26 +-
 ...pdate-copy_kernel_to_xregs_err-for-X.patch |  46 ---
 ...-_PAGE_DIRTY_HW-from-kernel-RO-pages.patch |  22 +-
 ...-Introduce-copy_supervisor_to_kernel.patch | 154 --------
 ...h => 0008-x86-mm-Introduce-_PAGE_COW.patch |  27 +-
 ...ange-_PAGE_DIRTY-to-_PAGE_DIRTY_BITS.patch |  14 +-
 ...reserve-supervisor-states-for-slow-p.patch | 130 -------
 ...estore-supervisor-states-for-signal-.patch | 129 -------
 ...6-mm-Update-pte_modify-for-_PAGE_COW.patch |  11 +-
 ...ep_set_wrprotect-and-pmdp_set_wrprot.patch |  11 +-
 ...uce-VM_SHSTK-for-shadow-stack-memory.patch |  21 +-
 ...adow-Stack-page-fault-error-checking.patch |  17 +-
 ...pdate-maybe_mkwrite-for-shadow-stack.patch |  62 +--
 ...laces-that-call-pte_mkwrite-directly.patch |  18 +-
 ...dd-guard-pages-around-a-shadow-stack.patch |  20 +-
 ...dow-stack-pages-to-memory-accounting.patch |  28 +-
 ...an_follow_write_pte-for-shadow-stack.patch |  32 +-
 ...shstk-User-mode-shadow-stack-support.patch |  59 +--
 ...hstk-Handle-signals-for-shadow-stack.patch |  30 +-
 ...e-GNU_PROPERTY_X86_FEATURE_1_AND-pro.patch |  36 ++
 ...LF-Introduce-arch_setup_elf_property.patch |  21 +-
 ...-ELF-header-parsing-for-shadow-stack.patch |  16 +-
 ...cet-shstk-Handle-thread-shadow-stack.patch |  18 +-
 ...d-arch_prctl-functions-for-shadow-st.patch | 126 ++++---
 ...Kconfig-option-for-user-mode-Indirec.patch |   8 +-
 ...-mode-Indirect-Branch-Tracking-suppo.patch |  16 +-
 ...le-signals-for-Indirect-Branch-Track.patch |  18 +-
 ...header-parsing-for-Indirect-Branch-T.patch |  12 +-
 ...arch_prctl-functions-for-Indirect-Br.patch |  10 +-
 ...nfig-additions-for-ELF-program-prope.patch |  87 -----
 ...x86-cet-Add-PTRACE-interface-for-CET.patch |  14 +-
 ...ELF-program-property-parsing-support.patch | 310 ---------------
 ...ENDBR32-to-__kernel_vsyscall-entry-p.patch |   5 +-
 ...-vdso-Insert-endbr32-endbr64-to-vDSO.patch |   9 +-
 ...yscall-emulation-when-CET-is-enabled.patch |  16 +-
 ...la-sections-when-CONFIG_RELOCATABLE-.patch |   6 +-
 ...u.property-sections-in-generic-NOTES.patch |   8 +-
 ...est-x86-Enable-CET-for-selftests-x86.patch |  54 +++
 0038-selftest-x86-Fix-sigreturn_64-test.patch |  93 +++++
 ...lftest-x86-Fix-sysret_rip-with-ENDBR.patch |  46 +++
 0040-selftest-x86-Add-CET-quick-test.patch    | 191 ++++++++++
 kernel.spec                                   |  87 ++---
 53 files changed, 914 insertions(+), 2383 deletions(-)
 rename 0011-Documentation-x86-Add-CET-description.patch => 0001-Documentation-x86-Add-CET-description.patch (84%)
 delete mode 100644 0001-x86-fpu-xstate-Rename-validate_xstate_header-to-vali.patch
 rename 0012-x86-cpufeatures-Add-CET-CPU-feature-flags-for-Contro.patch => 0002-x86-cpufeatures-Add-CET-CPU-feature-flags-for-Contro.patch (89%)
 delete mode 100644 0002-x86-fpu-xstate-Define-new-macros-for-supervisor-and-.patch
 rename 0013-x86-fpu-xstate-Introduce-CET-MSR-XSAVES-supervisor-s.patch => 0003-x86-fpu-xstate-Introduce-CET-MSR-XSAVES-supervisor-s.patch (89%)
 delete mode 100644 0003-x86-fpu-xstate-Separate-user-and-supervisor-xfeature.patch
 rename 0014-x86-cet-Add-control-protection-fault-handler.patch => 0004-x86-cet-Add-control-protection-fault-handler.patch (55%)
 delete mode 100644 0004-x86-fpu-xstate-Introduce-XSAVES-supervisor-states.patch
 rename 0015-x86-cet-shstk-Add-Kconfig-option-for-user-mode-Shado.patch => 0005-x86-cet-shstk-Add-Kconfig-option-for-user-mode-Shado.patch (91%)
 delete mode 100644 0005-x86-fpu-xstate-Define-new-functions-for-clearing-fpr.patch
 delete mode 100644 0006-x86-fpu-xstate-Update-sanitize_restored_xstate-for-s.patch
 rename 0016-x86-mm-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_HW.patch => 0006-x86-mm-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_HW.patch (88%)
 delete mode 100644 0007-x86-fpu-xstate-Update-copy_kernel_to_xregs_err-for-X.patch
 rename 0017-x86-mm-Remove-_PAGE_DIRTY_HW-from-kernel-RO-pages.patch => 0007-x86-mm-Remove-_PAGE_DIRTY_HW-from-kernel-RO-pages.patch (72%)
 delete mode 100644 0008-x86-fpu-Introduce-copy_supervisor_to_kernel.patch
 rename 0018-x86-mm-Introduce-_PAGE_COW.patch => 0008-x86-mm-Introduce-_PAGE_COW.patch (93%)
 rename 0019-drm-i915-gvt-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_BITS.patch => 0009-drm-i915-gvt-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_BITS.patch (60%)
 delete mode 100644 0009-x86-fpu-xstate-Preserve-supervisor-states-for-slow-p.patch
 delete mode 100644 0010-x86-fpu-xstate-Restore-supervisor-states-for-signal-.patch
 rename 0020-x86-mm-Update-pte_modify-for-_PAGE_COW.patch => 0010-x86-mm-Update-pte_modify-for-_PAGE_COW.patch (85%)
 rename 0021-x86-mm-Update-ptep_set_wrprotect-and-pmdp_set_wrprot.patch => 0011-x86-mm-Update-ptep_set_wrprotect-and-pmdp_set_wrprot.patch (91%)
 rename 0022-mm-Introduce-VM_SHSTK-for-shadow-stack-memory.patch => 0012-mm-Introduce-VM_SHSTK-for-shadow-stack-memory.patch (78%)
 rename 0023-x86-mm-Shadow-Stack-page-fault-error-checking.patch => 0013-x86-mm-Shadow-Stack-page-fault-error-checking.patch (86%)
 rename 0024-x86-mm-Update-maybe_mkwrite-for-shadow-stack.patch => 0014-x86-mm-Update-maybe_mkwrite-for-shadow-stack.patch (73%)
 rename 0025-mm-Fixup-places-that-call-pte_mkwrite-directly.patch => 0015-mm-Fixup-places-that-call-pte_mkwrite-directly.patch (83%)
 rename 0026-mm-Add-guard-pages-around-a-shadow-stack.patch => 0016-mm-Add-guard-pages-around-a-shadow-stack.patch (83%)
 rename 0027-mm-mmap-Add-shadow-stack-pages-to-memory-accounting.patch => 0017-mm-mmap-Add-shadow-stack-pages-to-memory-accounting.patch (70%)
 rename 0028-mm-Update-can_follow_write_pte-for-shadow-stack.patch => 0018-mm-Update-can_follow_write_pte-for-shadow-stack.patch (73%)
 rename 0029-x86-cet-shstk-User-mode-shadow-stack-support.patch => 0019-x86-cet-shstk-User-mode-shadow-stack-support.patch (86%)
 rename 0030-x86-cet-shstk-Handle-signals-for-shadow-stack.patch => 0020-x86-cet-shstk-Handle-signals-for-shadow-stack.patch (95%)
 create mode 100644 0021-binfmt_elf-Define-GNU_PROPERTY_X86_FEATURE_1_AND-pro.patch
 rename 0033-ELF-Introduce-arch_setup_elf_property.patch => 0022-ELF-Introduce-arch_setup_elf_property.patch (65%)
 rename 0034-x86-cet-shstk-ELF-header-parsing-for-shadow-stack.patch => 0023-x86-cet-shstk-ELF-header-parsing-for-shadow-stack.patch (84%)
 rename 0035-x86-cet-shstk-Handle-thread-shadow-stack.patch => 0024-x86-cet-shstk-Handle-thread-shadow-stack.patch (91%)
 rename 0036-x86-cet-shstk-Add-arch_prctl-functions-for-shadow-st.patch => 0025-x86-cet-shstk-Add-arch_prctl-functions-for-shadow-st.patch (71%)
 rename 0037-x86-cet-ibt-Add-Kconfig-option-for-user-mode-Indirec.patch => 0026-x86-cet-ibt-Add-Kconfig-option-for-user-mode-Indirec.patch (86%)
 rename 0038-x86-cet-ibt-User-mode-Indirect-Branch-Tracking-suppo.patch => 0027-x86-cet-ibt-User-mode-Indirect-Branch-Tracking-suppo.patch (92%)
 rename 0039-x86-cet-ibt-Handle-signals-for-Indirect-Branch-Track.patch => 0028-x86-cet-ibt-Handle-signals-for-Indirect-Branch-Track.patch (85%)
 rename 0040-x86-cet-ibt-ELF-header-parsing-for-Indirect-Branch-T.patch => 0029-x86-cet-ibt-ELF-header-parsing-for-Indirect-Branch-T.patch (78%)
 rename 0041-x86-cet-ibt-Add-arch_prctl-functions-for-Indirect-Br.patch => 0030-x86-cet-ibt-Add-arch_prctl-functions-for-Indirect-Br.patch (81%)
 delete mode 100644 0031-ELF-UAPI-and-Kconfig-additions-for-ELF-program-prope.patch
 rename 0042-x86-cet-Add-PTRACE-interface-for-CET.patch => 0031-x86-cet-Add-PTRACE-interface-for-CET.patch (92%)
 delete mode 100644 0032-ELF-Add-ELF-program-property-parsing-support.patch
 rename 0043-x86-vdso-32-Add-ENDBR32-to-__kernel_vsyscall-entry-p.patch => 0032-x86-vdso-32-Add-ENDBR32-to-__kernel_vsyscall-entry-p.patch (82%)
 rename 0044-x86-vdso-Insert-endbr32-endbr64-to-vDSO.patch => 0033-x86-vdso-Insert-endbr32-endbr64-to-vDSO.patch (78%)
 rename 0045-x86-Disallow-vsyscall-emulation-when-CET-is-enabled.patch => 0034-x86-Disallow-vsyscall-emulation-when-CET-is-enabled.patch (81%)
 rename 0046-powerpc-Keep-.rela-sections-when-CONFIG_RELOCATABLE-.patch => 0035-powerpc-Keep-.rela-sections-when-CONFIG_RELOCATABLE-.patch (88%)
 rename 0047-Discard-.note.gnu.property-sections-in-generic-NOTES.patch => 0036-Discard-.note.gnu.property-sections-in-generic-NOTES.patch (92%)
 create mode 100644 0037-selftest-x86-Enable-CET-for-selftests-x86.patch
 create mode 100644 0038-selftest-x86-Fix-sigreturn_64-test.patch
 create mode 100644 0039-selftest-x86-Fix-sysret_rip-with-ENDBR.patch
 create mode 100644 0040-selftest-x86-Add-CET-quick-test.patch

diff --git a/0011-Documentation-x86-Add-CET-description.patch b/0001-Documentation-x86-Add-CET-description.patch
similarity index 84%
rename from 0011-Documentation-x86-Add-CET-description.patch
rename to 0001-Documentation-x86-Add-CET-description.patch
index 20481249e..e25c80cb6 100644
--- a/0011-Documentation-x86-Add-CET-description.patch
+++ b/0001-Documentation-x86-Add-CET-description.patch
@@ -1,13 +1,16 @@
-From 2f2184cda3322b9a1a23d88a5bcc99f26410041f Mon Sep 17 00:00:00 2001
+From ce1e078b5704bbc3bacf96e0735cb304fec1dcc8 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Sun, 17 Dec 2017 09:09:23 -0800
-Subject: [PATCH 11/47] Documentation/x86: Add CET description
+Subject: [PATCH 01/40] Documentation/x86: Add CET description
 
 Explain no_user_shstk/no_user_ibt kernel parameters, and introduce a new
 document on Control-flow Enforcement Technology (CET).
 
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Kees Cook <keescook@chromium.org>
+
+v11:
+- Add back GLIBC tunables information.
+- Add ARCH_X86_CET_MMAP_SHSTK information.
 
 v10:
 - Change no_cet_shstk and no_cet_ibt to no_user_shstk and no_user_ibt.
@@ -21,15 +24,15 @@ v10:
 ---
  .../admin-guide/kernel-parameters.txt         |   6 +
  Documentation/x86/index.rst                   |   1 +
- Documentation/x86/intel_cet.rst               | 129 ++++++++++++++++++
- 3 files changed, 136 insertions(+)
+ Documentation/x86/intel_cet.rst               | 152 ++++++++++++++++++
+ 3 files changed, 159 insertions(+)
  create mode 100644 Documentation/x86/intel_cet.rst
 
 diff --git a/Documentation/admin-guide/kernel-parameters.txt b/Documentation/admin-guide/kernel-parameters.txt
-index 7bc83f3d9bdf..be715675df6d 100644
+index fb95fad81c79..e1571661e4a0 100644
 --- a/Documentation/admin-guide/kernel-parameters.txt
 +++ b/Documentation/admin-guide/kernel-parameters.txt
-@@ -3093,6 +3093,12 @@
+@@ -3139,6 +3139,12 @@
  			noexec=on: enable non-executable mappings (default)
  			noexec=off: disable non-executable mappings
  
@@ -56,10 +59,10 @@ index 265d9e9a093b..2aef972a868d 100644
     amd-memory-encryption
 diff --git a/Documentation/x86/intel_cet.rst b/Documentation/x86/intel_cet.rst
 new file mode 100644
-index 000000000000..746eda8c82f3
+index 000000000000..acedbe5457e9
 --- /dev/null
 +++ b/Documentation/x86/intel_cet.rst
-@@ -0,0 +1,129 @@
+@@ -0,0 +1,152 @@
 +.. SPDX-License-Identifier: GPL-2.0
 +
 +=========================================
@@ -114,7 +117,21 @@ index 000000000000..746eda8c82f3
 +CET protection.  If the application needs any shared libraries, the loader
 +checks all dependencies and enables CET when all requirements are met.
 +
-+[3] CET arch_prctl()'s
++[3] Backward Compatibility
++==========================
++
++GLIBC provides a few tunables for backward compatibility.
++
++GLIBC_TUNABLES=glibc.tune.hwcaps=-SHSTK,-IBT
++    Turn off SHSTK/IBT for the current shell.
++
++GLIBC_TUNABLES=glibc.tune.x86_shstk=<on, permissive>
++    This controls how dlopen() handles SHSTK legacy libraries::
++
++        on         - continue with SHSTK enabled;
++        permissive - continue with SHSTK off.
++
++[4] CET arch_prctl()'s
 +======================
 +
 +Several arch_prctl()'s have been added for CET:
@@ -147,11 +164,20 @@ index 000000000000..746eda8c82f3
 +    User-level threads that need a new stack are expected to allocate a
 +    new shadow stack.
 +
++arch_prctl(ARCH_X86_CET_MMAP_SHSTK, u64 *args)
++    Allocate a new shadow stack and put a restore token at top.
++
++    The parameter 'args' is a pointer to a user buffer::
++
++        *args = allocated shadow stack address
++        *(args + 1) = desired size
++        *(args + 2) = MAP_32BIT or MAP_POPULATE
++
 +Note:
 +  There is no CET-enabling arch_prctl function.  By design, CET is enabled
 +  automatically if the binary and the system can support it.
 +
-+[4] The implementation of the Shadow Stack
++[5] The implementation of the Shadow Stack
 +==========================================
 +
 +Shadow Stack size
diff --git a/0001-x86-fpu-xstate-Rename-validate_xstate_header-to-vali.patch b/0001-x86-fpu-xstate-Rename-validate_xstate_header-to-vali.patch
deleted file mode 100644
index 1a6c49751..000000000
--- a/0001-x86-fpu-xstate-Rename-validate_xstate_header-to-vali.patch
+++ /dev/null
@@ -1,98 +0,0 @@
-From a795020f5251c22dceaa2480f0cf4d9569bcf65c Mon Sep 17 00:00:00 2001
-From: Fenghua Yu <fenghua.yu@intel.com>
-Date: Wed, 13 Dec 2017 16:08:28 -0800
-Subject: [PATCH 01/47] x86/fpu/xstate: Rename validate_xstate_header() to
- validate_user_xstate_header()
-
-The function validate_xstate_header() validates an xstate header coming
-from userspace (PTRACE or sigreturn).  To make it clear, rename it to
-validate_user_xstate_header().
-
-v3:
-- Change validate_xstate_header_from_user() to validate_user_xstate_header().
-
-Suggested-by: Dave Hansen <dave.hansen@intel.com>
-Signed-off-by: Fenghua Yu <fenghua.yu@intel.com>
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
-Reviewed-by: Tony Luck <tony.luck@intel.com>
-Reviewed-by: Borislav Petkov <bp@suse.de>
----
- arch/x86/include/asm/fpu/xstate.h | 2 +-
- arch/x86/kernel/fpu/regset.c      | 2 +-
- arch/x86/kernel/fpu/signal.c      | 2 +-
- arch/x86/kernel/fpu/xstate.c      | 6 +++---
- 4 files changed, 6 insertions(+), 6 deletions(-)
-
-diff --git a/arch/x86/include/asm/fpu/xstate.h b/arch/x86/include/asm/fpu/xstate.h
-index c6136d79f8c0..fc4db51f3b53 100644
---- a/arch/x86/include/asm/fpu/xstate.h
-+++ b/arch/x86/include/asm/fpu/xstate.h
-@@ -56,6 +56,6 @@ int copy_kernel_to_xstate(struct xregs_state *xsave, const void *kbuf);
- int copy_user_to_xstate(struct xregs_state *xsave, const void __user *ubuf);
- 
- /* Validate an xstate header supplied by userspace (ptrace or sigreturn) */
--extern int validate_xstate_header(const struct xstate_header *hdr);
-+int validate_user_xstate_header(const struct xstate_header *hdr);
- 
- #endif
-diff --git a/arch/x86/kernel/fpu/regset.c b/arch/x86/kernel/fpu/regset.c
-index d652b939ccfb..bd1d0649f8ce 100644
---- a/arch/x86/kernel/fpu/regset.c
-+++ b/arch/x86/kernel/fpu/regset.c
-@@ -139,7 +139,7 @@ int xstateregs_set(struct task_struct *target, const struct user_regset *regset,
- 	} else {
- 		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, xsave, 0, -1);
- 		if (!ret)
--			ret = validate_xstate_header(&xsave->header);
-+			ret = validate_user_xstate_header(&xsave->header);
- 	}
- 
- 	/*
-diff --git a/arch/x86/kernel/fpu/signal.c b/arch/x86/kernel/fpu/signal.c
-index 400a05e1c1c5..585e3651b98f 100644
---- a/arch/x86/kernel/fpu/signal.c
-+++ b/arch/x86/kernel/fpu/signal.c
-@@ -366,7 +366,7 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
- 			ret = __copy_from_user(&fpu->state.xsave, buf_fx, state_size);
- 
- 			if (!ret && state_size > offsetof(struct xregs_state, header))
--				ret = validate_xstate_header(&fpu->state.xsave.header);
-+				ret = validate_user_xstate_header(&fpu->state.xsave.header);
- 		}
- 		if (ret)
- 			goto err_out;
-diff --git a/arch/x86/kernel/fpu/xstate.c b/arch/x86/kernel/fpu/xstate.c
-index 6a54e83d5589..56a4379a2001 100644
---- a/arch/x86/kernel/fpu/xstate.c
-+++ b/arch/x86/kernel/fpu/xstate.c
-@@ -472,7 +472,7 @@ int using_compacted_format(void)
- }
- 
- /* Validate an xstate header supplied by userspace (ptrace or sigreturn) */
--int validate_xstate_header(const struct xstate_header *hdr)
-+int validate_user_xstate_header(const struct xstate_header *hdr)
- {
- 	/* No unknown or supervisor features may be set */
- 	if (hdr->xfeatures & (~xfeatures_mask | XFEATURE_MASK_SUPERVISOR))
-@@ -1157,7 +1157,7 @@ int copy_kernel_to_xstate(struct xregs_state *xsave, const void *kbuf)
- 
- 	memcpy(&hdr, kbuf + offset, size);
- 
--	if (validate_xstate_header(&hdr))
-+	if (validate_user_xstate_header(&hdr))
- 		return -EINVAL;
- 
- 	for (i = 0; i < XFEATURE_MAX; i++) {
-@@ -1211,7 +1211,7 @@ int copy_user_to_xstate(struct xregs_state *xsave, const void __user *ubuf)
- 	if (__copy_from_user(&hdr, ubuf + offset, size))
- 		return -EFAULT;
- 
--	if (validate_xstate_header(&hdr))
-+	if (validate_user_xstate_header(&hdr))
- 		return -EINVAL;
- 
- 	for (i = 0; i < XFEATURE_MAX; i++) {
--- 
-2.26.2
-
diff --git a/0012-x86-cpufeatures-Add-CET-CPU-feature-flags-for-Contro.patch b/0002-x86-cpufeatures-Add-CET-CPU-feature-flags-for-Contro.patch
similarity index 89%
rename from 0012-x86-cpufeatures-Add-CET-CPU-feature-flags-for-Contro.patch
rename to 0002-x86-cpufeatures-Add-CET-CPU-feature-flags-for-Contro.patch
index a6c9285a1..71986626d 100644
--- a/0012-x86-cpufeatures-Add-CET-CPU-feature-flags-for-Contro.patch
+++ b/0002-x86-cpufeatures-Add-CET-CPU-feature-flags-for-Contro.patch
@@ -1,7 +1,7 @@
-From eb3b52bc6441b6a8b437d9b356d00b5b767cb619 Mon Sep 17 00:00:00 2001
+From 6e4c945c8f4a6a6ef8e94d3e7d1411c14a9428fd Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Wed, 9 Nov 2016 16:26:37 -0800
-Subject: [PATCH 12/47] x86/cpufeatures: Add CET CPU feature flags for
+Subject: [PATCH 02/40] x86/cpufeatures: Add CET CPU feature flags for
  Control-flow Enforcement Technology (CET)
 
 Add CPU feature flags for Control-flow Enforcement Technology (CET).
@@ -10,15 +10,13 @@ CPUID.(EAX=7,ECX=0):ECX[bit 7] Shadow stack
 CPUID.(EAX=7,ECX=0):EDX[bit 20] Indirect Branch Tracking
 
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Borislav Petkov <bp@suse.de>
-Reviewed-by: Kees Cook <keescook@chromium.org>
 ---
  arch/x86/include/asm/cpufeatures.h | 2 ++
  arch/x86/kernel/cpu/cpuid-deps.c   | 2 ++
  2 files changed, 4 insertions(+)
 
 diff --git a/arch/x86/include/asm/cpufeatures.h b/arch/x86/include/asm/cpufeatures.h
-index db189945e9b0..2c95a3efc2d9 100644
+index 02dabc9e77b0..32a353951089 100644
 --- a/arch/x86/include/asm/cpufeatures.h
 +++ b/arch/x86/include/asm/cpufeatures.h
 @@ -339,6 +339,7 @@
@@ -29,7 +27,7 @@ index db189945e9b0..2c95a3efc2d9 100644
  #define X86_FEATURE_GFNI		(16*32+ 8) /* Galois Field New Instructions */
  #define X86_FEATURE_VAES		(16*32+ 9) /* Vector AES */
  #define X86_FEATURE_VPCLMULQDQ		(16*32+10) /* Carry-Less Multiplication Double Quadword */
-@@ -365,6 +366,7 @@
+@@ -366,6 +367,7 @@
  #define X86_FEATURE_MD_CLEAR		(18*32+10) /* VERW clears CPU buffers */
  #define X86_FEATURE_TSX_FORCE_ABORT	(18*32+13) /* "" TSX_FORCE_ABORT */
  #define X86_FEATURE_PCONFIG		(18*32+18) /* Intel PCONFIG */
diff --git a/0002-x86-fpu-xstate-Define-new-macros-for-supervisor-and-.patch b/0002-x86-fpu-xstate-Define-new-macros-for-supervisor-and-.patch
deleted file mode 100644
index 27f492590..000000000
--- a/0002-x86-fpu-xstate-Define-new-macros-for-supervisor-and-.patch
+++ /dev/null
@@ -1,184 +0,0 @@
-From 6b03d53f4931a4fc6b58f570f7326a12868903cf Mon Sep 17 00:00:00 2001
-From: Fenghua Yu <fenghua.yu@intel.com>
-Date: Thu, 10 Nov 2016 10:13:56 -0800
-Subject: [PATCH 02/47] x86/fpu/xstate: Define new macros for supervisor and
- user xstates
-
-XCNTXT_MASK is 'all supported xfeatures' before introducing supervisor
-xstates.  Rename it to XFEATURE_MASK_USER_SUPPORTED to make clear that
-these are user xstates.
-
-XFEATURE_MASK_SUPERVISOR is replaced with the following:
-- XFEATURE_MASK_SUPERVISOR_SUPPORTED: Currently nothing.  ENQCMD and
-  Control-flow Enforcement Technology (CET) will be introduced in separate
-  series.
-- XFEATURE_MASK_SUPERVISOR_UNSUPPORTED: Currently only Processor Trace.
-- XFEATURE_MASK_SUPERVISOR_ALL: the combination of above.
-
-v3:
-- Change SUPPORTED_XFEATURES_*, UNSUPPORTED_XFEATURES_*, ALL_XFEATURES_* to
-  XFEATURE_MASK_*.
-
-Signed-off-by: Fenghua Yu <fenghua.yu@intel.com>
-Co-developed-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
-Reviewed-by: Tony Luck <tony.luck@intel.com>
----
- arch/x86/include/asm/fpu/xstate.h | 36 ++++++++++++++++++++-----------
- arch/x86/kernel/fpu/init.c        |  3 ++-
- arch/x86/kernel/fpu/xstate.c      | 26 +++++++++++-----------
- 3 files changed, 38 insertions(+), 27 deletions(-)
-
-diff --git a/arch/x86/include/asm/fpu/xstate.h b/arch/x86/include/asm/fpu/xstate.h
-index fc4db51f3b53..b08fa823425f 100644
---- a/arch/x86/include/asm/fpu/xstate.h
-+++ b/arch/x86/include/asm/fpu/xstate.h
-@@ -21,19 +21,29 @@
- #define XSAVE_YMM_SIZE	    256
- #define XSAVE_YMM_OFFSET    (XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET)
- 
--/* Supervisor features */
--#define XFEATURE_MASK_SUPERVISOR (XFEATURE_MASK_PT)
--
--/* All currently supported features */
--#define XCNTXT_MASK		(XFEATURE_MASK_FP | \
--				 XFEATURE_MASK_SSE | \
--				 XFEATURE_MASK_YMM | \
--				 XFEATURE_MASK_OPMASK | \
--				 XFEATURE_MASK_ZMM_Hi256 | \
--				 XFEATURE_MASK_Hi16_ZMM	 | \
--				 XFEATURE_MASK_PKRU | \
--				 XFEATURE_MASK_BNDREGS | \
--				 XFEATURE_MASK_BNDCSR)
-+/* All currently supported user features */
-+#define XFEATURE_MASK_USER_SUPPORTED (XFEATURE_MASK_FP | \
-+				      XFEATURE_MASK_SSE | \
-+				      XFEATURE_MASK_YMM | \
-+				      XFEATURE_MASK_OPMASK | \
-+				      XFEATURE_MASK_ZMM_Hi256 | \
-+				      XFEATURE_MASK_Hi16_ZMM	 | \
-+				      XFEATURE_MASK_PKRU | \
-+				      XFEATURE_MASK_BNDREGS | \
-+				      XFEATURE_MASK_BNDCSR)
-+
-+/* All currently supported supervisor features */
-+#define XFEATURE_MASK_SUPERVISOR_SUPPORTED (0)
-+
-+/*
-+ * Unsupported supervisor features. When a supervisor feature in this mask is
-+ * supported in the future, move it to the supported supervisor feature mask.
-+ */
-+#define XFEATURE_MASK_SUPERVISOR_UNSUPPORTED (XFEATURE_MASK_PT)
-+
-+/* All supervisor states including supported and unsupported states. */
-+#define XFEATURE_MASK_SUPERVISOR_ALL (XFEATURE_MASK_SUPERVISOR_SUPPORTED | \
-+				      XFEATURE_MASK_SUPERVISOR_UNSUPPORTED)
- 
- #ifdef CONFIG_X86_64
- #define REX_PREFIX	"0x48, "
-diff --git a/arch/x86/kernel/fpu/init.c b/arch/x86/kernel/fpu/init.c
-index 6ce7e0a23268..61ddc3a5e5c2 100644
---- a/arch/x86/kernel/fpu/init.c
-+++ b/arch/x86/kernel/fpu/init.c
-@@ -224,7 +224,8 @@ static void __init fpu__init_system_xstate_size_legacy(void)
-  */
- u64 __init fpu__get_supported_xfeatures_mask(void)
- {
--	return XCNTXT_MASK;
-+	return XFEATURE_MASK_USER_SUPPORTED |
-+	       XFEATURE_MASK_SUPERVISOR_SUPPORTED;
- }
- 
- /* Legacy code to initialize eager fpu mode. */
-diff --git a/arch/x86/kernel/fpu/xstate.c b/arch/x86/kernel/fpu/xstate.c
-index 56a4379a2001..f3093c63c584 100644
---- a/arch/x86/kernel/fpu/xstate.c
-+++ b/arch/x86/kernel/fpu/xstate.c
-@@ -208,14 +208,13 @@ void fpu__init_cpu_xstate(void)
- 	if (!boot_cpu_has(X86_FEATURE_XSAVE) || !xfeatures_mask)
- 		return;
- 	/*
--	 * Make it clear that XSAVES supervisor states are not yet
--	 * implemented should anyone expect it to work by changing
--	 * bits in XFEATURE_MASK_* macros and XCR0.
-+	 * Unsupported supervisor xstates should not be found in
-+	 * the xfeatures mask.
- 	 */
--	WARN_ONCE((xfeatures_mask & XFEATURE_MASK_SUPERVISOR),
--		"x86/fpu: XSAVES supervisor states are not yet implemented.\n");
-+	WARN_ONCE((xfeatures_mask & XFEATURE_MASK_SUPERVISOR_UNSUPPORTED),
-+		  "x86/fpu: Found unsupported supervisor xstates.\n");
- 
--	xfeatures_mask &= ~XFEATURE_MASK_SUPERVISOR;
-+	xfeatures_mask &= ~XFEATURE_MASK_SUPERVISOR_UNSUPPORTED;
- 
- 	cr4_set_bits(X86_CR4_OSXSAVE);
- 	xsetbv(XCR_XFEATURE_ENABLED_MASK, xfeatures_mask);
-@@ -438,7 +437,7 @@ static int xfeature_uncompacted_offset(int xfeature_nr)
- 	 * format. Checking a supervisor state's uncompacted offset is
- 	 * an error.
- 	 */
--	if (XFEATURE_MASK_SUPERVISOR & BIT_ULL(xfeature_nr)) {
-+	if (XFEATURE_MASK_SUPERVISOR_ALL & BIT_ULL(xfeature_nr)) {
- 		WARN_ONCE(1, "No fixed offset for xstate %d\n", xfeature_nr);
- 		return -1;
- 	}
-@@ -475,7 +474,7 @@ int using_compacted_format(void)
- int validate_user_xstate_header(const struct xstate_header *hdr)
- {
- 	/* No unknown or supervisor features may be set */
--	if (hdr->xfeatures & (~xfeatures_mask | XFEATURE_MASK_SUPERVISOR))
-+	if (hdr->xfeatures & ~(xfeatures_mask & XFEATURE_MASK_USER_SUPPORTED))
- 		return -EINVAL;
- 
- 	/* Userspace must use the uncompacted format */
-@@ -768,7 +767,8 @@ void __init fpu__init_system_xstate(void)
- 	 * Update info used for ptrace frames; use standard-format size and no
- 	 * supervisor xstates:
- 	 */
--	update_regset_xstate_info(fpu_user_xstate_size,	xfeatures_mask & ~XFEATURE_MASK_SUPERVISOR);
-+	update_regset_xstate_info(fpu_user_xstate_size,
-+				  xfeatures_mask & XFEATURE_MASK_USER_SUPPORTED);
- 
- 	fpu__init_prepare_fx_sw_frame();
- 	setup_init_fpu_buf();
-@@ -1010,7 +1010,7 @@ int copy_xstate_to_kernel(void *kbuf, struct xregs_state *xsave, unsigned int of
- 	 */
- 	memset(&header, 0, sizeof(header));
- 	header.xfeatures = xsave->header.xfeatures;
--	header.xfeatures &= ~XFEATURE_MASK_SUPERVISOR;
-+	header.xfeatures &= XFEATURE_MASK_USER_SUPPORTED;
- 
- 	if (header.xfeatures & XFEATURE_MASK_FP)
- 		copy_part(0, off_mxcsr,
-@@ -1090,7 +1090,7 @@ int copy_xstate_to_user(void __user *ubuf, struct xregs_state *xsave, unsigned i
- 	 */
- 	memset(&header, 0, sizeof(header));
- 	header.xfeatures = xsave->header.xfeatures;
--	header.xfeatures &= ~XFEATURE_MASK_SUPERVISOR;
-+	header.xfeatures &= XFEATURE_MASK_USER_SUPPORTED;
- 
- 	/*
- 	 * Copy xregs_state->header:
-@@ -1183,7 +1183,7 @@ int copy_kernel_to_xstate(struct xregs_state *xsave, const void *kbuf)
- 	 * The state that came in from userspace was user-state only.
- 	 * Mask all the user states out of 'xfeatures':
- 	 */
--	xsave->header.xfeatures &= XFEATURE_MASK_SUPERVISOR;
-+	xsave->header.xfeatures &= XFEATURE_MASK_SUPERVISOR_ALL;
- 
- 	/*
- 	 * Add back in the features that came in from userspace:
-@@ -1239,7 +1239,7 @@ int copy_user_to_xstate(struct xregs_state *xsave, const void __user *ubuf)
- 	 * The state that came in from userspace was user-state only.
- 	 * Mask all the user states out of 'xfeatures':
- 	 */
--	xsave->header.xfeatures &= XFEATURE_MASK_SUPERVISOR;
-+	xsave->header.xfeatures &= XFEATURE_MASK_SUPERVISOR_ALL;
- 
- 	/*
- 	 * Add back in the features that came in from userspace:
--- 
-2.26.2
-
diff --git a/0013-x86-fpu-xstate-Introduce-CET-MSR-XSAVES-supervisor-s.patch b/0003-x86-fpu-xstate-Introduce-CET-MSR-XSAVES-supervisor-s.patch
similarity index 89%
rename from 0013-x86-fpu-xstate-Introduce-CET-MSR-XSAVES-supervisor-s.patch
rename to 0003-x86-fpu-xstate-Introduce-CET-MSR-XSAVES-supervisor-s.patch
index 4708cbbca..0ca2b4a36 100644
--- a/0013-x86-fpu-xstate-Introduce-CET-MSR-XSAVES-supervisor-s.patch
+++ b/0003-x86-fpu-xstate-Introduce-CET-MSR-XSAVES-supervisor-s.patch
@@ -1,7 +1,7 @@
-From 86722a77bc955478c0399d653937d522893b8991 Mon Sep 17 00:00:00 2001
+From 2727991144fd8f58f7a9a24624bea2aaea9db172 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Thu, 10 Nov 2016 10:13:56 -0800
-Subject: [PATCH 13/47] x86/fpu/xstate: Introduce CET MSR XSAVES supervisor
+Subject: [PATCH 03/40] x86/fpu/xstate: Introduce CET MSR XSAVES supervisor
  states
 
 Control-flow Enforcement Technology (CET) adds five MSRs.  Introduce them
@@ -14,17 +14,20 @@ and their XSAVES supervisor states:
     MSR_IA32_PL2_SSP (Privilege Level 2 Shadow Stack pointer).
 
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Kees Cook <keescook@chromium.org>
+
+v11:
+- Drop MSR_IA32 prefix for individual bits, and use BIT_ULL().
+- Drop MSR_IA32_CET_BITMAP_MASK.
 
 v6:
 - Remove __packed from struct cet_user_state, struct cet_kernel_state.
 ---
  arch/x86/include/asm/fpu/types.h            | 22 ++++++++++++++++++
  arch/x86/include/asm/fpu/xstate.h           |  5 +++--
- arch/x86/include/asm/msr-index.h            | 18 +++++++++++++++
+ arch/x86/include/asm/msr-index.h            | 17 ++++++++++++++
  arch/x86/include/uapi/asm/processor-flags.h |  2 ++
  arch/x86/kernel/fpu/xstate.c                | 25 +++++++++++++++++++--
- 5 files changed, 68 insertions(+), 4 deletions(-)
+ 5 files changed, 67 insertions(+), 4 deletions(-)
 
 diff --git a/arch/x86/include/asm/fpu/types.h b/arch/x86/include/asm/fpu/types.h
 index f098f6cab94b..d7ef4d9c7ad5 100644
@@ -95,10 +98,10 @@ index 422d8369012a..db89d796b22e 100644
  /* All supervisor states including supported and unsupported states. */
  #define XFEATURE_MASK_SUPERVISOR_ALL (XFEATURE_MASK_SUPERVISOR_SUPPORTED | \
 diff --git a/arch/x86/include/asm/msr-index.h b/arch/x86/include/asm/msr-index.h
-index 12c9684d59ba..47f603729543 100644
+index e8370e64a155..3a71a072d8d3 100644
 --- a/arch/x86/include/asm/msr-index.h
 +++ b/arch/x86/include/asm/msr-index.h
-@@ -885,4 +885,22 @@
+@@ -892,4 +892,21 @@
  #define MSR_VM_IGNNE                    0xc0010115
  #define MSR_VM_HSAVE_PA                 0xc0010117
  
@@ -112,13 +115,12 @@ index 12c9684d59ba..47f603729543 100644
 +#define MSR_IA32_INT_SSP_TAB	0x6a8 /* exception shstk table */
 +
 +/* MSR_IA32_U_CET and MSR_IA32_S_CET bits */
-+#define MSR_IA32_CET_SHSTK_EN		0x0000000000000001ULL
-+#define MSR_IA32_CET_WRSS_EN		0x0000000000000002ULL
-+#define MSR_IA32_CET_ENDBR_EN		0x0000000000000004ULL
-+#define MSR_IA32_CET_LEG_IW_EN		0x0000000000000008ULL
-+#define MSR_IA32_CET_NO_TRACK_EN	0x0000000000000010ULL
-+#define MSR_IA32_CET_WAIT_ENDBR	0x00000000000000800UL
-+#define MSR_IA32_CET_BITMAP_MASK	0xfffffffffffff000ULL
++#define CET_SHSTK_EN		BIT_ULL(0)
++#define CET_WRSS_EN		BIT_ULL(1)
++#define CET_ENDBR_EN		BIT_ULL(2)
++#define CET_LEG_IW_EN		BIT_ULL(3)
++#define CET_NO_TRACK_EN		BIT_ULL(4)
++#define CET_WAIT_ENDBR		BIT_ULL(11)
 +
  #endif /* _ASM_X86_MSR_INDEX_H */
 diff --git a/arch/x86/include/uapi/asm/processor-flags.h b/arch/x86/include/uapi/asm/processor-flags.h
@@ -135,7 +137,7 @@ index bcba3c643e63..a8df907e8017 100644
  /*
   * x86-64 Task Priority Register, CR8
 diff --git a/arch/x86/kernel/fpu/xstate.c b/arch/x86/kernel/fpu/xstate.c
-index bda2e5eaca0e..85b7f295c399 100644
+index ad3a2b37927d..505dff739a24 100644
 --- a/arch/x86/kernel/fpu/xstate.c
 +++ b/arch/x86/kernel/fpu/xstate.c
 @@ -38,6 +38,9 @@ static const char *xfeature_names[] =
diff --git a/0003-x86-fpu-xstate-Separate-user-and-supervisor-xfeature.patch b/0003-x86-fpu-xstate-Separate-user-and-supervisor-xfeature.patch
deleted file mode 100644
index d2ece6d04..000000000
--- a/0003-x86-fpu-xstate-Separate-user-and-supervisor-xfeature.patch
+++ /dev/null
@@ -1,353 +0,0 @@
-From 973a93ce4dc3ef0e3a6d341a2a0cbb2493808359 Mon Sep 17 00:00:00 2001
-From: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Date: Wed, 13 Dec 2017 16:08:28 -0800
-Subject: [PATCH 03/47] x86/fpu/xstate: Separate user and supervisor xfeatures
- mask
-
-Before the introduction of XSAVES supervisor states, 'xfeatures_mask' is
-used at various places to determine XSAVE buffer components and XCR0 bits.
-It contains only user xstates.  To support supervisor xstates, it is
-necessary to separate user and supervisor xstates:
-
-- First, change 'xfeatures_mask' to 'xfeatures_mask_all', which represents
-  the full set of bits that should ever be set in a kernel XSAVE buffer.
-- Introduce xfeatures_mask_supervisor() and xfeatures_mask_user() to
-  extract relevant xfeatures from xfeatures_mask_all.
-
-v3:
-- Change xfeature_enabled() type from static int to static bool while at
-  it.
-
-v2:
-- Fix typo in commit log.
-- Move xfeatures_mask_supervisor() from xstate.c to xstate.h.
-- Remove printing of user xstates from fpu__init_system_xstate().
-
-Co-developed-by: Fenghua Yu <fenghua.yu@intel.com>
-Signed-off-by: Fenghua Yu <fenghua.yu@intel.com>
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
-Reviewed-by: Tony Luck <tony.luck@intel.com>
----
- arch/x86/include/asm/fpu/internal.h |  2 +-
- arch/x86/include/asm/fpu/xstate.h   | 13 ++++-
- arch/x86/kernel/fpu/signal.c        | 16 +++++--
- arch/x86/kernel/fpu/xstate.c        | 73 +++++++++++++++++------------
- 4 files changed, 67 insertions(+), 37 deletions(-)
-
-diff --git a/arch/x86/include/asm/fpu/internal.h b/arch/x86/include/asm/fpu/internal.h
-index 44c48e34d799..ccb1bb32ad7d 100644
---- a/arch/x86/include/asm/fpu/internal.h
-+++ b/arch/x86/include/asm/fpu/internal.h
-@@ -92,7 +92,7 @@ static inline void fpstate_init_xstate(struct xregs_state *xsave)
- 	 * XRSTORS requires these bits set in xcomp_bv, or it will
- 	 * trigger #GP:
- 	 */
--	xsave->header.xcomp_bv = XCOMP_BV_COMPACTED_FORMAT | xfeatures_mask;
-+	xsave->header.xcomp_bv = XCOMP_BV_COMPACTED_FORMAT | xfeatures_mask_all;
- }
- 
- static inline void fpstate_init_fxstate(struct fxregs_state *fx)
-diff --git a/arch/x86/include/asm/fpu/xstate.h b/arch/x86/include/asm/fpu/xstate.h
-index b08fa823425f..92104b298d77 100644
---- a/arch/x86/include/asm/fpu/xstate.h
-+++ b/arch/x86/include/asm/fpu/xstate.h
-@@ -51,7 +51,18 @@
- #define REX_PREFIX
- #endif
- 
--extern u64 xfeatures_mask;
-+extern u64 xfeatures_mask_all;
-+
-+static inline u64 xfeatures_mask_supervisor(void)
-+{
-+	return xfeatures_mask_all & XFEATURE_MASK_SUPERVISOR_SUPPORTED;
-+}
-+
-+static inline u64 xfeatures_mask_user(void)
-+{
-+	return xfeatures_mask_all & XFEATURE_MASK_USER_SUPPORTED;
-+}
-+
- extern u64 xstate_fx_sw_bytes[USER_XSTATE_FX_SW_WORDS];
- 
- extern void __init update_regset_xstate_info(unsigned int size,
-diff --git a/arch/x86/kernel/fpu/signal.c b/arch/x86/kernel/fpu/signal.c
-index 585e3651b98f..3df0cfae535f 100644
---- a/arch/x86/kernel/fpu/signal.c
-+++ b/arch/x86/kernel/fpu/signal.c
-@@ -252,13 +252,17 @@ sanitize_restored_xstate(union fpregs_state *state,
-  */
- static int copy_user_to_fpregs_zeroing(void __user *buf, u64 xbv, int fx_only)
- {
-+	u64 init_bv;
-+
- 	if (use_xsave()) {
- 		if (fx_only) {
--			u64 init_bv = xfeatures_mask & ~XFEATURE_MASK_FPSSE;
-+			init_bv = xfeatures_mask_user() & ~XFEATURE_MASK_FPSSE;
-+
- 			copy_kernel_to_xregs(&init_fpstate.xsave, init_bv);
- 			return copy_user_to_fxregs(buf);
- 		} else {
--			u64 init_bv = xfeatures_mask & ~xbv;
-+			init_bv = xfeatures_mask_user() & ~xbv;
-+
- 			if (unlikely(init_bv))
- 				copy_kernel_to_xregs(&init_fpstate.xsave, init_bv);
- 			return copy_user_to_xregs(buf, xbv);
-@@ -358,7 +362,7 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
- 
- 
- 	if (use_xsave() && !fx_only) {
--		u64 init_bv = xfeatures_mask & ~xfeatures;
-+		u64 init_bv = xfeatures_mask_user() & ~xfeatures;
- 
- 		if (using_compacted_format()) {
- 			ret = copy_user_to_xstate(&fpu->state.xsave, buf_fx);
-@@ -389,7 +393,9 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
- 
- 		fpregs_lock();
- 		if (use_xsave()) {
--			u64 init_bv = xfeatures_mask & ~XFEATURE_MASK_FPSSE;
-+			u64 init_bv;
-+
-+			init_bv = xfeatures_mask_user() & ~XFEATURE_MASK_FPSSE;
- 			copy_kernel_to_xregs(&init_fpstate.xsave, init_bv);
- 		}
- 
-@@ -465,7 +471,7 @@ void fpu__init_prepare_fx_sw_frame(void)
- 
- 	fx_sw_reserved.magic1 = FP_XSTATE_MAGIC1;
- 	fx_sw_reserved.extended_size = size;
--	fx_sw_reserved.xfeatures = xfeatures_mask;
-+	fx_sw_reserved.xfeatures = xfeatures_mask_user();
- 	fx_sw_reserved.xstate_size = fpu_user_xstate_size;
- 
- 	if (IS_ENABLED(CONFIG_IA32_EMULATION) ||
-diff --git a/arch/x86/kernel/fpu/xstate.c b/arch/x86/kernel/fpu/xstate.c
-index f3093c63c584..18e0e2a4c890 100644
---- a/arch/x86/kernel/fpu/xstate.c
-+++ b/arch/x86/kernel/fpu/xstate.c
-@@ -54,9 +54,10 @@ static short xsave_cpuid_features[] __initdata = {
- };
- 
- /*
-- * Mask of xstate features supported by the CPU and the kernel:
-+ * This represents the full set of bits that should ever be set in a kernel
-+ * XSAVE buffer, both supervisor and user xstates.
-  */
--u64 xfeatures_mask __read_mostly;
-+u64 xfeatures_mask_all __read_mostly;
- 
- static unsigned int xstate_offsets[XFEATURE_MAX] = { [ 0 ... XFEATURE_MAX - 1] = -1};
- static unsigned int xstate_sizes[XFEATURE_MAX]   = { [ 0 ... XFEATURE_MAX - 1] = -1};
-@@ -76,7 +77,7 @@ unsigned int fpu_user_xstate_size;
-  */
- int cpu_has_xfeatures(u64 xfeatures_needed, const char **feature_name)
- {
--	u64 xfeatures_missing = xfeatures_needed & ~xfeatures_mask;
-+	u64 xfeatures_missing = xfeatures_needed & ~xfeatures_mask_all;
- 
- 	if (unlikely(feature_name)) {
- 		long xfeature_idx, max_idx;
-@@ -150,7 +151,7 @@ void fpstate_sanitize_xstate(struct fpu *fpu)
- 	 * None of the feature bits are in init state. So nothing else
- 	 * to do for us, as the memory layout is up to date.
- 	 */
--	if ((xfeatures & xfeatures_mask) == xfeatures_mask)
-+	if ((xfeatures & xfeatures_mask_all) == xfeatures_mask_all)
- 		return;
- 
- 	/*
-@@ -177,7 +178,7 @@ void fpstate_sanitize_xstate(struct fpu *fpu)
- 	 * in a special way already:
- 	 */
- 	feature_bit = 0x2;
--	xfeatures = (xfeatures_mask & ~xfeatures) >> 2;
-+	xfeatures = (xfeatures_mask_user() & ~xfeatures) >> 2;
- 
- 	/*
- 	 * Update all the remaining memory layouts according to their
-@@ -205,19 +206,28 @@ void fpstate_sanitize_xstate(struct fpu *fpu)
-  */
- void fpu__init_cpu_xstate(void)
- {
--	if (!boot_cpu_has(X86_FEATURE_XSAVE) || !xfeatures_mask)
-+	u64 unsup_bits;
-+
-+	if (!boot_cpu_has(X86_FEATURE_XSAVE) || !xfeatures_mask_all)
- 		return;
- 	/*
- 	 * Unsupported supervisor xstates should not be found in
- 	 * the xfeatures mask.
- 	 */
--	WARN_ONCE((xfeatures_mask & XFEATURE_MASK_SUPERVISOR_UNSUPPORTED),
--		  "x86/fpu: Found unsupported supervisor xstates.\n");
-+	unsup_bits = xfeatures_mask_all & XFEATURE_MASK_SUPERVISOR_UNSUPPORTED;
-+	WARN_ONCE(unsup_bits, "x86/fpu: Found unsupported supervisor xstates: 0x%llx\n",
-+		  unsup_bits);
- 
--	xfeatures_mask &= ~XFEATURE_MASK_SUPERVISOR_UNSUPPORTED;
-+	xfeatures_mask_all &= ~XFEATURE_MASK_SUPERVISOR_UNSUPPORTED;
- 
- 	cr4_set_bits(X86_CR4_OSXSAVE);
--	xsetbv(XCR_XFEATURE_ENABLED_MASK, xfeatures_mask);
-+
-+	/*
-+	 * XCR_XFEATURE_ENABLED_MASK (aka. XCR0) sets user features
-+	 * managed by XSAVE{C, OPT, S} and XRSTOR{S}.  Only XSAVE user
-+	 * states can be set here.
-+	 */
-+	xsetbv(XCR_XFEATURE_ENABLED_MASK, xfeatures_mask_user());
- }
- 
- /*
-@@ -225,9 +235,9 @@ void fpu__init_cpu_xstate(void)
-  * functions here: one for user xstates and the other for
-  * system xstates.  For now, they are the same.
-  */
--static int xfeature_enabled(enum xfeature xfeature)
-+static bool xfeature_enabled(enum xfeature xfeature)
- {
--	return !!(xfeatures_mask & (1UL << xfeature));
-+	return xfeatures_mask_all & BIT_ULL(xfeature);
- }
- 
- /*
-@@ -414,7 +424,7 @@ static void __init setup_init_fpu_buf(void)
- 
- 	if (boot_cpu_has(X86_FEATURE_XSAVES))
- 		init_fpstate.xsave.header.xcomp_bv = XCOMP_BV_COMPACTED_FORMAT |
--						     xfeatures_mask;
-+						     xfeatures_mask_all;
- 
- 	/*
- 	 * Init all the features state with header.xfeatures being 0x0
-@@ -474,7 +484,7 @@ int using_compacted_format(void)
- int validate_user_xstate_header(const struct xstate_header *hdr)
- {
- 	/* No unknown or supervisor features may be set */
--	if (hdr->xfeatures & ~(xfeatures_mask & XFEATURE_MASK_USER_SUPPORTED))
-+	if (hdr->xfeatures & ~xfeatures_mask_user())
- 		return -EINVAL;
- 
- 	/* Userspace must use the uncompacted format */
-@@ -609,7 +619,7 @@ static void do_extra_xstate_size_checks(void)
- 
- 
- /*
-- * Get total size of enabled xstates in XCR0/xfeatures_mask.
-+ * Get total size of enabled xstates in XCR0 | IA32_XSS.
-  *
-  * Note the SDM's wording here.  "sub-function 0" only enumerates
-  * the size of the *user* states.  If we use it to size a buffer
-@@ -699,7 +709,7 @@ static int __init init_xstate_size(void)
-  */
- static void fpu__init_disable_system_xstate(void)
- {
--	xfeatures_mask = 0;
-+	xfeatures_mask_all = 0;
- 	cr4_clear_bits(X86_CR4_OSXSAVE);
- 	setup_clear_cpu_cap(X86_FEATURE_XSAVE);
- }
-@@ -734,16 +744,21 @@ void __init fpu__init_system_xstate(void)
- 		return;
- 	}
- 
-+	/*
-+	 * Find user xstates supported by the processor.
-+	 */
- 	cpuid_count(XSTATE_CPUID, 0, &eax, &ebx, &ecx, &edx);
--	xfeatures_mask = eax + ((u64)edx << 32);
-+	xfeatures_mask_all = eax + ((u64)edx << 32);
- 
--	if ((xfeatures_mask & XFEATURE_MASK_FPSSE) != XFEATURE_MASK_FPSSE) {
-+	/* Place supervisor features in xfeatures_mask_all here */
-+	if ((xfeatures_mask_user() & XFEATURE_MASK_FPSSE) != XFEATURE_MASK_FPSSE) {
- 		/*
- 		 * This indicates that something really unexpected happened
- 		 * with the enumeration.  Disable XSAVE and try to continue
- 		 * booting without it.  This is too early to BUG().
- 		 */
--		pr_err("x86/fpu: FP/SSE not present amongst the CPU's xstate features: 0x%llx.\n", xfeatures_mask);
-+		pr_err("x86/fpu: FP/SSE not present amongst the CPU's xstate features: 0x%llx.\n",
-+		       xfeatures_mask_all);
- 		goto out_disable;
- 	}
- 
-@@ -752,10 +767,10 @@ void __init fpu__init_system_xstate(void)
- 	 */
- 	for (i = 0; i < ARRAY_SIZE(xsave_cpuid_features); i++) {
- 		if (!boot_cpu_has(xsave_cpuid_features[i]))
--			xfeatures_mask &= ~BIT(i);
-+			xfeatures_mask_all &= ~BIT_ULL(i);
- 	}
- 
--	xfeatures_mask &= fpu__get_supported_xfeatures_mask();
-+	xfeatures_mask_all &= fpu__get_supported_xfeatures_mask();
- 
- 	/* Enable xstate instructions to be able to continue with initialization: */
- 	fpu__init_cpu_xstate();
-@@ -767,8 +782,7 @@ void __init fpu__init_system_xstate(void)
- 	 * Update info used for ptrace frames; use standard-format size and no
- 	 * supervisor xstates:
- 	 */
--	update_regset_xstate_info(fpu_user_xstate_size,
--				  xfeatures_mask & XFEATURE_MASK_USER_SUPPORTED);
-+	update_regset_xstate_info(fpu_user_xstate_size, xfeatures_mask_user());
- 
- 	fpu__init_prepare_fx_sw_frame();
- 	setup_init_fpu_buf();
-@@ -776,7 +790,7 @@ void __init fpu__init_system_xstate(void)
- 	print_xstate_offset_size();
- 
- 	pr_info("x86/fpu: Enabled xstate features 0x%llx, context size is %d bytes, using '%s' format.\n",
--		xfeatures_mask,
-+		xfeatures_mask_all,
- 		fpu_kernel_xstate_size,
- 		boot_cpu_has(X86_FEATURE_XSAVES) ? "compacted" : "standard");
- 	return;
-@@ -795,7 +809,7 @@ void fpu__resume_cpu(void)
- 	 * Restore XCR0 on xsave capable CPUs:
- 	 */
- 	if (boot_cpu_has(X86_FEATURE_XSAVE))
--		xsetbv(XCR_XFEATURE_ENABLED_MASK, xfeatures_mask);
-+		xsetbv(XCR_XFEATURE_ENABLED_MASK, xfeatures_mask_user());
- }
- 
- /*
-@@ -840,10 +854,9 @@ void *get_xsave_addr(struct xregs_state *xsave, int xfeature_nr)
- 
- 	/*
- 	 * We should not ever be requesting features that we
--	 * have not enabled.  Remember that xfeatures_mask is
--	 * what we write to the XCR0 register.
-+	 * have not enabled.
- 	 */
--	WARN_ONCE(!(xfeatures_mask & BIT_ULL(xfeature_nr)),
-+	WARN_ONCE(!(xfeatures_mask_all & BIT_ULL(xfeature_nr)),
- 		  "get of unsupported state");
- 	/*
- 	 * This assumes the last 'xsave*' instruction to
-@@ -1010,7 +1023,7 @@ int copy_xstate_to_kernel(void *kbuf, struct xregs_state *xsave, unsigned int of
- 	 */
- 	memset(&header, 0, sizeof(header));
- 	header.xfeatures = xsave->header.xfeatures;
--	header.xfeatures &= XFEATURE_MASK_USER_SUPPORTED;
-+	header.xfeatures &= xfeatures_mask_user();
- 
- 	if (header.xfeatures & XFEATURE_MASK_FP)
- 		copy_part(0, off_mxcsr,
-@@ -1090,7 +1103,7 @@ int copy_xstate_to_user(void __user *ubuf, struct xregs_state *xsave, unsigned i
- 	 */
- 	memset(&header, 0, sizeof(header));
- 	header.xfeatures = xsave->header.xfeatures;
--	header.xfeatures &= XFEATURE_MASK_USER_SUPPORTED;
-+	header.xfeatures &= xfeatures_mask_user();
- 
- 	/*
- 	 * Copy xregs_state->header:
--- 
-2.26.2
-
diff --git a/0014-x86-cet-Add-control-protection-fault-handler.patch b/0004-x86-cet-Add-control-protection-fault-handler.patch
similarity index 55%
rename from 0014-x86-cet-Add-control-protection-fault-handler.patch
rename to 0004-x86-cet-Add-control-protection-fault-handler.patch
index c20b3d1b7..0708c3a32 100644
--- a/0014-x86-cet-Add-control-protection-fault-handler.patch
+++ b/0004-x86-cet-Add-control-protection-fault-handler.patch
@@ -1,7 +1,7 @@
-From 5482399434ea919130c6825ef4235ecd9fcd470d Mon Sep 17 00:00:00 2001
+From 268d645a0a2cccc3a76f01dff014b38b10f65a0b Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Date: Thu, 10 Nov 2016 13:17:46 -0800
-Subject: [PATCH 14/47] x86/cet: Add control-protection fault handler
+Date: Mon, 15 Jun 2020 14:26:27 -0700
+Subject: [PATCH 04/40] x86/cet: Add control-protection fault handler
 
 A control-protection fault is triggered when a control-flow transfer
 attempt violates Shadow Stack or Indirect Branch Tracking constraints.
@@ -14,7 +14,6 @@ protection fault handler.  It provides the si_code SEGV_CPERR to the signal
 handler.
 
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Kees Cook <keescook@chromium.org>
 
 v10:
 - Change CONFIG_X86_64 to CONFIG_X86_INTEL_CET.
@@ -22,68 +21,39 @@ v10:
 v9:
 - Add Shadow Stack pointer to the fault printout.
 ---
- arch/x86/entry/entry_64.S          |  2 +-
- arch/x86/include/asm/traps.h       |  5 +++
- arch/x86/kernel/idt.c              |  4 ++
+ arch/x86/include/asm/idtentry.h    |  4 +++
+ arch/x86/kernel/idt.c              |  4 +++
  arch/x86/kernel/signal_compat.c    |  2 +-
- arch/x86/kernel/traps.c            | 59 ++++++++++++++++++++++++++++++
+ arch/x86/kernel/traps.c            | 56 ++++++++++++++++++++++++++++++
  include/uapi/asm-generic/siginfo.h |  3 +-
- 6 files changed, 72 insertions(+), 3 deletions(-)
+ 5 files changed, 67 insertions(+), 2 deletions(-)
 
-diff --git a/arch/x86/entry/entry_64.S b/arch/x86/entry/entry_64.S
-index 3063aa9090f9..b260e3eaecda 100644
---- a/arch/x86/entry/entry_64.S
-+++ b/arch/x86/entry/entry_64.S
-@@ -1034,7 +1034,7 @@ idtentry spurious_interrupt_bug		do_spurious_interrupt_bug	has_error_code=0
- idtentry coprocessor_error		do_coprocessor_error		has_error_code=0
- idtentry alignment_check		do_alignment_check		has_error_code=1
- idtentry simd_coprocessor_error		do_simd_coprocessor_error	has_error_code=0
--
-+idtentry control_protection		do_control_protection		has_error_code=1
+diff --git a/arch/x86/include/asm/idtentry.h b/arch/x86/include/asm/idtentry.h
+index 80d3b30d3ee3..bc068e85cbf8 100644
+--- a/arch/x86/include/asm/idtentry.h
++++ b/arch/x86/include/asm/idtentry.h
+@@ -536,6 +536,10 @@ DECLARE_IDTENTRY_ERRORCODE(X86_TRAP_SS,	exc_stack_segment);
+ DECLARE_IDTENTRY_ERRORCODE(X86_TRAP_GP,	exc_general_protection);
+ DECLARE_IDTENTRY_ERRORCODE(X86_TRAP_AC,	exc_alignment_check);
  
- 	/*
- 	 * Reload gs selector with exception handling
-diff --git a/arch/x86/include/asm/traps.h b/arch/x86/include/asm/traps.h
-index c26a7e1d8a2c..9bf804709ee6 100644
---- a/arch/x86/include/asm/traps.h
-+++ b/arch/x86/include/asm/traps.h
-@@ -35,6 +35,9 @@ asmlinkage void alignment_check(void);
- asmlinkage void machine_check(void);
- #endif /* CONFIG_X86_MCE */
- asmlinkage void simd_coprocessor_error(void);
 +#ifdef CONFIG_X86_INTEL_CET
-+asmlinkage void control_protection(void);
++DECLARE_IDTENTRY_ERRORCODE(X86_TRAP_CP, exc_control_protection);
 +#endif
- 
- #if defined(CONFIG_X86_64) && defined(CONFIG_XEN_PV)
- asmlinkage void xen_divide_error(void);
-@@ -86,6 +89,7 @@ dotraplinkage void do_simd_coprocessor_error(struct pt_regs *regs, long error_co
- dotraplinkage void do_iret_error(struct pt_regs *regs, long error_code);
- #endif
- dotraplinkage void do_mce(struct pt_regs *regs, long error_code);
-+dotraplinkage void do_control_protection(struct pt_regs *regs, long error_code);
- 
- #ifdef CONFIG_X86_64
- asmlinkage __visible notrace struct pt_regs *sync_regs(struct pt_regs *eregs);
-@@ -151,6 +155,7 @@ enum {
- 	X86_TRAP_AC,		/* 17, Alignment Check */
- 	X86_TRAP_MC,		/* 18, Machine Check */
- 	X86_TRAP_XF,		/* 19, SIMD Floating-Point Exception */
-+	X86_TRAP_CP = 21,	/* 21 Control Protection Fault */
- 	X86_TRAP_IRET = 32,	/* 32, IRET Exception */
- };
- 
++
+ /* Raw exception entries which need extra work */
+ DECLARE_IDTENTRY_RAW(X86_TRAP_UD,		exc_invalid_op);
+ DECLARE_IDTENTRY_RAW(X86_TRAP_BP,		exc_int3);
 diff --git a/arch/x86/kernel/idt.c b/arch/x86/kernel/idt.c
-index 87ef69a72c52..19160c8d734f 100644
+index 0db21206f2f3..286b36740432 100644
 --- a/arch/x86/kernel/idt.c
 +++ b/arch/x86/kernel/idt.c
-@@ -102,6 +102,10 @@ static const __initconst struct idt_data def_idts[] = {
+@@ -112,6 +112,10 @@ static const __initconst struct idt_data def_idts[] = {
  #elif defined(CONFIG_X86_32)
  	SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_32),
  #endif
 +
 +#ifdef CONFIG_X86_INTEL_CET
-+	INTG(X86_TRAP_CP,		control_protection),
++	INTG(X86_TRAP_CP,		asm_exc_control_protection),
 +#endif
  };
  
@@ -102,12 +72,12 @@ index 9ccbf0576cd0..c572a3de1037 100644
  	BUILD_BUG_ON(NSIGTRAP != 5);
  	BUILD_BUG_ON(NSIGCHLD != 6);
 diff --git a/arch/x86/kernel/traps.c b/arch/x86/kernel/traps.c
-index d54cffdc7cac..d2515dfbc178 100644
+index b7cb3e0716f7..074bcb411c04 100644
 --- a/arch/x86/kernel/traps.c
 +++ b/arch/x86/kernel/traps.c
-@@ -586,6 +586,65 @@ dotraplinkage void do_general_protection(struct pt_regs *regs, long error_code)
+@@ -598,6 +598,62 @@ DEFINE_IDTENTRY_ERRORCODE(exc_general_protection)
+ 	cond_local_irq_disable(regs);
  }
- NOKPROBE_SYMBOL(do_general_protection);
  
 +static const char * const control_protection_err[] = {
 +	"unknown",
@@ -124,12 +94,10 @@ index d54cffdc7cac..d2515dfbc178 100644
 + * protection is only enabled for the user mode.  This
 + * exception should not come from the kernel mode.
 + */
-+dotraplinkage void
-+do_control_protection(struct pt_regs *regs, long error_code)
++DEFINE_IDTENTRY_ERRORCODE(exc_control_protection)
 +{
 +	struct task_struct *tsk;
 +
-+	RCU_LOCKDEP_WARN(!rcu_is_watching(), "entry code didn't wake RCU");
 +	if (notify_die(DIE_TRAP, "control protection fault", regs,
 +		       error_code, X86_TRAP_CP, SIGSEGV) == NOTIFY_STOP)
 +		return;
@@ -166,13 +134,12 @@ index d54cffdc7cac..d2515dfbc178 100644
 +	force_sig_fault(SIGSEGV, SEGV_CPERR,
 +			(void __user *)uprobe_get_trap_addr(regs));
 +}
-+NOKPROBE_SYMBOL(do_control_protection);
 +
- dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)
+ static bool do_int3(struct pt_regs *regs)
  {
- 	if (poke_int3_handler(regs))
+ 	int res;
 diff --git a/include/uapi/asm-generic/siginfo.h b/include/uapi/asm-generic/siginfo.h
-index cb3d6c267181..693071dbe641 100644
+index cb3d6c267181..91e10cbe3bb0 100644
 --- a/include/uapi/asm-generic/siginfo.h
 +++ b/include/uapi/asm-generic/siginfo.h
 @@ -229,7 +229,8 @@ typedef struct siginfo {
@@ -180,7 +147,7 @@ index cb3d6c267181..693071dbe641 100644
  #define SEGV_ADIDERR	6	/* Disrupting MCD error */
  #define SEGV_ADIPERR	7	/* Precise MCD exception */
 -#define NSIGSEGV	7
-+#define SEGV_CPERR	8
++#define SEGV_CPERR	8	/* Control protection fault */
 +#define NSIGSEGV	8
  
  /*
diff --git a/0004-x86-fpu-xstate-Introduce-XSAVES-supervisor-states.patch b/0004-x86-fpu-xstate-Introduce-XSAVES-supervisor-states.patch
deleted file mode 100644
index dc0c79e3a..000000000
--- a/0004-x86-fpu-xstate-Introduce-XSAVES-supervisor-states.patch
+++ /dev/null
@@ -1,85 +0,0 @@
-From 18ab1746423145306069f2acb972197f723dc6b0 Mon Sep 17 00:00:00 2001
-From: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Date: Thu, 10 Nov 2016 10:13:56 -0800
-Subject: [PATCH 04/47] x86/fpu/xstate: Introduce XSAVES supervisor states
-
-Enable XSAVES supervisor states by setting MSR_IA32_XSS bits according to
-CPUID enumeration results.  Also revise comments at various places.
-
-v2:
-- Remove printing of supervisor xstates from fpu__init_system_xstate().
-
-Co-developed-by: Fenghua Yu <fenghua.yu@intel.com>
-Signed-off-by: Fenghua Yu <fenghua.yu@intel.com>
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
-Reviewed-by: Tony Luck <tony.luck@intel.com>
----
- arch/x86/kernel/fpu/xstate.c | 28 +++++++++++++++++++---------
- 1 file changed, 19 insertions(+), 9 deletions(-)
-
-diff --git a/arch/x86/kernel/fpu/xstate.c b/arch/x86/kernel/fpu/xstate.c
-index 18e0e2a4c890..95f09c2e8cd6 100644
---- a/arch/x86/kernel/fpu/xstate.c
-+++ b/arch/x86/kernel/fpu/xstate.c
-@@ -228,13 +228,14 @@ void fpu__init_cpu_xstate(void)
- 	 * states can be set here.
- 	 */
- 	xsetbv(XCR_XFEATURE_ENABLED_MASK, xfeatures_mask_user());
-+
-+	/*
-+	 * MSR_IA32_XSS sets supervisor states managed by XSAVES.
-+	 */
-+	if (boot_cpu_has(X86_FEATURE_XSAVES))
-+		wrmsrl(MSR_IA32_XSS, xfeatures_mask_supervisor());
- }
- 
--/*
-- * Note that in the future we will likely need a pair of
-- * functions here: one for user xstates and the other for
-- * system xstates.  For now, they are the same.
-- */
- static bool xfeature_enabled(enum xfeature xfeature)
- {
- 	return xfeatures_mask_all & BIT_ULL(xfeature);
-@@ -625,9 +626,6 @@ static void do_extra_xstate_size_checks(void)
-  * the size of the *user* states.  If we use it to size a buffer
-  * that we use 'XSAVES' on, we could potentially overflow the
-  * buffer because 'XSAVES' saves system states too.
-- *
-- * Note that we do not currently set any bits on IA32_XSS so
-- * 'XCR0 | IA32_XSS == XCR0' for now.
-  */
- static unsigned int __init get_xsaves_size(void)
- {
-@@ -750,7 +748,12 @@ void __init fpu__init_system_xstate(void)
- 	cpuid_count(XSTATE_CPUID, 0, &eax, &ebx, &ecx, &edx);
- 	xfeatures_mask_all = eax + ((u64)edx << 32);
- 
--	/* Place supervisor features in xfeatures_mask_all here */
-+	/*
-+	 * Find supervisor xstates supported by the processor.
-+	 */
-+	cpuid_count(XSTATE_CPUID, 1, &eax, &ebx, &ecx, &edx);
-+	xfeatures_mask_all |= ecx + ((u64)edx << 32);
-+
- 	if ((xfeatures_mask_user() & XFEATURE_MASK_FPSSE) != XFEATURE_MASK_FPSSE) {
- 		/*
- 		 * This indicates that something really unexpected happened
-@@ -810,6 +813,13 @@ void fpu__resume_cpu(void)
- 	 */
- 	if (boot_cpu_has(X86_FEATURE_XSAVE))
- 		xsetbv(XCR_XFEATURE_ENABLED_MASK, xfeatures_mask_user());
-+
-+	/*
-+	 * Restore IA32_XSS. The same CPUID bit enumerates support
-+	 * of XSAVES and MSR_IA32_XSS.
-+	 */
-+	if (boot_cpu_has(X86_FEATURE_XSAVES))
-+		wrmsrl(MSR_IA32_XSS, xfeatures_mask_supervisor());
- }
- 
- /*
--- 
-2.26.2
-
diff --git a/0015-x86-cet-shstk-Add-Kconfig-option-for-user-mode-Shado.patch b/0005-x86-cet-shstk-Add-Kconfig-option-for-user-mode-Shado.patch
similarity index 91%
rename from 0015-x86-cet-shstk-Add-Kconfig-option-for-user-mode-Shado.patch
rename to 0005-x86-cet-shstk-Add-Kconfig-option-for-user-mode-Shado.patch
index f07882a67..8fc21078a 100644
--- a/0015-x86-cet-shstk-Add-Kconfig-option-for-user-mode-Shado.patch
+++ b/0005-x86-cet-shstk-Add-Kconfig-option-for-user-mode-Shado.patch
@@ -1,7 +1,7 @@
-From ba4ba07816db79eb7a3b77283fe2d50074f0d42d Mon Sep 17 00:00:00 2001
+From a91ee1a1f1f393d2b4f759e5ac3647c8ac75bcbc Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 3 Oct 2017 12:55:03 -0700
-Subject: [PATCH 15/47] x86/cet/shstk: Add Kconfig option for user-mode Shadow
+Subject: [PATCH 05/40] x86/cet/shstk: Add Kconfig option for user-mode Shadow
  Stack
 
 Shadow Stack provides protection against function return address
@@ -24,10 +24,10 @@ v10:
  create mode 100755 scripts/as-x86_64-has-shadow-stack.sh
 
 diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
-index 2d3f963fd6f1..315647350fa2 100644
+index 883da0abf779..3dedb666d9f7 100644
 --- a/arch/x86/Kconfig
 +++ b/arch/x86/Kconfig
-@@ -1948,6 +1948,36 @@ config X86_INTEL_TSX_MODE_AUTO
+@@ -1926,6 +1926,36 @@ config X86_INTEL_TSX_MODE_AUTO
  	  side channel attacks- equals the tsx=auto command line parameter.
  endchoice
  
diff --git a/0005-x86-fpu-xstate-Define-new-functions-for-clearing-fpr.patch b/0005-x86-fpu-xstate-Define-new-functions-for-clearing-fpr.patch
deleted file mode 100644
index bb491e023..000000000
--- a/0005-x86-fpu-xstate-Define-new-functions-for-clearing-fpr.patch
+++ /dev/null
@@ -1,184 +0,0 @@
-From ecde7e8b453458e3424431e3d4f8a3800d74e259 Mon Sep 17 00:00:00 2001
-From: Fenghua Yu <fenghua.yu@intel.com>
-Date: Thu, 10 Nov 2016 10:13:56 -0800
-Subject: [PATCH 05/47] x86/fpu/xstate: Define new functions for clearing
- fpregs and xstates
-
-Currently, fpu__clear() clears all fpregs and xstates.  Once XSAVES
-supervisor states are introduced, supervisor settings (e.g. CET xstates)
-must remain active for signals; It is necessary to have separate functions:
-
-- Create fpu__clear_user_states(): clear only user settings for signals;
-- Create fpu__clear_all(): clear both user and supervisor settings in
-   flush_thread().
-
-Also modify copy_init_fpstate_to_fpregs() to take a mask from above two
-functions.
-
-Remove obvious side-comment in fpu__clear(), while at it.
-
-Signed-off-by: Fenghua Yu <fenghua.yu@intel.com>
-Co-developed-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
-Reviewed-by: Tony Luck <tony.luck@intel.com>
-
-v3:
-- Put common code into a static function fpu__clear(), with a parameter
-  user_only.
-
-v2:
-- Fixed an issue where fpu__clear_user_states() drops supervisor xstates.
-- Revise commit log.
----
- arch/x86/include/asm/fpu/internal.h |  3 +-
- arch/x86/kernel/fpu/core.c          | 49 +++++++++++++++++++----------
- arch/x86/kernel/fpu/signal.c        |  4 +--
- arch/x86/kernel/process.c           |  2 +-
- arch/x86/kernel/signal.c            |  2 +-
- 5 files changed, 39 insertions(+), 21 deletions(-)
-
-diff --git a/arch/x86/include/asm/fpu/internal.h b/arch/x86/include/asm/fpu/internal.h
-index ccb1bb32ad7d..a42fcb4b690d 100644
---- a/arch/x86/include/asm/fpu/internal.h
-+++ b/arch/x86/include/asm/fpu/internal.h
-@@ -31,7 +31,8 @@ extern void fpu__save(struct fpu *fpu);
- extern int  fpu__restore_sig(void __user *buf, int ia32_frame);
- extern void fpu__drop(struct fpu *fpu);
- extern int  fpu__copy(struct task_struct *dst, struct task_struct *src);
--extern void fpu__clear(struct fpu *fpu);
-+extern void fpu__clear_user_states(struct fpu *fpu);
-+extern void fpu__clear_all(struct fpu *fpu);
- extern int  fpu__exception_code(struct fpu *fpu, int trap_nr);
- extern int  dump_fpu(struct pt_regs *ptregs, struct user_i387_struct *fpstate);
- 
-diff --git a/arch/x86/kernel/fpu/core.c b/arch/x86/kernel/fpu/core.c
-index 12c70840980e..7fddd5d60443 100644
---- a/arch/x86/kernel/fpu/core.c
-+++ b/arch/x86/kernel/fpu/core.c
-@@ -294,12 +294,10 @@ void fpu__drop(struct fpu *fpu)
-  * Clear FPU registers by setting them up from
-  * the init fpstate:
-  */
--static inline void copy_init_fpstate_to_fpregs(void)
-+static inline void copy_init_fpstate_to_fpregs(u64 features_mask)
- {
--	fpregs_lock();
--
- 	if (use_xsave())
--		copy_kernel_to_xregs(&init_fpstate.xsave, -1);
-+		copy_kernel_to_xregs(&init_fpstate.xsave, features_mask);
- 	else if (static_cpu_has(X86_FEATURE_FXSR))
- 		copy_kernel_to_fxregs(&init_fpstate.fxsave);
- 	else
-@@ -307,9 +305,6 @@ static inline void copy_init_fpstate_to_fpregs(void)
- 
- 	if (boot_cpu_has(X86_FEATURE_OSPKE))
- 		copy_init_pkru_to_fpregs();
--
--	fpregs_mark_activate();
--	fpregs_unlock();
- }
- 
- /*
-@@ -318,18 +313,40 @@ static inline void copy_init_fpstate_to_fpregs(void)
-  * Called by sys_execve(), by the signal handler code and by various
-  * error paths.
-  */
--void fpu__clear(struct fpu *fpu)
-+static void fpu__clear(struct fpu *fpu, int user_only)
- {
--	WARN_ON_FPU(fpu != &current->thread.fpu); /* Almost certainly an anomaly */
-+	WARN_ON_FPU(fpu != &current->thread.fpu);
- 
--	fpu__drop(fpu);
-+	if (!static_cpu_has(X86_FEATURE_FPU)) {
-+		fpu__drop(fpu);
-+		fpu__initialize(fpu);
-+		return;
-+	}
- 
--	/*
--	 * Make sure fpstate is cleared and initialized.
--	 */
--	fpu__initialize(fpu);
--	if (static_cpu_has(X86_FEATURE_FPU))
--		copy_init_fpstate_to_fpregs();
-+	fpregs_lock();
-+
-+	if (user_only) {
-+		if (!fpregs_state_valid(fpu, smp_processor_id()) &&
-+		    xfeatures_mask_supervisor())
-+			copy_kernel_to_xregs(&fpu->state.xsave,
-+					     xfeatures_mask_supervisor());
-+		copy_init_fpstate_to_fpregs(xfeatures_mask_user());
-+	} else {
-+		copy_init_fpstate_to_fpregs(xfeatures_mask_all);
-+	}
-+
-+	fpregs_mark_activate();
-+	fpregs_unlock();
-+}
-+
-+void fpu__clear_user_states(struct fpu *fpu)
-+{
-+	fpu__clear(fpu, 1);
-+}
-+
-+void fpu__clear_all(struct fpu *fpu)
-+{
-+	fpu__clear(fpu, 0);
- }
- 
- /*
-diff --git a/arch/x86/kernel/fpu/signal.c b/arch/x86/kernel/fpu/signal.c
-index 3df0cfae535f..cd6eafba12da 100644
---- a/arch/x86/kernel/fpu/signal.c
-+++ b/arch/x86/kernel/fpu/signal.c
-@@ -289,7 +289,7 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
- 			 IS_ENABLED(CONFIG_IA32_EMULATION));
- 
- 	if (!buf) {
--		fpu__clear(fpu);
-+		fpu__clear_user_states(fpu);
- 		return 0;
- 	}
- 
-@@ -416,7 +416,7 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
- 
- err_out:
- 	if (ret)
--		fpu__clear(fpu);
-+		fpu__clear_user_states(fpu);
- 	return ret;
- }
- 
-diff --git a/arch/x86/kernel/process.c b/arch/x86/kernel/process.c
-index 35638f1c5791..ce6cd220f722 100644
---- a/arch/x86/kernel/process.c
-+++ b/arch/x86/kernel/process.c
-@@ -191,7 +191,7 @@ void flush_thread(void)
- 	flush_ptrace_hw_breakpoint(tsk);
- 	memset(tsk->thread.tls_array, 0, sizeof(tsk->thread.tls_array));
- 
--	fpu__clear(&tsk->thread.fpu);
-+	fpu__clear_all(&tsk->thread.fpu);
- }
- 
- void disable_TSC(void)
-diff --git a/arch/x86/kernel/signal.c b/arch/x86/kernel/signal.c
-index 83b74fb38c8f..0052bbe5dfd4 100644
---- a/arch/x86/kernel/signal.c
-+++ b/arch/x86/kernel/signal.c
-@@ -732,7 +732,7 @@ handle_signal(struct ksignal *ksig, struct pt_regs *regs)
- 		/*
- 		 * Ensure the signal handler starts with the new fpu state.
- 		 */
--		fpu__clear(fpu);
-+		fpu__clear_user_states(fpu);
- 	}
- 	signal_setup_done(failed, ksig, stepping);
- }
--- 
-2.26.2
-
diff --git a/0006-x86-fpu-xstate-Update-sanitize_restored_xstate-for-s.patch b/0006-x86-fpu-xstate-Update-sanitize_restored_xstate-for-s.patch
deleted file mode 100644
index bae40cca0..000000000
--- a/0006-x86-fpu-xstate-Update-sanitize_restored_xstate-for-s.patch
+++ /dev/null
@@ -1,138 +0,0 @@
-From bda901519751a4765e8546939ff198b8535dee12 Mon Sep 17 00:00:00 2001
-From: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Date: Tue, 12 Nov 2019 09:09:10 -0800
-Subject: [PATCH 06/47] x86/fpu/xstate: Update sanitize_restored_xstate() for
- supervisor xstates
-
-The function sanitize_restored_xstate() sanitizes user xstates of an XSAVE
-buffer by clearing bits not in the input 'xfeatures' from the buffer's
-header->xfeatures, effectively resetting those features back to the init
-state.
-
-When supervisor xstates are introduced, it is necessary to make sure only
-user xstates are sanitized.  Ensure supervisor bits in header->xfeatures
-stay set and supervisor states are not modified.
-
-To make names clear, also:
-
-- Rename the function to sanitize_restored_user_xstate().
-- Rename input parameter 'xfeatures' to 'user_xfeatures'.
-- In __fpu__restore_sig(), rename 'xfeatures' to 'user_xfeatures'.
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
-
-v3:
-- Change xfeatures_user to user_xfeatures.
----
- arch/x86/kernel/fpu/signal.c | 37 +++++++++++++++++++++++-------------
- 1 file changed, 24 insertions(+), 13 deletions(-)
-
-diff --git a/arch/x86/kernel/fpu/signal.c b/arch/x86/kernel/fpu/signal.c
-index cd6eafba12da..40583487883e 100644
---- a/arch/x86/kernel/fpu/signal.c
-+++ b/arch/x86/kernel/fpu/signal.c
-@@ -211,9 +211,9 @@ int copy_fpstate_to_sigframe(void __user *buf, void __user *buf_fx, int size)
- }
- 
- static inline void
--sanitize_restored_xstate(union fpregs_state *state,
--			 struct user_i387_ia32_struct *ia32_env,
--			 u64 xfeatures, int fx_only)
-+sanitize_restored_user_xstate(union fpregs_state *state,
-+			      struct user_i387_ia32_struct *ia32_env,
-+			      u64 user_xfeatures, int fx_only)
- {
- 	struct xregs_state *xsave = &state->xsave;
- 	struct xstate_header *header = &xsave->header;
-@@ -226,13 +226,22 @@ sanitize_restored_xstate(union fpregs_state *state,
- 		 */
- 
- 		/*
--		 * Init the state that is not present in the memory
--		 * layout and not enabled by the OS.
-+		 * 'user_xfeatures' might have bits clear which are
-+		 * set in header->xfeatures. This represents features that
-+		 * were in init state prior to a signal delivery, and need
-+		 * to be reset back to the init state.  Clear any user
-+		 * feature bits which are set in the kernel buffer to get
-+		 * them back to the init state.
-+		 *
-+		 * Supervisor state is unchanged by input from userspace.
-+		 * Ensure supervisor state bits stay set and supervisor
-+		 * state is not modified.
- 		 */
- 		if (fx_only)
- 			header->xfeatures = XFEATURE_MASK_FPSSE;
- 		else
--			header->xfeatures &= xfeatures;
-+			header->xfeatures &= user_xfeatures |
-+					     xfeatures_mask_supervisor();
- 	}
- 
- 	if (use_fxsr()) {
-@@ -281,7 +290,7 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
- 	struct task_struct *tsk = current;
- 	struct fpu *fpu = &tsk->thread.fpu;
- 	struct user_i387_ia32_struct env;
--	u64 xfeatures = 0;
-+	u64 user_xfeatures = 0;
- 	int fx_only = 0;
- 	int ret = 0;
- 
-@@ -314,7 +323,7 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
- 			trace_x86_fpu_xstate_check_failed(fpu);
- 		} else {
- 			state_size = fx_sw_user.xstate_size;
--			xfeatures = fx_sw_user.xfeatures;
-+			user_xfeatures = fx_sw_user.xfeatures;
- 		}
- 	}
- 
-@@ -349,7 +358,7 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
- 		 */
- 		fpregs_lock();
- 		pagefault_disable();
--		ret = copy_user_to_fpregs_zeroing(buf_fx, xfeatures, fx_only);
-+		ret = copy_user_to_fpregs_zeroing(buf_fx, user_xfeatures, fx_only);
- 		pagefault_enable();
- 		if (!ret) {
- 			fpregs_mark_activate();
-@@ -362,7 +371,7 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
- 
- 
- 	if (use_xsave() && !fx_only) {
--		u64 init_bv = xfeatures_mask_user() & ~xfeatures;
-+		u64 init_bv = xfeatures_mask_user() & ~user_xfeatures;
- 
- 		if (using_compacted_format()) {
- 			ret = copy_user_to_xstate(&fpu->state.xsave, buf_fx);
-@@ -375,12 +384,13 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
- 		if (ret)
- 			goto err_out;
- 
--		sanitize_restored_xstate(&fpu->state, envp, xfeatures, fx_only);
-+		sanitize_restored_user_xstate(&fpu->state, envp, user_xfeatures,
-+					      fx_only);
- 
- 		fpregs_lock();
- 		if (unlikely(init_bv))
- 			copy_kernel_to_xregs(&init_fpstate.xsave, init_bv);
--		ret = copy_kernel_to_xregs_err(&fpu->state.xsave, xfeatures);
-+		ret = copy_kernel_to_xregs_err(&fpu->state.xsave, user_xfeatures);
- 
- 	} else if (use_fxsr()) {
- 		ret = __copy_from_user(&fpu->state.fxsave, buf_fx, state_size);
-@@ -389,7 +399,8 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
- 			goto err_out;
- 		}
- 
--		sanitize_restored_xstate(&fpu->state, envp, xfeatures, fx_only);
-+		sanitize_restored_user_xstate(&fpu->state, envp,
-+					      user_xfeatures, fx_only);
- 
- 		fpregs_lock();
- 		if (use_xsave()) {
--- 
-2.26.2
-
diff --git a/0016-x86-mm-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_HW.patch b/0006-x86-mm-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_HW.patch
similarity index 88%
rename from 0016-x86-mm-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_HW.patch
rename to 0006-x86-mm-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_HW.patch
index e121baacb..f4d164b22 100644
--- a/0016-x86-mm-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_HW.patch
+++ b/0006-x86-mm-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_HW.patch
@@ -1,7 +1,7 @@
-From ce2166e6e1ea24b455444c68679ed5acde6675fd Mon Sep 17 00:00:00 2001
+From 63eb6dc0b71c2e75d519cb6591ce3a7291500ed2 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Thu, 12 Apr 2018 09:32:59 -0700
-Subject: [PATCH 16/47] x86/mm: Change _PAGE_DIRTY to _PAGE_DIRTY_HW
+Subject: [PATCH 06/40] x86/mm: Change _PAGE_DIRTY to _PAGE_DIRTY_HW
 
 Before introducing _PAGE_COW for non-hardware memory management purposes in
 the next patch, rename _PAGE_DIRTY to _PAGE_DIRTY_HW and _PAGE_BIT_DIRTY to
@@ -9,8 +9,6 @@ _PAGE_BIT_DIRTY_HW to make meanings more clear.  There are no functional
 changes from this patch.
 
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Kees Cook <keescook@chromium.org>
-Reviewed-by: Dave Hansen <dave.hansen@intel.com>
 
 v9:
 - At some places _PAGE_DIRTY were not changed to _PAGE_DIRTY_HW, because
@@ -25,7 +23,7 @@ v9:
  4 files changed, 16 insertions(+), 17 deletions(-)
 
 diff --git a/arch/x86/include/asm/pgtable.h b/arch/x86/include/asm/pgtable.h
-index 4d02e64af1b3..90f9a73881ad 100644
+index 76aa21e8128d..69a9498506ec 100644
 --- a/arch/x86/include/asm/pgtable.h
 +++ b/arch/x86/include/asm/pgtable.h
 @@ -124,7 +124,7 @@ extern pmdval_t early_pmd_flags;
@@ -55,7 +53,7 @@ index 4d02e64af1b3..90f9a73881ad 100644
  }
  
  static inline int pud_young(pud_t pud)
-@@ -333,7 +333,7 @@ static inline pte_t pte_clear_uffd_wp(pte_t pte)
+@@ -334,7 +334,7 @@ static inline pte_t pte_clear_uffd_wp(pte_t pte)
  
  static inline pte_t pte_mkclean(pte_t pte)
  {
@@ -64,7 +62,7 @@ index 4d02e64af1b3..90f9a73881ad 100644
  }
  
  static inline pte_t pte_mkold(pte_t pte)
-@@ -353,7 +353,7 @@ static inline pte_t pte_mkexec(pte_t pte)
+@@ -354,7 +354,7 @@ static inline pte_t pte_mkexec(pte_t pte)
  
  static inline pte_t pte_mkdirty(pte_t pte)
  {
@@ -73,7 +71,7 @@ index 4d02e64af1b3..90f9a73881ad 100644
  }
  
  static inline pte_t pte_mkyoung(pte_t pte)
-@@ -434,7 +434,7 @@ static inline pmd_t pmd_mkold(pmd_t pmd)
+@@ -435,7 +435,7 @@ static inline pmd_t pmd_mkold(pmd_t pmd)
  
  static inline pmd_t pmd_mkclean(pmd_t pmd)
  {
@@ -82,7 +80,7 @@ index 4d02e64af1b3..90f9a73881ad 100644
  }
  
  static inline pmd_t pmd_wrprotect(pmd_t pmd)
-@@ -444,7 +444,7 @@ static inline pmd_t pmd_wrprotect(pmd_t pmd)
+@@ -445,7 +445,7 @@ static inline pmd_t pmd_wrprotect(pmd_t pmd)
  
  static inline pmd_t pmd_mkdirty(pmd_t pmd)
  {
@@ -91,7 +89,7 @@ index 4d02e64af1b3..90f9a73881ad 100644
  }
  
  static inline pmd_t pmd_mkdevmap(pmd_t pmd)
-@@ -488,7 +488,7 @@ static inline pud_t pud_mkold(pud_t pud)
+@@ -489,7 +489,7 @@ static inline pud_t pud_mkold(pud_t pud)
  
  static inline pud_t pud_mkclean(pud_t pud)
  {
@@ -100,7 +98,7 @@ index 4d02e64af1b3..90f9a73881ad 100644
  }
  
  static inline pud_t pud_wrprotect(pud_t pud)
-@@ -498,7 +498,7 @@ static inline pud_t pud_wrprotect(pud_t pud)
+@@ -499,7 +499,7 @@ static inline pud_t pud_wrprotect(pud_t pud)
  
  static inline pud_t pud_mkdirty(pud_t pud)
  {
@@ -110,7 +108,7 @@ index 4d02e64af1b3..90f9a73881ad 100644
  
  static inline pud_t pud_mkdevmap(pud_t pud)
 diff --git a/arch/x86/include/asm/pgtable_types.h b/arch/x86/include/asm/pgtable_types.h
-index b6606fe6cfdf..b82e0f167879 100644
+index 816b31c68550..192e1326b3db 100644
 --- a/arch/x86/include/asm/pgtable_types.h
 +++ b/arch/x86/include/asm/pgtable_types.h
 @@ -15,7 +15,7 @@
@@ -180,10 +178,10 @@ index a4d9a261425b..e3bb4ff95523 100644
  /*
   * control_page + KEXEC_CONTROL_CODE_MAX_SIZE
 diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.c
-index 89c766fad889..5d143b2eb3b7 100644
+index 13745f2a5ecd..7f0c4e78881b 100644
 --- a/arch/x86/kvm/vmx/vmx.c
 +++ b/arch/x86/kvm/vmx/vmx.c
-@@ -3500,7 +3500,7 @@ static int init_rmode_identity_map(struct kvm *kvm)
+@@ -3608,7 +3608,7 @@ static int init_rmode_identity_map(struct kvm *kvm)
  	/* Set up identity-mapping pagetable for EPT in real mode */
  	for (i = 0; i < PT32_ENT_PER_PAGE; i++) {
  		tmp = (i << 22) + (_PAGE_PRESENT | _PAGE_RW | _PAGE_USER |
diff --git a/0007-x86-fpu-xstate-Update-copy_kernel_to_xregs_err-for-X.patch b/0007-x86-fpu-xstate-Update-copy_kernel_to_xregs_err-for-X.patch
deleted file mode 100644
index fe1140c15..000000000
--- a/0007-x86-fpu-xstate-Update-copy_kernel_to_xregs_err-for-X.patch
+++ /dev/null
@@ -1,46 +0,0 @@
-From a6d2ac13fc0efe552faf2f761abff8b1e21d9b31 Mon Sep 17 00:00:00 2001
-From: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Date: Tue, 29 Oct 2019 12:42:06 -0700
-Subject: [PATCH 07/47] x86/fpu/xstate: Update copy_kernel_to_xregs_err() for
- XSAVES supervisor states
-
-The function copy_kernel_to_xregs_err() uses XRSTOR, which can work with
-standard or compacted format without supervisor xstates.  However, when
-supervisor xstates are present, XRSTORS must be used.  Fix it by using
-XRSTORS when XSAVES is enabled.
-
-I also considered if there were additional cases where XRSTOR might be
-mistakenly called instead of XRSTORS.  There are only three XRSTOR sites
-in kernel:
-
-1. copy_kernel_to_xregs_booting(), already switches between XRSTOR and
-   XRSTORS based on X86_FEATURE_XSAVES.
-2. copy_user_to_xregs(), which *needs* XRSTOR because it is copying from
-   userspace and must never copy supervisor state with XRSTORS.
-3. copy_kernel_to_xregs_err() mistakenly used XRSTOR only.  Fixed it.
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
----
- arch/x86/include/asm/fpu/internal.h | 5 ++++-
- 1 file changed, 4 insertions(+), 1 deletion(-)
-
-diff --git a/arch/x86/include/asm/fpu/internal.h b/arch/x86/include/asm/fpu/internal.h
-index a42fcb4b690d..42159f45bf9c 100644
---- a/arch/x86/include/asm/fpu/internal.h
-+++ b/arch/x86/include/asm/fpu/internal.h
-@@ -400,7 +400,10 @@ static inline int copy_kernel_to_xregs_err(struct xregs_state *xstate, u64 mask)
- 	u32 hmask = mask >> 32;
- 	int err;
- 
--	XSTATE_OP(XRSTOR, xstate, lmask, hmask, err);
-+	if (static_cpu_has(X86_FEATURE_XSAVES))
-+		XSTATE_OP(XRSTORS, xstate, lmask, hmask, err);
-+	else
-+		XSTATE_OP(XRSTOR, xstate, lmask, hmask, err);
- 
- 	return err;
- }
--- 
-2.26.2
-
diff --git a/0017-x86-mm-Remove-_PAGE_DIRTY_HW-from-kernel-RO-pages.patch b/0007-x86-mm-Remove-_PAGE_DIRTY_HW-from-kernel-RO-pages.patch
similarity index 72%
rename from 0017-x86-mm-Remove-_PAGE_DIRTY_HW-from-kernel-RO-pages.patch
rename to 0007-x86-mm-Remove-_PAGE_DIRTY_HW-from-kernel-RO-pages.patch
index 8ba1cd136..3c091b774 100644
--- a/0017-x86-mm-Remove-_PAGE_DIRTY_HW-from-kernel-RO-pages.patch
+++ b/0007-x86-mm-Remove-_PAGE_DIRTY_HW-from-kernel-RO-pages.patch
@@ -1,27 +1,19 @@
-From 59a325f01bf3297438bb7e9e9be1450f1cacb3ec Mon Sep 17 00:00:00 2001
+From 6b72d3e587d9b38083413a7187d455fa565819a8 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 14 Apr 2020 14:48:14 -0700
-Subject: [PATCH 17/47] x86/mm: Remove _PAGE_DIRTY_HW from kernel RO pages
+Subject: [PATCH 07/40] x86/mm: Remove _PAGE_DIRTY_HW from kernel RO pages
 
 Kernel read-only PTEs are setup as _PAGE_DIRTY_HW.  Since these become
 shadow stack PTEs, remove the dirty bit.
 
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Cc: "H. Peter Anvin" <hpa@zytor.com>
-Cc: Kees Cook <keescook@chromium.org>
-Cc: Thomas Gleixner <tglx@linutronix.de>
-Cc: Dave Hansen <dave.hansen@linux.intel.com>
-Cc: Andy Lutomirski <luto@kernel.org>
-Cc: Ingo Molnar <mingo@redhat.com>
-Cc: Borislav Petkov <bp@alien8.de>
-Cc: Peter Zijlstra <peterz@infradead.org>
 ---
  arch/x86/include/asm/pgtable_types.h | 6 +++---
  arch/x86/mm/pat/set_memory.c         | 2 +-
  2 files changed, 4 insertions(+), 4 deletions(-)
 
 diff --git a/arch/x86/include/asm/pgtable_types.h b/arch/x86/include/asm/pgtable_types.h
-index b82e0f167879..522b80b952f4 100644
+index 192e1326b3db..5f31f1c407b9 100644
 --- a/arch/x86/include/asm/pgtable_types.h
 +++ b/arch/x86/include/asm/pgtable_types.h
 @@ -193,10 +193,10 @@ enum page_cache_mode {
@@ -29,9 +21,9 @@ index b82e0f167879..522b80b952f4 100644
  #define _PAGE_TABLE_NOENC	 (__PP|__RW|_USR|___A|   0|___D|   0|   0)
  #define _PAGE_TABLE		 (__PP|__RW|_USR|___A|   0|___D|   0|   0| _ENC)
 -#define __PAGE_KERNEL_RO	 (__PP|   0|   0|___A|__NX|___D|   0|___G)
--#define __PAGE_KERNEL_RX	 (__PP|   0|   0|___A|   0|___D|   0|___G)
+-#define __PAGE_KERNEL_ROX	 (__PP|   0|   0|___A|   0|___D|   0|___G)
 +#define __PAGE_KERNEL_RO	 (__PP|   0|   0|___A|__NX|   0|   0|___G)
-+#define __PAGE_KERNEL_RX	 (__PP|   0|   0|___A|   0|   0|___G)
++#define __PAGE_KERNEL_ROX	 (__PP|   0|   0|___A|   0|   0|   0|___G)
  #define __PAGE_KERNEL_NOCACHE	 (__PP|__RW|   0|___A|__NX|___D|   0|___G| __NC)
 -#define __PAGE_KERNEL_VVAR	 (__PP|   0|_USR|___A|__NX|___D|   0|___G)
 +#define __PAGE_KERNEL_VVAR	 (__PP|   0|_USR|___A|__NX|   0|   0|___G)
@@ -39,10 +31,10 @@ index b82e0f167879..522b80b952f4 100644
  #define __PAGE_KERNEL_LARGE_EXEC (__PP|__RW|   0|___A|   0|___D|_PSE|___G)
  #define __PAGE_KERNEL_WP	 (__PP|__RW|   0|___A|__NX|___D|   0|___G| __WP)
 diff --git a/arch/x86/mm/pat/set_memory.c b/arch/x86/mm/pat/set_memory.c
-index b8c55a2e402d..deb8b044f15d 100644
+index 77e04304a2a7..43ac7866f20d 100644
 --- a/arch/x86/mm/pat/set_memory.c
 +++ b/arch/x86/mm/pat/set_memory.c
-@@ -1927,7 +1927,7 @@ int set_memory_nx(unsigned long addr, int numpages)
+@@ -1932,7 +1932,7 @@ int set_memory_nx(unsigned long addr, int numpages)
  
  int set_memory_ro(unsigned long addr, int numpages)
  {
diff --git a/0008-x86-fpu-Introduce-copy_supervisor_to_kernel.patch b/0008-x86-fpu-Introduce-copy_supervisor_to_kernel.patch
deleted file mode 100644
index 99adf031e..000000000
--- a/0008-x86-fpu-Introduce-copy_supervisor_to_kernel.patch
+++ /dev/null
@@ -1,154 +0,0 @@
-From cb17dcf151aab3c650d7cb81715d5c5e99041fb7 Mon Sep 17 00:00:00 2001
-From: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Date: Mon, 16 Mar 2020 10:29:12 -0700
-Subject: [PATCH 08/47] x86/fpu: Introduce copy_supervisor_to_kernel()
-
-The XSAVES instruction takes a mask and saves only the features specified
-in that mask.  The kernel normally specifies that all features be saved.
-
-XSAVES also unconditionally uses the "compacted format" which means that
-all specified features are saved next to each other in memory.  If a
-feature is removed from the mask, all the features after it will "move
-up" into earlier locations in the buffer.
-
-Introduce copy_supervisor_to_kernel(), which saves only supervisor states
-and then moves those states into the standard location where they are
-normally found.
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
----
- arch/x86/include/asm/fpu/xstate.h |  1 +
- arch/x86/kernel/fpu/xstate.c      | 84 +++++++++++++++++++++++++++++++
- 2 files changed, 85 insertions(+)
-
-diff --git a/arch/x86/include/asm/fpu/xstate.h b/arch/x86/include/asm/fpu/xstate.h
-index 92104b298d77..422d8369012a 100644
---- a/arch/x86/include/asm/fpu/xstate.h
-+++ b/arch/x86/include/asm/fpu/xstate.h
-@@ -75,6 +75,7 @@ int copy_xstate_to_kernel(void *kbuf, struct xregs_state *xsave, unsigned int of
- int copy_xstate_to_user(void __user *ubuf, struct xregs_state *xsave, unsigned int offset, unsigned int size);
- int copy_kernel_to_xstate(struct xregs_state *xsave, const void *kbuf);
- int copy_user_to_xstate(struct xregs_state *xsave, const void __user *ubuf);
-+void copy_supervisor_to_kernel(struct xregs_state *xsave);
- 
- /* Validate an xstate header supplied by userspace (ptrace or sigreturn) */
- int validate_user_xstate_header(const struct xstate_header *hdr);
-diff --git a/arch/x86/kernel/fpu/xstate.c b/arch/x86/kernel/fpu/xstate.c
-index 95f09c2e8cd6..bda2e5eaca0e 100644
---- a/arch/x86/kernel/fpu/xstate.c
-+++ b/arch/x86/kernel/fpu/xstate.c
-@@ -62,6 +62,7 @@ u64 xfeatures_mask_all __read_mostly;
- static unsigned int xstate_offsets[XFEATURE_MAX] = { [ 0 ... XFEATURE_MAX - 1] = -1};
- static unsigned int xstate_sizes[XFEATURE_MAX]   = { [ 0 ... XFEATURE_MAX - 1] = -1};
- static unsigned int xstate_comp_offsets[XFEATURE_MAX] = { [ 0 ... XFEATURE_MAX - 1] = -1};
-+static unsigned int xstate_supervisor_only_offsets[XFEATURE_MAX] = { [ 0 ... XFEATURE_MAX - 1] = -1};
- 
- /*
-  * The XSAVE area of kernel can be in standard or compacted format;
-@@ -392,6 +393,33 @@ static void __init setup_xstate_comp_offsets(void)
- 	}
- }
- 
-+/*
-+ * Setup offsets of a supervisor-state-only XSAVES buffer:
-+ *
-+ * The offsets stored in xstate_comp_offsets[] only work for one specific
-+ * value of the Requested Feature BitMap (RFBM).  In cases where a different
-+ * RFBM value is used, a different set of offsets is required.  This set of
-+ * offsets is for when RFBM=xfeatures_mask_supervisor().
-+ */
-+static void __init setup_supervisor_only_offsets(void)
-+{
-+	unsigned int next_offset;
-+	int i;
-+
-+	next_offset = FXSAVE_SIZE + XSAVE_HDR_SIZE;
-+
-+	for (i = FIRST_EXTENDED_XFEATURE; i < XFEATURE_MAX; i++) {
-+		if (!xfeature_enabled(i) || !xfeature_is_supervisor(i))
-+			continue;
-+
-+		if (xfeature_is_aligned(i))
-+			next_offset = ALIGN(next_offset, 64);
-+
-+		xstate_supervisor_only_offsets[i] = next_offset;
-+		next_offset += xstate_sizes[i];
-+	}
-+}
-+
- /*
-  * Print out xstate component offsets and sizes
-  */
-@@ -790,6 +818,7 @@ void __init fpu__init_system_xstate(void)
- 	fpu__init_prepare_fx_sw_frame();
- 	setup_init_fpu_buf();
- 	setup_xstate_comp_offsets();
-+	setup_supervisor_only_offsets();
- 	print_xstate_offset_size();
- 
- 	pr_info("x86/fpu: Enabled xstate features 0x%llx, context size is %d bytes, using '%s' format.\n",
-@@ -1272,6 +1301,61 @@ int copy_user_to_xstate(struct xregs_state *xsave, const void __user *ubuf)
- 	return 0;
- }
- 
-+/*
-+ * Save only supervisor states to the kernel buffer.  This blows away all
-+ * old states, and is intended to be used only in __fpu__restore_sig(), where
-+ * user states are restored from the user buffer.
-+ */
-+void copy_supervisor_to_kernel(struct xregs_state *xstate)
-+{
-+	struct xstate_header *header;
-+	u64 max_bit, min_bit;
-+	u32 lmask, hmask;
-+	int err, i;
-+
-+	if (WARN_ON(!boot_cpu_has(X86_FEATURE_XSAVES)))
-+		return;
-+
-+	if (!xfeatures_mask_supervisor())
-+		return;
-+
-+	max_bit = __fls(xfeatures_mask_supervisor());
-+	min_bit = __ffs(xfeatures_mask_supervisor());
-+
-+	lmask = xfeatures_mask_supervisor();
-+	hmask = xfeatures_mask_supervisor() >> 32;
-+	XSTATE_OP(XSAVES, xstate, lmask, hmask, err);
-+
-+	/* We should never fault when copying to a kernel buffer: */
-+	if (WARN_ON_FPU(err))
-+		return;
-+
-+	/*
-+	 * At this point, the buffer has only supervisor states and must be
-+	 * converted back to normal kernel format.
-+	 */
-+	header = &xstate->header;
-+	header->xcomp_bv |= xfeatures_mask_all;
-+
-+	/*
-+	 * This only moves states up in the buffer.  Start with
-+	 * the last state and move backwards so that states are
-+	 * not overwritten until after they are moved.  Note:
-+	 * memmove() allows overlapping src/dst buffers.
-+	 */
-+	for (i = max_bit; i >= min_bit; i--) {
-+		u8 *xbuf = (u8 *)xstate;
-+
-+		if (!((header->xfeatures >> i) & 1))
-+			continue;
-+
-+		/* Move xfeature 'i' into its normal location */
-+		memmove(xbuf + xstate_comp_offsets[i],
-+			xbuf + xstate_supervisor_only_offsets[i],
-+			xstate_sizes[i]);
-+	}
-+}
-+
- #ifdef CONFIG_PROC_PID_ARCH_STATUS
- /*
-  * Report the amount of time elapsed in millisecond since last AVX512
--- 
-2.26.2
-
diff --git a/0018-x86-mm-Introduce-_PAGE_COW.patch b/0008-x86-mm-Introduce-_PAGE_COW.patch
similarity index 93%
rename from 0018-x86-mm-Introduce-_PAGE_COW.patch
rename to 0008-x86-mm-Introduce-_PAGE_COW.patch
index 3e4679ceb..4b346978d 100644
--- a/0018-x86-mm-Introduce-_PAGE_COW.patch
+++ b/0008-x86-mm-Introduce-_PAGE_COW.patch
@@ -1,7 +1,7 @@
-From 725ee629712261d648961d822a87aca0528a1930 Mon Sep 17 00:00:00 2001
+From 01e949539342f47a1c36f8c6fee7686d8961a484 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Wed, 24 Jan 2018 10:27:13 -0800
-Subject: [PATCH 18/47] x86/mm: Introduce _PAGE_COW
+Subject: [PATCH 08/40] x86/mm: Introduce _PAGE_COW
 
 There is essentially no room left in the x86 hardware PTEs on some OSes
 (not Linux).  That left the hardware architects looking for a way to
@@ -42,7 +42,6 @@ There are no more free bits in the 32-bit PTE (except for PAE) and shadow
 stack is not implemented for the 32-bit kernel.
 
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Kees Cook <keescook@chromium.org>
 
 v10:
 - Change _PAGE_BIT_DIRTY_SW to _PAGE_BIT_COW, as it is used for copy-on-
@@ -66,7 +65,7 @@ v9:
  2 files changed, 150 insertions(+), 11 deletions(-)
 
 diff --git a/arch/x86/include/asm/pgtable.h b/arch/x86/include/asm/pgtable.h
-index 90f9a73881ad..5f89035d1e60 100644
+index 69a9498506ec..1b57b5543adb 100644
 --- a/arch/x86/include/asm/pgtable.h
 +++ b/arch/x86/include/asm/pgtable.h
 @@ -122,9 +122,9 @@ extern pmdval_t early_pmd_flags;
@@ -118,7 +117,7 @@ index 90f9a73881ad..5f89035d1e60 100644
  	return pte_flags(pte) & _PAGE_RW;
  }
  
-@@ -333,7 +339,7 @@ static inline pte_t pte_clear_uffd_wp(pte_t pte)
+@@ -334,7 +340,7 @@ static inline pte_t pte_clear_uffd_wp(pte_t pte)
  
  static inline pte_t pte_mkclean(pte_t pte)
  {
@@ -127,7 +126,7 @@ index 90f9a73881ad..5f89035d1e60 100644
  }
  
  static inline pte_t pte_mkold(pte_t pte)
-@@ -343,6 +349,17 @@ static inline pte_t pte_mkold(pte_t pte)
+@@ -344,6 +350,17 @@ static inline pte_t pte_mkold(pte_t pte)
  
  static inline pte_t pte_wrprotect(pte_t pte)
  {
@@ -145,7 +144,7 @@ index 90f9a73881ad..5f89035d1e60 100644
  	return pte_clear_flags(pte, _PAGE_RW);
  }
  
-@@ -353,6 +370,18 @@ static inline pte_t pte_mkexec(pte_t pte)
+@@ -354,6 +371,18 @@ static inline pte_t pte_mkexec(pte_t pte)
  
  static inline pte_t pte_mkdirty(pte_t pte)
  {
@@ -164,7 +163,7 @@ index 90f9a73881ad..5f89035d1e60 100644
  	return pte_set_flags(pte, _PAGE_DIRTY_HW | _PAGE_SOFT_DIRTY);
  }
  
-@@ -363,6 +392,13 @@ static inline pte_t pte_mkyoung(pte_t pte)
+@@ -364,6 +393,13 @@ static inline pte_t pte_mkyoung(pte_t pte)
  
  static inline pte_t pte_mkwrite(pte_t pte)
  {
@@ -178,7 +177,7 @@ index 90f9a73881ad..5f89035d1e60 100644
  	return pte_set_flags(pte, _PAGE_RW);
  }
  
-@@ -434,16 +470,41 @@ static inline pmd_t pmd_mkold(pmd_t pmd)
+@@ -435,16 +471,41 @@ static inline pmd_t pmd_mkold(pmd_t pmd)
  
  static inline pmd_t pmd_mkclean(pmd_t pmd)
  {
@@ -221,7 +220,7 @@ index 90f9a73881ad..5f89035d1e60 100644
  	return pmd_set_flags(pmd, _PAGE_DIRTY_HW | _PAGE_SOFT_DIRTY);
  }
  
-@@ -464,6 +525,13 @@ static inline pmd_t pmd_mkyoung(pmd_t pmd)
+@@ -465,6 +526,13 @@ static inline pmd_t pmd_mkyoung(pmd_t pmd)
  
  static inline pmd_t pmd_mkwrite(pmd_t pmd)
  {
@@ -235,7 +234,7 @@ index 90f9a73881ad..5f89035d1e60 100644
  	return pmd_set_flags(pmd, _PAGE_RW);
  }
  
-@@ -488,17 +556,36 @@ static inline pud_t pud_mkold(pud_t pud)
+@@ -489,17 +557,36 @@ static inline pud_t pud_mkold(pud_t pud)
  
  static inline pud_t pud_mkclean(pud_t pud)
  {
@@ -274,7 +273,7 @@ index 90f9a73881ad..5f89035d1e60 100644
  }
  
  static inline pud_t pud_mkdevmap(pud_t pud)
-@@ -518,6 +605,13 @@ static inline pud_t pud_mkyoung(pud_t pud)
+@@ -519,6 +606,13 @@ static inline pud_t pud_mkyoung(pud_t pud)
  
  static inline pud_t pud_mkwrite(pud_t pud)
  {
@@ -288,7 +287,7 @@ index 90f9a73881ad..5f89035d1e60 100644
  	return pud_set_flags(pud, _PAGE_RW);
  }
  
-@@ -1218,6 +1312,12 @@ extern int pmdp_clear_flush_young(struct vm_area_struct *vma,
+@@ -1135,6 +1229,12 @@ extern int pmdp_clear_flush_young(struct vm_area_struct *vma,
  #define pmd_write pmd_write
  static inline int pmd_write(pmd_t pmd)
  {
@@ -302,7 +301,7 @@ index 90f9a73881ad..5f89035d1e60 100644
  }
  
 diff --git a/arch/x86/include/asm/pgtable_types.h b/arch/x86/include/asm/pgtable_types.h
-index 522b80b952f4..74229db078ce 100644
+index 5f31f1c407b9..b57483567b8b 100644
 --- a/arch/x86/include/asm/pgtable_types.h
 +++ b/arch/x86/include/asm/pgtable_types.h
 @@ -23,7 +23,8 @@
diff --git a/0019-drm-i915-gvt-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_BITS.patch b/0009-drm-i915-gvt-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_BITS.patch
similarity index 60%
rename from 0019-drm-i915-gvt-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_BITS.patch
rename to 0009-drm-i915-gvt-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_BITS.patch
index bf99c97bd..1f7a8ba28 100644
--- a/0019-drm-i915-gvt-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_BITS.patch
+++ b/0009-drm-i915-gvt-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_BITS.patch
@@ -1,26 +1,18 @@
-From 92be29e61e2aa19145f9b07aa665dce69d4b57e6 Mon Sep 17 00:00:00 2001
+From 207e9ea9cb806e3a704b22ebc9518a17582bd5f5 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 28 Aug 2018 13:01:49 -0700
-Subject: [PATCH 19/47] drm/i915/gvt: Change _PAGE_DIRTY to _PAGE_DIRTY_BITS
+Subject: [PATCH 09/40] drm/i915/gvt: Change _PAGE_DIRTY to _PAGE_DIRTY_BITS
 
 After the introduction of _PAGE_COW, a modified page's PTE can have either
 _PAGE_DIRTY_HW or _PAGE_COW.  Change _PAGE_DIRTY to _PAGE_DIRTY_BITS.
 
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Kees Cook <keescook@chromium.org>
-Cc: David Airlie <airlied@linux.ie>
-Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
-Cc: Jani Nikula <jani.nikula@linux.intel.com>
-Cc: Daniel Vetter <daniel@ffwll.ch>
-Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
-Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
-Cc: Zhi Wang <zhi.a.wang@intel.com>
 ---
  drivers/gpu/drm/i915/gvt/gtt.c | 2 +-
  1 file changed, 1 insertion(+), 1 deletion(-)
 
 diff --git a/drivers/gpu/drm/i915/gvt/gtt.c b/drivers/gpu/drm/i915/gvt/gtt.c
-index 2a4b23f8aa74..789dce23424b 100644
+index 210016192ce7..c01f4880c794 100644
 --- a/drivers/gpu/drm/i915/gvt/gtt.c
 +++ b/drivers/gpu/drm/i915/gvt/gtt.c
 @@ -1207,7 +1207,7 @@ static int split_2MB_gtt_entry(struct intel_vgpu *vgpu,
diff --git a/0009-x86-fpu-xstate-Preserve-supervisor-states-for-slow-p.patch b/0009-x86-fpu-xstate-Preserve-supervisor-states-for-slow-p.patch
deleted file mode 100644
index c3b2b0702..000000000
--- a/0009-x86-fpu-xstate-Preserve-supervisor-states-for-slow-p.patch
+++ /dev/null
@@ -1,130 +0,0 @@
-From 2b149ef4cd5acfe5112c9d10b2144c0b99fcfd5d Mon Sep 17 00:00:00 2001
-From: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Date: Tue, 29 Oct 2019 13:03:10 -0700
-Subject: [PATCH 09/47] x86/fpu/xstate: Preserve supervisor states for slow
- path of __fpu__restore_sig()
-
-The signal return code is responsible for taking an XSAVE buffer present
-in user memory and loading it into the hardware registers.  This
-operation only affects user XSAVE state and never affects supervisor state.
-
-The fast path through this code simply points XRSTOR directly at the
-user buffer.  However, since user memory is not guaranteed to be always
-mapped, this XRSTOR can fail.  If it fails, the signal return code falls
-back to a slow path which can tolerate page faults.
-
-That slow path copies the xfeatures one by one out of the user buffer
-into the task's fpu state area.  However, by being in a context where it
-can handle page faults, the code can also schedule.  The lazy-fpu-load code
-would think it has an up-to-date fpstate and would fail to save the
-supervisor state when scheduling the task out.  When scheduling back in, it
-would likely restore stale supervisor state.
-
-To fix that, preserve supervisor state before the slow path.  Modify
-copy_user_to_fpregs_zeroing() so that if it fails, fpregs are not zeroed,
-and there is no need for fpregs_deactivate() and supervisor states are
-preserved.
-
-Move set_thread_flag(TIF_NEED_FPU_LOAD) to the slow path.  Without doing
-this, the fast path also needs supervisor states to be saved first.
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
----
- arch/x86/kernel/fpu/signal.c | 53 +++++++++++++++++++-----------------
- 1 file changed, 28 insertions(+), 25 deletions(-)
-
-diff --git a/arch/x86/kernel/fpu/signal.c b/arch/x86/kernel/fpu/signal.c
-index 40583487883e..c0e07b548076 100644
---- a/arch/x86/kernel/fpu/signal.c
-+++ b/arch/x86/kernel/fpu/signal.c
-@@ -262,19 +262,23 @@ sanitize_restored_user_xstate(union fpregs_state *state,
- static int copy_user_to_fpregs_zeroing(void __user *buf, u64 xbv, int fx_only)
- {
- 	u64 init_bv;
-+	int r;
- 
- 	if (use_xsave()) {
- 		if (fx_only) {
- 			init_bv = xfeatures_mask_user() & ~XFEATURE_MASK_FPSSE;
- 
--			copy_kernel_to_xregs(&init_fpstate.xsave, init_bv);
--			return copy_user_to_fxregs(buf);
-+			r = copy_user_to_fxregs(buf);
-+			if (!r)
-+				copy_kernel_to_xregs(&init_fpstate.xsave, init_bv);
-+			return r;
- 		} else {
- 			init_bv = xfeatures_mask_user() & ~xbv;
- 
--			if (unlikely(init_bv))
-+			r = copy_user_to_xregs(buf, xbv);
-+			if (!r && unlikely(init_bv))
- 				copy_kernel_to_xregs(&init_fpstate.xsave, init_bv);
--			return copy_user_to_xregs(buf, xbv);
-+			return r;
- 		}
- 	} else if (use_fxsr()) {
- 		return copy_user_to_fxregs(buf);
-@@ -327,28 +331,10 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
- 		}
- 	}
- 
--	/*
--	 * The current state of the FPU registers does not matter. By setting
--	 * TIF_NEED_FPU_LOAD unconditionally it is ensured that the our xstate
--	 * is not modified on context switch and that the xstate is considered
--	 * to be loaded again on return to userland (overriding last_cpu avoids
--	 * the optimisation).
--	 */
--	set_thread_flag(TIF_NEED_FPU_LOAD);
--	__fpu_invalidate_fpregs_state(fpu);
--
- 	if ((unsigned long)buf_fx % 64)
- 		fx_only = 1;
--	/*
--	 * For 32-bit frames with fxstate, copy the fxstate so it can be
--	 * reconstructed later.
--	 */
--	if (ia32_fxstate) {
--		ret = __copy_from_user(&env, buf, sizeof(env));
--		if (ret)
--			goto err_out;
--		envp = &env;
--	} else {
-+
-+	if (!ia32_fxstate) {
- 		/*
- 		 * Attempt to restore the FPU registers directly from user
- 		 * memory. For that to succeed, the user access cannot cause
-@@ -365,10 +351,27 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
- 			fpregs_unlock();
- 			return 0;
- 		}
--		fpregs_deactivate(fpu);
- 		fpregs_unlock();
-+	} else {
-+		/*
-+		 * For 32-bit frames with fxstate, copy the fxstate so it can
-+		 * be reconstructed later.
-+		 */
-+		ret = __copy_from_user(&env, buf, sizeof(env));
-+		if (ret)
-+			goto err_out;
-+		envp = &env;
- 	}
- 
-+	/*
-+	 * The current state of the FPU registers does not matter. By setting
-+	 * TIF_NEED_FPU_LOAD unconditionally it is ensured that the our xstate
-+	 * is not modified on context switch and that the xstate is considered
-+	 * to be loaded again on return to userland (overriding last_cpu avoids
-+	 * the optimisation).
-+	 */
-+	set_thread_flag(TIF_NEED_FPU_LOAD);
-+	__fpu_invalidate_fpregs_state(fpu);
- 
- 	if (use_xsave() && !fx_only) {
- 		u64 init_bv = xfeatures_mask_user() & ~user_xfeatures;
--- 
-2.26.2
-
diff --git a/0010-x86-fpu-xstate-Restore-supervisor-states-for-signal-.patch b/0010-x86-fpu-xstate-Restore-supervisor-states-for-signal-.patch
deleted file mode 100644
index 4e437bc0f..000000000
--- a/0010-x86-fpu-xstate-Restore-supervisor-states-for-signal-.patch
+++ /dev/null
@@ -1,129 +0,0 @@
-From 299a4d2e1c53addbf2169a9cb88d28069d0aa58e Mon Sep 17 00:00:00 2001
-From: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Date: Fri, 27 Mar 2020 09:42:02 -0700
-Subject: [PATCH 10/47] x86/fpu/xstate: Restore supervisor states for signal
- return
-
-As described in the previous patch, the signal return fast path directly
-restores user states from the user buffer.  Once that succeeds, restore
-supervisor states (but only when they are not yet restored).
-
-For the slow path, save supervisor states to preserve them across context
-switches, and restore after the user states are restored.
-
-The previous version has the overhead of an XSAVES in both the fast and the
-slow paths.  It is addressed as the following:
-
-- In the fast path, only do an XRSTORS.
-- In the slow path, do a supervisor-state-only XSAVES, and relocate the
-  buffer contents.
-
-Some thoughts in the implementation:
-
-- In the slow path, can any supervisor state become stale between
-  save/restore?
-
-  Answer: set_thread_flag(TIF_NEED_FPU_LOAD) protects the xstate buffer.
-
-- In the slow path, can any code reference a stale supervisor state
-  register between save/restore?
-
-  Answer: In the current lazy-restore scheme, any reference to xstate
-  registers needs fpregs_lock()/fpregs_unlock() and __fpregs_load_activate().
-
-- Are there other options?
-
-  One other option is eagerly restoring all supervisor states.
-
-  Currently, CET user-mode states and ENQCMD's PASID do not need to be
-  eagerly restored.  The upcoming CET kernel-mode states (24 bytes) need
-  to be eagerly restored.  To me, eagerly restoring all supervisor states
-  adds more overhead then benefit at this point.
-
-v3:
-- Change copy_xregs_to_kernel() to copy_supervisor_to_kernel(), which is
-  introduced in a previous patch.
-- Update commit log.
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Dave Hansen <dave.hansen@linux.intel.com>
----
- arch/x86/kernel/fpu/signal.c | 44 ++++++++++++++++++++++++++++++++----
- 1 file changed, 39 insertions(+), 5 deletions(-)
-
-diff --git a/arch/x86/kernel/fpu/signal.c b/arch/x86/kernel/fpu/signal.c
-index c0e07b548076..003735eec674 100644
---- a/arch/x86/kernel/fpu/signal.c
-+++ b/arch/x86/kernel/fpu/signal.c
-@@ -347,6 +347,23 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
- 		ret = copy_user_to_fpregs_zeroing(buf_fx, user_xfeatures, fx_only);
- 		pagefault_enable();
- 		if (!ret) {
-+
-+			/*
-+			 * Restore supervisor states: previous context switch
-+			 * etc has done XSAVES and saved the supervisor states
-+			 * in the kernel buffer from which they can be restored
-+			 * now.
-+			 *
-+			 * We cannot do a single XRSTORS here - which would
-+			 * be nice - because the rest of the FPU registers are
-+			 * being restored from a user buffer directly. The
-+			 * single XRSTORS happens below, when the user buffer
-+			 * has been copied to the kernel one.
-+			 */
-+			if (test_thread_flag(TIF_NEED_FPU_LOAD) &&
-+			    xfeatures_mask_supervisor())
-+				copy_kernel_to_xregs(&fpu->state.xsave,
-+						     xfeatures_mask_supervisor());
- 			fpregs_mark_activate();
- 			fpregs_unlock();
- 			return 0;
-@@ -364,14 +381,25 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
- 	}
- 
- 	/*
--	 * The current state of the FPU registers does not matter. By setting
--	 * TIF_NEED_FPU_LOAD unconditionally it is ensured that the our xstate
--	 * is not modified on context switch and that the xstate is considered
-+	 * By setting TIF_NEED_FPU_LOAD it is ensured that our xstate is
-+	 * not modified on context switch and that the xstate is considered
- 	 * to be loaded again on return to userland (overriding last_cpu avoids
- 	 * the optimisation).
- 	 */
--	set_thread_flag(TIF_NEED_FPU_LOAD);
-+	fpregs_lock();
-+
-+	if (!test_thread_flag(TIF_NEED_FPU_LOAD)) {
-+
-+		/*
-+		 * Supervisor states are not modified by user space input.  Save
-+		 * current supervisor states first and invalidate the FPU regs.
-+		 */
-+		if (xfeatures_mask_supervisor())
-+			copy_supervisor_to_kernel(&fpu->state.xsave);
-+		set_thread_flag(TIF_NEED_FPU_LOAD);
-+	}
- 	__fpu_invalidate_fpregs_state(fpu);
-+	fpregs_unlock();
- 
- 	if (use_xsave() && !fx_only) {
- 		u64 init_bv = xfeatures_mask_user() & ~user_xfeatures;
-@@ -393,7 +421,13 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
- 		fpregs_lock();
- 		if (unlikely(init_bv))
- 			copy_kernel_to_xregs(&init_fpstate.xsave, init_bv);
--		ret = copy_kernel_to_xregs_err(&fpu->state.xsave, user_xfeatures);
-+
-+		/*
-+		 * Restore previously saved supervisor xstates along with
-+		 * copied-in user xstates.
-+		 */
-+		ret = copy_kernel_to_xregs_err(&fpu->state.xsave,
-+					       user_xfeatures | xfeatures_mask_supervisor());
- 
- 	} else if (use_fxsr()) {
- 		ret = __copy_from_user(&fpu->state.fxsave, buf_fx, state_size);
--- 
-2.26.2
-
diff --git a/0020-x86-mm-Update-pte_modify-for-_PAGE_COW.patch b/0010-x86-mm-Update-pte_modify-for-_PAGE_COW.patch
similarity index 85%
rename from 0020-x86-mm-Update-pte_modify-for-_PAGE_COW.patch
rename to 0010-x86-mm-Update-pte_modify-for-_PAGE_COW.patch
index d58e60781..99aa2db81 100644
--- a/0020-x86-mm-Update-pte_modify-for-_PAGE_COW.patch
+++ b/0010-x86-mm-Update-pte_modify-for-_PAGE_COW.patch
@@ -1,7 +1,7 @@
-From 9274121b3a80dd2046ed015c8f6dc1caae296332 Mon Sep 17 00:00:00 2001
+From 994bc9351fb1c9ecebfdd1781ea8878559f42517 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Thu, 29 Aug 2019 09:24:13 -0700
-Subject: [PATCH 20/47] x86/mm: Update pte_modify for _PAGE_COW
+Subject: [PATCH 10/40] x86/mm: Update pte_modify for _PAGE_COW
 
 Pte_modify() changes a PTE to 'newprot'.  It doesn't use the pte_*()
 helpers that a previous patch fixed up, so we need a new site.
@@ -12,17 +12,16 @@ apply the same changes to pmd_modify().
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 
 v10:
-- Change static_cpu_has() to cpu_feature_enabled().
 - Replace _PAGE_CHG_MASK approach with fixup functions.
 ---
  arch/x86/include/asm/pgtable.h | 33 +++++++++++++++++++++++++++++++++
  1 file changed, 33 insertions(+)
 
 diff --git a/arch/x86/include/asm/pgtable.h b/arch/x86/include/asm/pgtable.h
-index 5f89035d1e60..f4870cd040de 100644
+index 1b57b5543adb..53048a3ff876 100644
 --- a/arch/x86/include/asm/pgtable.h
 +++ b/arch/x86/include/asm/pgtable.h
-@@ -726,6 +726,21 @@ static inline pmd_t pmd_mknotpresent(pmd_t pmd)
+@@ -727,6 +727,21 @@ static inline pmd_t pmd_mkinvalid(pmd_t pmd)
  
  static inline u64 flip_protnone_guard(u64 oldval, u64 val, u64 mask);
  
@@ -44,7 +43,7 @@ index 5f89035d1e60..f4870cd040de 100644
  static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
  {
  	pteval_t val = pte_val(pte), oldval = val;
-@@ -736,16 +751,34 @@ static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
+@@ -737,16 +752,34 @@ static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
  	 */
  	val &= _PAGE_CHG_MASK;
  	val |= check_pgprot(newprot) & ~_PAGE_CHG_MASK;
diff --git a/0021-x86-mm-Update-ptep_set_wrprotect-and-pmdp_set_wrprot.patch b/0011-x86-mm-Update-ptep_set_wrprotect-and-pmdp_set_wrprot.patch
similarity index 91%
rename from 0021-x86-mm-Update-ptep_set_wrprotect-and-pmdp_set_wrprot.patch
rename to 0011-x86-mm-Update-ptep_set_wrprotect-and-pmdp_set_wrprot.patch
index 2e2c1da7a..1b7a48bf6 100644
--- a/0021-x86-mm-Update-ptep_set_wrprotect-and-pmdp_set_wrprot.patch
+++ b/0011-x86-mm-Update-ptep_set_wrprotect-and-pmdp_set_wrprot.patch
@@ -1,7 +1,7 @@
-From fe62117cb5951c82e604a3cb770021910b4e27da Mon Sep 17 00:00:00 2001
+From 905043b9a8465bbf8d610e7485220cb7af8b061d Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Fri, 15 Jun 2018 09:33:40 -0700
-Subject: [PATCH 21/47] x86/mm: Update ptep_set_wrprotect() and
+Subject: [PATCH 11/40] x86/mm: Update ptep_set_wrprotect() and
  pmdp_set_wrprotect() for transition from _PAGE_DIRTY_HW to _PAGE_COW
 
 When shadow stack is introduced, [R/O + _PAGE_DIRTY_HW] PTE is reserved
@@ -23,7 +23,6 @@ Dave Hansen, Jann Horn, Andy Lutomirski, and Peter Zijlstra provided many
 insights to the issue.  Jann Horn provided the cmpxchg solution.
 
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Kees Cook <keescook@chromium.org>
 
 v10:
 - Replace bit shift with pte_wrprotect()/pmd_wrprotect(), which use bit
@@ -43,10 +42,10 @@ v4:
  1 file changed, 52 insertions(+)
 
 diff --git a/arch/x86/include/asm/pgtable.h b/arch/x86/include/asm/pgtable.h
-index f4870cd040de..eaa38adb1038 100644
+index 53048a3ff876..18dfedbbd87a 100644
 --- a/arch/x86/include/asm/pgtable.h
 +++ b/arch/x86/include/asm/pgtable.h
-@@ -1316,6 +1316,32 @@ static inline pte_t ptep_get_and_clear_full(struct mm_struct *mm,
+@@ -1233,6 +1233,32 @@ static inline pte_t ptep_get_and_clear_full(struct mm_struct *mm,
  static inline void ptep_set_wrprotect(struct mm_struct *mm,
  				      unsigned long addr, pte_t *ptep)
  {
@@ -79,7 +78,7 @@ index f4870cd040de..eaa38adb1038 100644
  	clear_bit(_PAGE_BIT_RW, (unsigned long *)&ptep->pte);
  }
  
-@@ -1372,6 +1398,32 @@ static inline pud_t pudp_huge_get_and_clear(struct mm_struct *mm,
+@@ -1289,6 +1315,32 @@ static inline pud_t pudp_huge_get_and_clear(struct mm_struct *mm,
  static inline void pmdp_set_wrprotect(struct mm_struct *mm,
  				      unsigned long addr, pmd_t *pmdp)
  {
diff --git a/0022-mm-Introduce-VM_SHSTK-for-shadow-stack-memory.patch b/0012-mm-Introduce-VM_SHSTK-for-shadow-stack-memory.patch
similarity index 78%
rename from 0022-mm-Introduce-VM_SHSTK-for-shadow-stack-memory.patch
rename to 0012-mm-Introduce-VM_SHSTK-for-shadow-stack-memory.patch
index a6ddd8985..154ae5b53 100644
--- a/0022-mm-Introduce-VM_SHSTK-for-shadow-stack-memory.patch
+++ b/0012-mm-Introduce-VM_SHSTK-for-shadow-stack-memory.patch
@@ -1,7 +1,7 @@
-From 0a010dee48e194ef3d88731d58ff5e1cae81805f Mon Sep 17 00:00:00 2001
+From 6404e5270c8cb4ae4e5b70017a0d6a2ef1c1dc4f Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Fri, 12 Jan 2018 15:04:54 -0800
-Subject: [PATCH 22/47] mm: Introduce VM_SHSTK for shadow stack memory
+Subject: [PATCH 12/40] mm: Introduce VM_SHSTK for shadow stack memory
 
 A Shadow Stack PTE must be read-only and have _PAGE_DIRTY set.  However,
 read-only and Dirty PTEs also exist for copy-on-write (COW) pages.  These
@@ -9,7 +9,6 @@ two cases are handled differently for page faults.  Introduce VM_SHSTK to
 track shadow stack VMAs.
 
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Kees Cook <keescook@chromium.org>
 
 v9:
 - Add VM_SHSTK case to arch_vma_name().
@@ -21,10 +20,10 @@ v9:
  3 files changed, 13 insertions(+)
 
 diff --git a/arch/x86/mm/mmap.c b/arch/x86/mm/mmap.c
-index cb91eccc4960..fe77fd6debf1 100644
+index c90c20904a60..a22c6b6fc607 100644
 --- a/arch/x86/mm/mmap.c
 +++ b/arch/x86/mm/mmap.c
-@@ -163,6 +163,8 @@ unsigned long get_mmap_base(int is_legacy)
+@@ -165,6 +165,8 @@ unsigned long get_mmap_base(int is_legacy)
  
  const char *arch_vma_name(struct vm_area_struct *vma)
  {
@@ -34,10 +33,10 @@ index cb91eccc4960..fe77fd6debf1 100644
  }
  
 diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c
-index 8d382d4ec067..434692759265 100644
+index dbda4499a859..0605426a933d 100644
 --- a/fs/proc/task_mmu.c
 +++ b/fs/proc/task_mmu.c
-@@ -657,6 +657,9 @@ static void show_smap_vma_flags(struct seq_file *m, struct vm_area_struct *vma)
+@@ -663,6 +663,9 @@ static void show_smap_vma_flags(struct seq_file *m, struct vm_area_struct *vma)
  		[ilog2(VM_PKEY_BIT4)]	= "",
  #endif
  #endif /* CONFIG_ARCH_HAS_PKEYS */
@@ -48,10 +47,10 @@ index 8d382d4ec067..434692759265 100644
  	size_t i;
  
 diff --git a/include/linux/mm.h b/include/linux/mm.h
-index f3fe7371855c..ac3490df64d8 100644
+index dc7b87310c10..0dc33e581c54 100644
 --- a/include/linux/mm.h
 +++ b/include/linux/mm.h
-@@ -294,11 +294,13 @@ extern unsigned int kobjsize(const void *objp);
+@@ -295,11 +295,13 @@ extern unsigned int kobjsize(const void *objp);
  #define VM_HIGH_ARCH_BIT_2	34	/* bit only usable on 64-bit architectures */
  #define VM_HIGH_ARCH_BIT_3	35	/* bit only usable on 64-bit architectures */
  #define VM_HIGH_ARCH_BIT_4	36	/* bit only usable on 64-bit architectures */
@@ -65,8 +64,8 @@ index f3fe7371855c..ac3490df64d8 100644
  #endif /* CONFIG_ARCH_USES_HIGH_VMA_FLAGS */
  
  #ifdef CONFIG_ARCH_HAS_PKEYS
-@@ -336,6 +338,12 @@ extern unsigned int kobjsize(const void *objp);
- # define VM_MPX		VM_NONE
+@@ -333,6 +335,12 @@ extern unsigned int kobjsize(const void *objp);
+ # define VM_MAPPED_COPY	VM_ARCH_1	/* T if mapped copy of data (nommu mmap) */
  #endif
  
 +#ifdef CONFIG_X86_INTEL_SHADOW_STACK_USER
diff --git a/0023-x86-mm-Shadow-Stack-page-fault-error-checking.patch b/0013-x86-mm-Shadow-Stack-page-fault-error-checking.patch
similarity index 86%
rename from 0023-x86-mm-Shadow-Stack-page-fault-error-checking.patch
rename to 0013-x86-mm-Shadow-Stack-page-fault-error-checking.patch
index b95a12870..e46b2ba78 100644
--- a/0023-x86-mm-Shadow-Stack-page-fault-error-checking.patch
+++ b/0013-x86-mm-Shadow-Stack-page-fault-error-checking.patch
@@ -1,7 +1,7 @@
-From afe0845429def9f7412d9a0d3629bea890bf7a56 Mon Sep 17 00:00:00 2001
+From 97711f7fc1f9e9a4b8745ed105b71326c981f993 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 28 Nov 2017 13:01:18 -0800
-Subject: [PATCH 23/47] x86/mm: Shadow Stack page fault error checking
+Subject: [PATCH 13/40] x86/mm: Shadow Stack page fault error checking
 
 Shadow stack accesses are those that are performed by the CPU where it
 expects to encounter a shadow stack mapping.  These accesses are performed
@@ -26,7 +26,6 @@ read fault and shadow stack write fault are not differentiated and both are
 handled as a write access.
 
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Kees Cook <keescook@chromium.org>
 
 v10:
 -Revise commit log.
@@ -36,10 +35,10 @@ v10:
  2 files changed, 21 insertions(+)
 
 diff --git a/arch/x86/include/asm/traps.h b/arch/x86/include/asm/traps.h
-index 9bf804709ee6..b4f4c725a350 100644
+index 714b1a30e7b0..28b493c53d70 100644
 --- a/arch/x86/include/asm/traps.h
 +++ b/arch/x86/include/asm/traps.h
-@@ -168,6 +168,7 @@ enum {
+@@ -50,6 +50,7 @@ void __noreturn handle_stack_overflow(const char *message,
   *   bit 3 ==				1: use of reserved bit detected
   *   bit 4 ==				1: fault was an instruction fetch
   *   bit 5 ==				1: protection keys block access
@@ -47,7 +46,7 @@ index 9bf804709ee6..b4f4c725a350 100644
   */
  enum x86_pf_error_code {
  	X86_PF_PROT	=		1 << 0,
-@@ -176,5 +177,6 @@ enum x86_pf_error_code {
+@@ -58,5 +59,6 @@ enum x86_pf_error_code {
  	X86_PF_RSVD	=		1 << 3,
  	X86_PF_INSTR	=		1 << 4,
  	X86_PF_PK	=		1 << 5,
@@ -55,10 +54,10 @@ index 9bf804709ee6..b4f4c725a350 100644
  };
  #endif /* _ASM_X86_TRAPS_H */
 diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c
-index a51df516b87b..a4a3c8f016f0 100644
+index 1ead568c0101..8c95dc851615 100644
 --- a/arch/x86/mm/fault.c
 +++ b/arch/x86/mm/fault.c
-@@ -1210,6 +1210,17 @@ access_error(unsigned long error_code, struct vm_area_struct *vma)
+@@ -1064,6 +1064,17 @@ access_error(unsigned long error_code, struct vm_area_struct *vma)
  				       (error_code & X86_PF_INSTR), foreign))
  		return 1;
  
@@ -76,7 +75,7 @@ index a51df516b87b..a4a3c8f016f0 100644
  	if (error_code & X86_PF_WRITE) {
  		/* write, present and write, not present: */
  		if (unlikely(!(vma->vm_flags & VM_WRITE)))
-@@ -1367,6 +1378,14 @@ void do_user_addr_fault(struct pt_regs *regs,
+@@ -1198,6 +1209,14 @@ void do_user_addr_fault(struct pt_regs *regs,
  
  	perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);
  
diff --git a/0024-x86-mm-Update-maybe_mkwrite-for-shadow-stack.patch b/0014-x86-mm-Update-maybe_mkwrite-for-shadow-stack.patch
similarity index 73%
rename from 0024-x86-mm-Update-maybe_mkwrite-for-shadow-stack.patch
rename to 0014-x86-mm-Update-maybe_mkwrite-for-shadow-stack.patch
index 0f1b1dad4..e5f17cfa2 100644
--- a/0024-x86-mm-Update-maybe_mkwrite-for-shadow-stack.patch
+++ b/0014-x86-mm-Update-maybe_mkwrite-for-shadow-stack.patch
@@ -1,25 +1,25 @@
-From 9705338c9d66aa1118c4cf1c2ee6cd09cac55f9d Mon Sep 17 00:00:00 2001
+From f9330f1aa9d71c305e475f67ca32575e1e5059b8 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 7 Apr 2020 16:03:36 -0700
-Subject: [PATCH 24/47] x86/mm: Update maybe_mkwrite() for shadow stack
+Subject: [PATCH 14/40] x86/mm: Update maybe_mkwrite() for shadow stack
 
 Shadow stack memory is writable, but its VMA has VM_SHSTK instead of
 VM_WRITE.  Update maybe_mkwrite() to include the shadow stack.
 
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 ---
- arch/x86/Kconfig              |  4 ++++
- arch/x86/mm/pgtable.c         | 18 ++++++++++++++++++
- include/asm-generic/pgtable.h | 24 ++++++++++++++++++++++++
- include/linux/mm.h            |  2 ++
- mm/huge_memory.c              |  2 ++
+ arch/x86/Kconfig        |  4 ++++
+ arch/x86/mm/pgtable.c   | 18 ++++++++++++++++++
+ include/linux/mm.h      |  2 ++
+ include/linux/pgtable.h | 24 ++++++++++++++++++++++++
+ mm/huge_memory.c        |  2 ++
  5 files changed, 50 insertions(+)
 
 diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
-index 315647350fa2..df24c4a90ea0 100644
+index 3dedb666d9f7..7c0493c41420 100644
 --- a/arch/x86/Kconfig
 +++ b/arch/x86/Kconfig
-@@ -1956,6 +1956,9 @@ config AS_HAS_SHADOW_STACK
+@@ -1934,6 +1934,9 @@ config AS_HAS_SHADOW_STACK
  config X86_INTEL_CET
  	def_bool n
  
@@ -29,7 +29,7 @@ index 315647350fa2..df24c4a90ea0 100644
  config ARCH_HAS_SHADOW_STACK
  	def_bool n
  
-@@ -1966,6 +1969,7 @@ config X86_INTEL_SHADOW_STACK_USER
+@@ -1944,6 +1947,7 @@ config X86_INTEL_SHADOW_STACK_USER
  	depends on AS_HAS_SHADOW_STACK
  	select ARCH_USES_HIGH_VMA_FLAGS
  	select X86_INTEL_CET
@@ -38,10 +38,10 @@ index 315647350fa2..df24c4a90ea0 100644
  	help
  	  Shadow Stacks provides protection against program stack
 diff --git a/arch/x86/mm/pgtable.c b/arch/x86/mm/pgtable.c
-index 7bd2c3a52297..aa4d396ff98d 100644
+index dfd82f51ba66..a9666b64bc05 100644
 --- a/arch/x86/mm/pgtable.c
 +++ b/arch/x86/mm/pgtable.c
-@@ -603,6 +603,24 @@ int pmdp_clear_flush_young(struct vm_area_struct *vma,
+@@ -610,6 +610,24 @@ int pmdp_clear_flush_young(struct vm_area_struct *vma,
  }
  #endif
  
@@ -66,11 +66,24 @@ index 7bd2c3a52297..aa4d396ff98d 100644
  /**
   * reserve_top_address - reserves a hole in the top of kernel address space
   * @reserve - size of hole to reserve
-diff --git a/include/asm-generic/pgtable.h b/include/asm-generic/pgtable.h
-index 329b8c8ca703..2c3875724809 100644
---- a/include/asm-generic/pgtable.h
-+++ b/include/asm-generic/pgtable.h
-@@ -1191,6 +1191,30 @@ static inline bool arch_has_pfn_modify_check(void)
+diff --git a/include/linux/mm.h b/include/linux/mm.h
+index 0dc33e581c54..81d7a65fa208 100644
+--- a/include/linux/mm.h
++++ b/include/linux/mm.h
+@@ -952,6 +952,8 @@ static inline pte_t maybe_mkwrite(pte_t pte, struct vm_area_struct *vma)
+ {
+ 	if (likely(vma->vm_flags & VM_WRITE))
+ 		pte = pte_mkwrite(pte);
++	else
++		pte = arch_maybe_mkwrite(pte, vma);
+ 	return pte;
+ }
+ 
+diff --git a/include/linux/pgtable.h b/include/linux/pgtable.h
+index 56c1e8eb7bb0..03a0815c49e6 100644
+--- a/include/linux/pgtable.h
++++ b/include/linux/pgtable.h
+@@ -1351,6 +1351,30 @@ static inline bool arch_has_pfn_modify_check(void)
  }
  #endif /* !_HAVE_ARCH_PFN_MODIFY_ALLOWED */
  
@@ -101,21 +114,8 @@ index 329b8c8ca703..2c3875724809 100644
  /*
   * Architecture PAGE_KERNEL_* fallbacks
   *
-diff --git a/include/linux/mm.h b/include/linux/mm.h
-index ac3490df64d8..6c31b5222b0f 100644
---- a/include/linux/mm.h
-+++ b/include/linux/mm.h
-@@ -955,6 +955,8 @@ static inline pte_t maybe_mkwrite(pte_t pte, struct vm_area_struct *vma)
- {
- 	if (likely(vma->vm_flags & VM_WRITE))
- 		pte = pte_mkwrite(pte);
-+	else
-+		pte = arch_maybe_mkwrite(pte, vma);
- 	return pte;
- }
- 
 diff --git a/mm/huge_memory.c b/mm/huge_memory.c
-index 6ecd1045113b..608746bb9d19 100644
+index 78c84bee7e29..6b1512961f32 100644
 --- a/mm/huge_memory.c
 +++ b/mm/huge_memory.c
 @@ -485,6 +485,8 @@ pmd_t maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma)
diff --git a/0025-mm-Fixup-places-that-call-pte_mkwrite-directly.patch b/0015-mm-Fixup-places-that-call-pte_mkwrite-directly.patch
similarity index 83%
rename from 0025-mm-Fixup-places-that-call-pte_mkwrite-directly.patch
rename to 0015-mm-Fixup-places-that-call-pte_mkwrite-directly.patch
index 230508b79..4ed4224cf 100644
--- a/0025-mm-Fixup-places-that-call-pte_mkwrite-directly.patch
+++ b/0015-mm-Fixup-places-that-call-pte_mkwrite-directly.patch
@@ -1,7 +1,7 @@
-From cd5f5266db8dc418271ebc131313633bfe96e51a Mon Sep 17 00:00:00 2001
+From e756baaf123ea5348d9e67389aa9498e8e5b1027 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Mon, 13 Apr 2020 13:21:22 -0700
-Subject: [PATCH 25/47] mm: Fixup places that call pte_mkwrite() directly
+Subject: [PATCH 15/40] mm: Fixup places that call pte_mkwrite() directly
 
 A shadow stack page is made writable by pte_mkwrite_shstk(), which sets
 _PAGE_DIRTY_HW.  There are a few places that call pte_mkwrite() directly
@@ -26,20 +26,20 @@ Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
  3 files changed, 4 insertions(+), 6 deletions(-)
 
 diff --git a/mm/memory.c b/mm/memory.c
-index f703fe8c8346..b9002f644806 100644
+index 3ecad55103ad..5334d088472c 100644
 --- a/mm/memory.c
 +++ b/mm/memory.c
-@@ -3373,8 +3373,7 @@ static vm_fault_t do_anonymous_page(struct vm_fault *vmf)
- 	__SetPageUptodate(page);
+@@ -3388,8 +3388,7 @@ static vm_fault_t do_anonymous_page(struct vm_fault *vmf)
  
  	entry = mk_pte(page, vma->vm_page_prot);
+ 	entry = pte_sw_mkyoung(entry);
 -	if (vma->vm_flags & VM_WRITE)
 -		entry = pte_mkwrite(pte_mkdirty(entry));
 +	entry = maybe_mkwrite(pte_mkdirty(entry), vma);
  
  	vmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd, vmf->address,
  			&vmf->ptl);
-@@ -4033,7 +4032,7 @@ static vm_fault_t do_numa_page(struct vm_fault *vmf)
+@@ -4043,7 +4042,7 @@ static vm_fault_t do_numa_page(struct vm_fault *vmf)
  	pte = pte_modify(old_pte, vma->vm_page_prot);
  	pte = pte_mkyoung(pte);
  	if (was_writable)
@@ -49,10 +49,10 @@ index f703fe8c8346..b9002f644806 100644
  	update_mmu_cache(vma, vmf->address, vmf->pte);
  
 diff --git a/mm/migrate.c b/mm/migrate.c
-index 7160c1556f79..0fa59b1562c6 100644
+index 40cd7016ae6f..8fea8636563e 100644
 --- a/mm/migrate.c
 +++ b/mm/migrate.c
-@@ -2805,8 +2805,7 @@ static void migrate_vma_insert_page(struct migrate_vma *migrate,
+@@ -2794,8 +2794,7 @@ static void migrate_vma_insert_page(struct migrate_vma *migrate,
  		}
  	} else {
  		entry = mk_pte(page, vma->vm_page_prot);
@@ -63,7 +63,7 @@ index 7160c1556f79..0fa59b1562c6 100644
  
  	ptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);
 diff --git a/mm/mprotect.c b/mm/mprotect.c
-index 494192ca954b..02762af1057c 100644
+index ce8b8a5eacbb..a8edbcb3af99 100644
 --- a/mm/mprotect.c
 +++ b/mm/mprotect.c
 @@ -135,7 +135,7 @@ static unsigned long change_pte_range(struct vm_area_struct *vma, pmd_t *pmd,
diff --git a/0026-mm-Add-guard-pages-around-a-shadow-stack.patch b/0016-mm-Add-guard-pages-around-a-shadow-stack.patch
similarity index 83%
rename from 0026-mm-Add-guard-pages-around-a-shadow-stack.patch
rename to 0016-mm-Add-guard-pages-around-a-shadow-stack.patch
index e2c4b3872..b21ad2e91 100644
--- a/0026-mm-Add-guard-pages-around-a-shadow-stack.patch
+++ b/0016-mm-Add-guard-pages-around-a-shadow-stack.patch
@@ -1,7 +1,7 @@
-From c2a20059924bcb9c77937a77c9999e9eec5a0a4f Mon Sep 17 00:00:00 2001
+From 2cc77f65bd353f057d7c80d1fccfb42889af86d6 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Fri, 4 Oct 2019 14:00:58 -0700
-Subject: [PATCH 26/47] mm: Add guard pages around a shadow stack.
+Subject: [PATCH 16/40] mm: Add guard pages around a shadow stack.
 
 INCSSP(Q/D) increments shadow stack pointer and 'pops and discards' the
 first and the last elements in the range, effectively touches those memory
@@ -22,10 +22,10 @@ v10:
  2 files changed, 30 insertions(+), 4 deletions(-)
 
 diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h
-index 3bcf27caf6c9..eb9536f803f9 100644
+index 03b7c4ca425a..ae18f1820795 100644
 --- a/arch/x86/include/asm/processor.h
 +++ b/arch/x86/include/asm/processor.h
-@@ -907,6 +907,16 @@ static inline void spin_lock_prefetch(const void *x)
+@@ -906,6 +906,16 @@ static inline void spin_lock_prefetch(const void *x)
  #define STACK_TOP		TASK_SIZE_LOW
  #define STACK_TOP_MAX		TASK_SIZE_MAX
  
@@ -43,12 +43,12 @@ index 3bcf27caf6c9..eb9536f803f9 100644
  	.addr_limit		= KERNEL_DS,			\
  }
 diff --git a/include/linux/mm.h b/include/linux/mm.h
-index 6c31b5222b0f..5c623db088eb 100644
+index 81d7a65fa208..9f86af53e889 100644
 --- a/include/linux/mm.h
 +++ b/include/linux/mm.h
-@@ -2641,6 +2641,10 @@ void page_cache_async_readahead(struct address_space *mapping,
- 				pgoff_t offset,
- 				unsigned long size);
+@@ -2654,6 +2654,10 @@ extern vm_fault_t filemap_page_mkwrite(struct vm_fault *vmf);
+ int __must_check write_one_page(struct page *page);
+ void task_dirty_inc(struct task_struct *tsk);
  
 +#ifndef ARCH_SHADOW_STACK_GUARD_GAP
 +#define ARCH_SHADOW_STACK_GUARD_GAP 0
@@ -57,7 +57,7 @@ index 6c31b5222b0f..5c623db088eb 100644
  extern unsigned long stack_guard_gap;
  /* Generic expand stack which grows the stack according to GROWS{UP,DOWN} */
  extern int expand_stack(struct vm_area_struct *vma, unsigned long address);
-@@ -2673,9 +2677,15 @@ static inline struct vm_area_struct * find_vma_intersection(struct mm_struct * m
+@@ -2686,9 +2690,15 @@ static inline struct vm_area_struct * find_vma_intersection(struct mm_struct * m
  static inline unsigned long vm_start_gap(struct vm_area_struct *vma)
  {
  	unsigned long vm_start = vma->vm_start;
@@ -75,7 +75,7 @@ index 6c31b5222b0f..5c623db088eb 100644
  		if (vm_start > vma->vm_start)
  			vm_start = 0;
  	}
-@@ -2685,9 +2695,15 @@ static inline unsigned long vm_start_gap(struct vm_area_struct *vma)
+@@ -2698,9 +2708,15 @@ static inline unsigned long vm_start_gap(struct vm_area_struct *vma)
  static inline unsigned long vm_end_gap(struct vm_area_struct *vma)
  {
  	unsigned long vm_end = vma->vm_end;
diff --git a/0027-mm-mmap-Add-shadow-stack-pages-to-memory-accounting.patch b/0017-mm-mmap-Add-shadow-stack-pages-to-memory-accounting.patch
similarity index 70%
rename from 0027-mm-mmap-Add-shadow-stack-pages-to-memory-accounting.patch
rename to 0017-mm-mmap-Add-shadow-stack-pages-to-memory-accounting.patch
index 78a391b55..fa028201b 100644
--- a/0027-mm-mmap-Add-shadow-stack-pages-to-memory-accounting.patch
+++ b/0017-mm-mmap-Add-shadow-stack-pages-to-memory-accounting.patch
@@ -1,7 +1,7 @@
-From 699a8340f958398bc90c83fed9ad41da00a77789 Mon Sep 17 00:00:00 2001
+From 205ed97b5062749a3fefb7af681357129a4b115f Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Thu, 13 Sep 2018 12:36:48 -0700
-Subject: [PATCH 27/47] mm/mmap: Add shadow stack pages to memory accounting
+Subject: [PATCH 17/40] mm/mmap: Add shadow stack pages to memory accounting
 
 Account shadow stack pages to stack memory.
 
@@ -13,16 +13,16 @@ v10:
 v8:
 - Change shadow stake pages from data_vm to stack_vm.
 ---
- arch/x86/mm/pgtable.c         |  7 +++++++
- include/asm-generic/pgtable.h | 11 +++++++++++
- mm/mmap.c                     |  5 +++++
+ arch/x86/mm/pgtable.c   |  7 +++++++
+ include/linux/pgtable.h | 11 +++++++++++
+ mm/mmap.c               |  5 +++++
  3 files changed, 23 insertions(+)
 
 diff --git a/arch/x86/mm/pgtable.c b/arch/x86/mm/pgtable.c
-index aa4d396ff98d..f384e0314ba7 100644
+index a9666b64bc05..68e98f70298b 100644
 --- a/arch/x86/mm/pgtable.c
 +++ b/arch/x86/mm/pgtable.c
-@@ -890,3 +890,10 @@ int pmd_free_pte_page(pmd_t *pmd, unsigned long addr)
+@@ -893,3 +893,10 @@ int pmd_free_pte_page(pmd_t *pmd, unsigned long addr)
  
  #endif /* CONFIG_X86_64 */
  #endif	/* CONFIG_HAVE_ARCH_HUGE_VMAP */
@@ -33,11 +33,11 @@ index aa4d396ff98d..f384e0314ba7 100644
 +	return (vm_flags & VM_SHSTK);
 +}
 +#endif
-diff --git a/include/asm-generic/pgtable.h b/include/asm-generic/pgtable.h
-index 2c3875724809..dbd415ab7dd8 100644
---- a/include/asm-generic/pgtable.h
-+++ b/include/asm-generic/pgtable.h
-@@ -1215,6 +1215,17 @@ static inline pmd_t arch_maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma
+diff --git a/include/linux/pgtable.h b/include/linux/pgtable.h
+index 03a0815c49e6..19422c0fed2c 100644
+--- a/include/linux/pgtable.h
++++ b/include/linux/pgtable.h
+@@ -1375,6 +1375,17 @@ static inline pmd_t arch_maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma
  #endif /* CONFIG_ARCH_MAYBE_MKWRITE */
  #endif /* CONFIG_MMU */
  
@@ -56,7 +56,7 @@ index 2c3875724809..dbd415ab7dd8 100644
   * Architecture PAGE_KERNEL_* fallbacks
   *
 diff --git a/mm/mmap.c b/mm/mmap.c
-index f609e9ec4a25..70d240b3559c 100644
+index 8c7ca737a19b..01eac2df1ea0 100644
 --- a/mm/mmap.c
 +++ b/mm/mmap.c
 @@ -1681,6 +1681,9 @@ static inline int accountable_mapping(struct file *file, vm_flags_t vm_flags)
@@ -69,7 +69,7 @@ index f609e9ec4a25..70d240b3559c 100644
  	return (vm_flags & (VM_NORESERVE | VM_SHARED | VM_WRITE)) == VM_WRITE;
  }
  
-@@ -3318,6 +3321,8 @@ void vm_stat_account(struct mm_struct *mm, vm_flags_t flags, long npages)
+@@ -3330,6 +3333,8 @@ void vm_stat_account(struct mm_struct *mm, vm_flags_t flags, long npages)
  		mm->stack_vm += npages;
  	else if (is_data_mapping(flags))
  		mm->data_vm += npages;
diff --git a/0028-mm-Update-can_follow_write_pte-for-shadow-stack.patch b/0018-mm-Update-can_follow_write_pte-for-shadow-stack.patch
similarity index 73%
rename from 0028-mm-Update-can_follow_write_pte-for-shadow-stack.patch
rename to 0018-mm-Update-can_follow_write_pte-for-shadow-stack.patch
index bd9701684..98da62466 100644
--- a/0028-mm-Update-can_follow_write_pte-for-shadow-stack.patch
+++ b/0018-mm-Update-can_follow_write_pte-for-shadow-stack.patch
@@ -1,7 +1,7 @@
-From f14edafa82c18e1a36777ce096007a08cbc15c02 Mon Sep 17 00:00:00 2001
+From 9d5b15a6b076c41c1173aeef8de6aeaf637f7842 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 3 Jul 2018 13:07:12 -0700
-Subject: [PATCH 28/47] mm: Update can_follow_write_pte() for shadow stack
+Subject: [PATCH 18/40] mm: Update can_follow_write_pte() for shadow stack
 
 Can_follow_write_pte() ensures a read-only page is COWed by checking the
 FOLL_COW flag, and uses pte_dirty() to validate the flag is still valid.
@@ -17,15 +17,15 @@ Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 v10:
 - Reverse name changes to can_follow_write_*().
 ---
- mm/gup.c         | 9 ++++++---
- mm/huge_memory.c | 9 ++++++---
- 2 files changed, 12 insertions(+), 6 deletions(-)
+ mm/gup.c         | 8 +++++---
+ mm/huge_memory.c | 8 +++++---
+ 2 files changed, 10 insertions(+), 6 deletions(-)
 
 diff --git a/mm/gup.c b/mm/gup.c
-index 43cce23aea89..501f3ecac306 100644
+index 6f47697f8fb0..194dda81de7b 100644
 --- a/mm/gup.c
 +++ b/mm/gup.c
-@@ -385,9 +385,12 @@ static int follow_pfn_pte(struct vm_area_struct *vma, unsigned long address,
+@@ -384,9 +384,11 @@ static int follow_pfn_pte(struct vm_area_struct *vma, unsigned long address,
   * FOLL_FORCE or a forced COW break can write even to unwritable pte's,
   * but only after we've gone through a COW cycle and they are dirty.
   */
@@ -34,13 +34,12 @@ index 43cce23aea89..501f3ecac306 100644
 +					struct vm_area_struct *vma)
  {
 -	return pte_write(pte) || ((flags & FOLL_COW) && pte_dirty(pte));
-+	return pte_write(pte) || ((flags & FOLL_COW) &&
-+				  !arch_shadow_stack_mapping(vma->vm_flags) &&
-+				  pte_dirty(pte));
++	return pte_write(pte) || ((flags & FOLL_COW) && pte_dirty(pte) &&
++				  !arch_shadow_stack_mapping(vma->vm_flags));
  }
  
  /*
-@@ -440,7 +443,7 @@ static struct page *follow_page_pte(struct vm_area_struct *vma,
+@@ -439,7 +441,7 @@ static struct page *follow_page_pte(struct vm_area_struct *vma,
  	}
  	if ((flags & FOLL_NUMA) && pte_protnone(pte))
  		goto no_page;
@@ -50,10 +49,10 @@ index 43cce23aea89..501f3ecac306 100644
  		return NULL;
  	}
 diff --git a/mm/huge_memory.c b/mm/huge_memory.c
-index 8e5148e138d1..bc93ad0448e9 100644
+index 6b1512961f32..f8c9e5d569d8 100644
 --- a/mm/huge_memory.c
 +++ b/mm/huge_memory.c
-@@ -1520,9 +1520,12 @@ vm_fault_t do_huge_pmd_wp_page(struct vm_fault *vmf, pmd_t orig_pmd)
+@@ -1317,9 +1317,11 @@ vm_fault_t do_huge_pmd_wp_page(struct vm_fault *vmf, pmd_t orig_pmd)
   * FOLL_FORCE or a forced COW break can write even to unwritable pmd's,
   * but only after we've gone through a COW cycle and they are dirty.
   */
@@ -62,13 +61,12 @@ index 8e5148e138d1..bc93ad0448e9 100644
 +					struct vm_area_struct *vma)
  {
 -	return pmd_write(pmd) || ((flags & FOLL_COW) && pmd_dirty(pmd));
-+	return pmd_write(pmd) || ((flags & FOLL_COW) &&
-+				  !arch_shadow_stack_mapping(vma->vm_flags) &&
-+				  pmd_dirty(pmd));
++	return pmd_write(pmd) || ((flags & FOLL_COW) && pmd_dirty(pmd) &&
++				  !arch_shadow_stack_mapping(vma->vm_flags));
  }
  
  struct page *follow_trans_huge_pmd(struct vm_area_struct *vma,
-@@ -1535,7 +1538,7 @@ struct page *follow_trans_huge_pmd(struct vm_area_struct *vma,
+@@ -1332,7 +1334,7 @@ struct page *follow_trans_huge_pmd(struct vm_area_struct *vma,
  
  	assert_spin_locked(pmd_lockptr(mm, pmd));
  
diff --git a/0029-x86-cet-shstk-User-mode-shadow-stack-support.patch b/0019-x86-cet-shstk-User-mode-shadow-stack-support.patch
similarity index 86%
rename from 0029-x86-cet-shstk-User-mode-shadow-stack-support.patch
rename to 0019-x86-cet-shstk-User-mode-shadow-stack-support.patch
index 1af57d6ec..87de7dded 100644
--- a/0029-x86-cet-shstk-User-mode-shadow-stack-support.patch
+++ b/0019-x86-cet-shstk-User-mode-shadow-stack-support.patch
@@ -1,7 +1,7 @@
-From ca1a609ee448e93b86809cc383bbcac891c9f841 Mon Sep 17 00:00:00 2001
+From 844e0c15e87fa8c0a1a21b2a0b88b78c93b9c143 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Thu, 22 Aug 2019 10:06:11 -0700
-Subject: [PATCH 29/47] x86/cet/shstk: User-mode shadow stack support
+Subject: [PATCH 19/40] x86/cet/shstk: User-mode shadow stack support
 
 This patch adds basic shadow stack enabling/disabling routines.  A task's
 shadow stack is allocated from memory with VM_SHSTK flag and has a fixed
@@ -9,6 +9,10 @@ size of min(RLIMIT_STACK, 4GB).
 
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 
+v11:
+- Modify alloc_shstk() to take address and flags and pass to do_mmap().
+  This is to be used by an arch_prctl() introduced later.
+
 v10:
 - Change no_cet_shstk to no_user_shstk.
 - Limit shadow stack size to 4 GB, and round_up to PAGE_SIZE.
@@ -32,11 +36,11 @@ v2:
  arch/x86/include/asm/disabled-features.h      |   8 +-
  arch/x86/include/asm/processor.h              |   5 +
  arch/x86/kernel/Makefile                      |   2 +
- arch/x86/kernel/cet.c                         | 135 ++++++++++++++++++
+ arch/x86/kernel/cet.c                         | 138 ++++++++++++++++++
  arch/x86/kernel/cpu/common.c                  |  28 ++++
  arch/x86/kernel/process.c                     |   1 +
  .../arch/x86/include/asm/disabled-features.h  |   8 +-
- 8 files changed, 211 insertions(+), 2 deletions(-)
+ 8 files changed, 214 insertions(+), 2 deletions(-)
  create mode 100644 arch/x86/include/asm/cet.h
  create mode 100644 arch/x86/kernel/cet.c
 
@@ -99,7 +103,7 @@ index 4ea8584682f9..a0e1b24cfa02 100644
  #define DISABLED_MASK18	0
  #define DISABLED_MASK_CHECK BUILD_BUG_ON_ZERO(NCAPINTS != 19)
 diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h
-index eb9536f803f9..0ccf1c7ab173 100644
+index ae18f1820795..2243ff247e9a 100644
 --- a/arch/x86/include/asm/processor.h
 +++ b/arch/x86/include/asm/processor.h
 @@ -27,6 +27,7 @@ struct vm86;
@@ -110,7 +114,7 @@ index eb9536f803f9..0ccf1c7ab173 100644
  
  #include <linux/personality.h>
  #include <linux/cache.h>
-@@ -543,6 +544,10 @@ struct thread_struct {
+@@ -544,6 +545,10 @@ struct thread_struct {
  
  	unsigned int		sig_on_uaccess_err:1;
  
@@ -122,10 +126,10 @@ index eb9536f803f9..0ccf1c7ab173 100644
  	struct fpu		fpu;
  	/*
 diff --git a/arch/x86/kernel/Makefile b/arch/x86/kernel/Makefile
-index ba89cabe5fcf..e9cc2551573b 100644
+index e77261db2391..76f27f518266 100644
 --- a/arch/x86/kernel/Makefile
 +++ b/arch/x86/kernel/Makefile
-@@ -144,6 +144,8 @@ obj-$(CONFIG_UNWINDER_ORC)		+= unwind_orc.o
+@@ -145,6 +145,8 @@ obj-$(CONFIG_UNWINDER_ORC)		+= unwind_orc.o
  obj-$(CONFIG_UNWINDER_FRAME_POINTER)	+= unwind_frame.o
  obj-$(CONFIG_UNWINDER_GUESS)		+= unwind_guess.o
  
@@ -136,10 +140,10 @@ index ba89cabe5fcf..e9cc2551573b 100644
  ifeq ($(CONFIG_X86_64),y)
 diff --git a/arch/x86/kernel/cet.c b/arch/x86/kernel/cet.c
 new file mode 100644
-index 000000000000..d8196c8e792a
+index 000000000000..f261eabdf66b
 --- /dev/null
 +++ b/arch/x86/kernel/cet.c
-@@ -0,0 +1,135 @@
+@@ -0,0 +1,138 @@
 +/* SPDX-License-Identifier: GPL-2.0 */
 +/*
 + * cet.c - Control-flow Enforcement (CET)
@@ -195,15 +199,18 @@ index 000000000000..d8196c8e792a
 +	return ssp;
 +}
 +
-+static unsigned long alloc_shstk(unsigned long size)
++static unsigned long alloc_shstk(unsigned long addr, unsigned long size, int flags)
 +{
 +	struct mm_struct *mm = current->mm;
-+	unsigned long addr, populate;
++	unsigned long populate;
++
++	/* VM_SHSTK requires MAP_ANONYMOUS, MAP_PRIVATE */
++	flags |= MAP_ANONYMOUS | MAP_PRIVATE;
 +
-+	down_write(&mm->mmap_sem);
-+	addr = do_mmap(NULL, 0, size, PROT_READ, MAP_ANONYMOUS | MAP_PRIVATE,
-+		       VM_SHSTK, 0, &populate, NULL);
-+	up_write(&mm->mmap_sem);
++	mmap_write_lock(mm);
++	addr = do_mmap(NULL, addr, size, PROT_READ, flags, VM_SHSTK, 0,
++		       &populate, NULL);
++	mmap_write_unlock(mm);
 +
 +	if (populate)
 +		mm_populate(addr, populate);
@@ -220,9 +227,9 @@ index 000000000000..d8196c8e792a
 +		return -EOPNOTSUPP;
 +
 +	size = round_up(min(rlimit(RLIMIT_STACK), 1UL << 32), PAGE_SIZE);
-+	addr = alloc_shstk(size);
++	addr = alloc_shstk(0, size, 0);
 +
-+	if (IS_ERR((void *)addr))
++	if (IS_ERR_VALUE(addr))
 +		return PTR_ERR((void *)addr);
 +
 +	cet->shstk_base = addr;
@@ -230,7 +237,7 @@ index 000000000000..d8196c8e792a
 +
 +	start_update_msrs();
 +	wrmsrl(MSR_IA32_PL3_SSP, addr + size);
-+	wrmsrl(MSR_IA32_U_CET, MSR_IA32_CET_SHSTK_EN);
++	wrmsrl(MSR_IA32_U_CET, CET_SHSTK_EN);
 +	end_update_msrs();
 +	return 0;
 +}
@@ -251,7 +258,7 @@ index 000000000000..d8196c8e792a
 +
 +		start_update_msrs();
 +		rdmsrl(MSR_IA32_U_CET, msr_val);
-+		wrmsrl(MSR_IA32_U_CET, msr_val & ~MSR_IA32_CET_SHSTK_EN);
++		wrmsrl(MSR_IA32_U_CET, msr_val & ~CET_SHSTK_EN);
 +		wrmsrl(MSR_IA32_PL3_SSP, 0);
 +		end_update_msrs();
 +	}
@@ -262,7 +269,7 @@ index 000000000000..d8196c8e792a
 +		r = vm_munmap(cet->shstk_base, cet->shstk_size);
 +
 +		/*
-+		 * Retry if mmap_sem is not available.
++		 * Retry if mmap_lock is not available.
 +		 */
 +		if (r == -EINTR) {
 +			cond_resched();
@@ -276,7 +283,7 @@ index 000000000000..d8196c8e792a
 +	cet->shstk_size = 0;
 +}
 diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c
-index bed0cb83fe24..1563b472e0f9 100644
+index 95c090a45b4b..44d51d8008cc 100644
 --- a/arch/x86/kernel/cpu/common.c
 +++ b/arch/x86/kernel/cpu/common.c
 @@ -55,6 +55,7 @@
@@ -287,7 +294,7 @@ index bed0cb83fe24..1563b472e0f9 100644
  #include <asm/uv/uv.h>
  
  #include "cpu.h"
-@@ -469,6 +470,32 @@ static __init int setup_disable_pku(char *arg)
+@@ -492,6 +493,32 @@ static __init int setup_disable_pku(char *arg)
  __setup("nopku", setup_disable_pku);
  #endif /* CONFIG_X86_64 */
  
@@ -320,16 +327,16 @@ index bed0cb83fe24..1563b472e0f9 100644
  /*
   * Some CPU features depend on higher CPUID levels, which may not always
   * be available due to CPUID level capping or broken virtualization
-@@ -1505,6 +1532,7 @@ static void identify_cpu(struct cpuinfo_x86 *c)
+@@ -1521,6 +1548,7 @@ static void identify_cpu(struct cpuinfo_x86 *c)
+ 
  	x86_init_rdrand(c);
- 	x86_init_cache_qos(c);
  	setup_pku(c);
 +	setup_cet(c);
  
  	/*
  	 * Clear/Set all flags overridden by options, need do it
 diff --git a/arch/x86/kernel/process.c b/arch/x86/kernel/process.c
-index ce6cd220f722..56587051df5a 100644
+index fe67dbd76e51..9b2c84cbf805 100644
 --- a/arch/x86/kernel/process.c
 +++ b/arch/x86/kernel/process.c
 @@ -42,6 +42,7 @@
diff --git a/0030-x86-cet-shstk-Handle-signals-for-shadow-stack.patch b/0020-x86-cet-shstk-Handle-signals-for-shadow-stack.patch
similarity index 95%
rename from 0030-x86-cet-shstk-Handle-signals-for-shadow-stack.patch
rename to 0020-x86-cet-shstk-Handle-signals-for-shadow-stack.patch
index 462cfa92a..c9eeaab8b 100644
--- a/0030-x86-cet-shstk-Handle-signals-for-shadow-stack.patch
+++ b/0020-x86-cet-shstk-Handle-signals-for-shadow-stack.patch
@@ -1,7 +1,7 @@
-From b30f0fddbdd84f37040474a7e07c35b13d3e3158 Mon Sep 17 00:00:00 2001
+From 82ebc16e41da8abe8e886e3f147a5b1ab9078d3d Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Thu, 5 Jan 2017 13:48:31 -0800
-Subject: [PATCH 30/47] x86/cet/shstk: Handle signals for shadow stack
+Subject: [PATCH 20/40] x86/cet/shstk: Handle signals for shadow stack
 
 To deliver a signal, create a shadow stack restore token and put a restore
 token and the signal restorer address on the shadow stack.  For sigreturn,
@@ -46,7 +46,7 @@ v2:
  8 files changed, 340 insertions(+)
 
 diff --git a/arch/x86/ia32/ia32_signal.c b/arch/x86/ia32/ia32_signal.c
-index f9d8804144d0..cb19159817cb 100644
+index 81cf22398cd1..cec9cf0a00cf 100644
 --- a/arch/x86/ia32/ia32_signal.c
 +++ b/arch/x86/ia32/ia32_signal.c
 @@ -35,6 +35,7 @@
@@ -118,7 +118,7 @@ index caac0687c8e4..56fe08eebae6 100644
  
  #endif /* __ASSEMBLY__ */
 diff --git a/arch/x86/include/asm/fpu/internal.h b/arch/x86/include/asm/fpu/internal.h
-index 42159f45bf9c..b569ac929ccc 100644
+index 845e7481ab77..8bf59b5b82b7 100644
 --- a/arch/x86/include/asm/fpu/internal.h
 +++ b/arch/x86/include/asm/fpu/internal.h
 @@ -476,6 +476,16 @@ static inline void copy_kernel_to_fpregs(union fpregs_state *fpstate)
@@ -139,10 +139,10 @@ index 42159f45bf9c..b569ac929ccc 100644
  
  /*
 diff --git a/arch/x86/include/asm/special_insns.h b/arch/x86/include/asm/special_insns.h
-index 6d37b8fcfc77..1b9b2e79c353 100644
+index eb8e781c4353..46e06bd1d0be 100644
 --- a/arch/x86/include/asm/special_insns.h
 +++ b/arch/x86/include/asm/special_insns.h
-@@ -222,6 +222,38 @@ static inline void clwb(volatile void *__p)
+@@ -232,6 +232,38 @@ static inline void clwb(volatile void *__p)
  		: [pax] "a" (p));
  }
  
@@ -202,7 +202,7 @@ index 844d60eb1882..cf2d55db3be4 100644
   * The 32-bit signal frame:
   */
 diff --git a/arch/x86/kernel/cet.c b/arch/x86/kernel/cet.c
-index d8196c8e792a..e95bd2b3c394 100644
+index f261eabdf66b..7e8dc7ffd5a9 100644
 --- a/arch/x86/kernel/cet.c
 +++ b/arch/x86/kernel/cet.c
 @@ -19,6 +19,8 @@
@@ -214,7 +214,7 @@ index d8196c8e792a..e95bd2b3c394 100644
  
  static void start_update_msrs(void)
  {
-@@ -69,6 +71,80 @@ static unsigned long alloc_shstk(unsigned long size)
+@@ -72,6 +74,80 @@ static unsigned long alloc_shstk(unsigned long addr, unsigned long size, int fla
  	return addr;
  }
  
@@ -295,7 +295,7 @@ index d8196c8e792a..e95bd2b3c394 100644
  int cet_setup_shstk(void)
  {
  	unsigned long addr, size;
-@@ -133,3 +209,81 @@ void cet_disable_free_shstk(struct task_struct *tsk)
+@@ -136,3 +212,81 @@ void cet_disable_free_shstk(struct task_struct *tsk)
  	cet->shstk_base = 0;
  	cet->shstk_size = 0;
  }
@@ -324,7 +324,7 @@ index d8196c8e792a..e95bd2b3c394 100644
 +		else
 +			wrmsrl(MSR_IA32_PL3_SSP, sc_ext->ssp);
 +
-+		msr_val |= MSR_IA32_CET_SHSTK_EN;
++		msr_val |= CET_SHSTK_EN;
 +	}
 +
 +	if (test_thread_flag(TIF_NEED_FPU_LOAD))
@@ -378,7 +378,7 @@ index d8196c8e792a..e95bd2b3c394 100644
 +	return 0;
 +}
 diff --git a/arch/x86/kernel/fpu/signal.c b/arch/x86/kernel/fpu/signal.c
-index 003735eec674..163a17772ca0 100644
+index 9393a445d73c..c58b9ba0e29b 100644
 --- a/arch/x86/kernel/fpu/signal.c
 +++ b/arch/x86/kernel/fpu/signal.c
 @@ -52,6 +52,74 @@ static inline int check_for_xstate(struct fxregs_state __user *buf,
@@ -530,10 +530,10 @@ index 003735eec674..163a17772ca0 100644
  	if (ia32_frame && use_fxsr()) {
  		frame_size += sizeof(struct fregs_state);
 diff --git a/arch/x86/kernel/signal.c b/arch/x86/kernel/signal.c
-index 0052bbe5dfd4..5ee1b2e51de3 100644
+index 399f97abee02..29dcdd82c2b9 100644
 --- a/arch/x86/kernel/signal.c
 +++ b/arch/x86/kernel/signal.c
-@@ -44,6 +44,7 @@
+@@ -45,6 +45,7 @@
  #include <asm/syscall.h>
  #include <asm/sigframe.h>
  #include <asm/signal.h>
@@ -541,7 +541,7 @@ index 0052bbe5dfd4..5ee1b2e51de3 100644
  
  #ifdef CONFIG_X86_64
  /*
-@@ -237,6 +238,9 @@ get_sigframe(struct k_sigaction *ka, struct pt_regs *regs, size_t frame_size,
+@@ -238,6 +239,9 @@ get_sigframe(struct k_sigaction *ka, struct pt_regs *regs, size_t frame_size,
  	unsigned long buf_fx = 0;
  	int onsigstack = on_sig_stack(sp);
  	int ret;
@@ -551,7 +551,7 @@ index 0052bbe5dfd4..5ee1b2e51de3 100644
  
  	/* redzone */
  	if (IS_ENABLED(CONFIG_X86_64))
-@@ -268,6 +272,12 @@ get_sigframe(struct k_sigaction *ka, struct pt_regs *regs, size_t frame_size,
+@@ -269,6 +273,12 @@ get_sigframe(struct k_sigaction *ka, struct pt_regs *regs, size_t frame_size,
  	if (onsigstack && !likely(on_sig_stack(sp)))
  		return (void __user *)-1L;
  
diff --git a/0021-binfmt_elf-Define-GNU_PROPERTY_X86_FEATURE_1_AND-pro.patch b/0021-binfmt_elf-Define-GNU_PROPERTY_X86_FEATURE_1_AND-pro.patch
new file mode 100644
index 000000000..a390a09b1
--- /dev/null
+++ b/0021-binfmt_elf-Define-GNU_PROPERTY_X86_FEATURE_1_AND-pro.patch
@@ -0,0 +1,36 @@
+From 62a008aeec046b28c0ac66d3ef3e21e8ea471135 Mon Sep 17 00:00:00 2001
+From: Yu-cheng Yu <yu-cheng.yu@intel.com>
+Date: Fri, 18 Oct 2019 18:25:34 +0100
+Subject: [PATCH 21/40] binfmt_elf: Define GNU_PROPERTY_X86_FEATURE_1_AND
+ properties
+
+An ELF file's .note.gnu.property indicates architecture features of the
+file.. Introduce feature definitions for Shadow Stack and Indirect Branch
+Tracking.
+
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
+---
+ include/uapi/linux/elf.h | 9 +++++++++
+ 1 file changed, 9 insertions(+)
+
+diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
+index c6dd0215482e..e294a5ac98aa 100644
+--- a/include/uapi/linux/elf.h
++++ b/include/uapi/linux/elf.h
+@@ -454,4 +454,13 @@ typedef struct elf64_note {
+ /* Bits for GNU_PROPERTY_AARCH64_FEATURE_1_BTI */
+ #define GNU_PROPERTY_AARCH64_FEATURE_1_BTI	(1U << 0)
+ 
++/* .note.gnu.property types for x86: */
++#define GNU_PROPERTY_X86_FEATURE_1_AND		0xc0000002
++
++/* Bits for GNU_PROPERTY_X86_FEATURE_1_AND */
++#define GNU_PROPERTY_X86_FEATURE_1_IBT		0x00000001
++#define GNU_PROPERTY_X86_FEATURE_1_SHSTK	0x00000002
++#define GNU_PROPERTY_X86_FEATURE_1_INVAL ~(GNU_PROPERTY_X86_FEATURE_1_IBT | \
++					    GNU_PROPERTY_X86_FEATURE_1_SHSTK)
++
+ #endif /* _UAPI_LINUX_ELF_H */
+-- 
+2.26.2
+
diff --git a/0033-ELF-Introduce-arch_setup_elf_property.patch b/0022-ELF-Introduce-arch_setup_elf_property.patch
similarity index 65%
rename from 0033-ELF-Introduce-arch_setup_elf_property.patch
rename to 0022-ELF-Introduce-arch_setup_elf_property.patch
index 71fbd5d43..9ee2a6283 100644
--- a/0033-ELF-Introduce-arch_setup_elf_property.patch
+++ b/0022-ELF-Introduce-arch_setup_elf_property.patch
@@ -1,12 +1,13 @@
-From d5fa1383166189cf11d9e08e8c6ac690416f7d2c Mon Sep 17 00:00:00 2001
+From b6134942aba035bffa76e21da50952900455fad4 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 20 Aug 2019 13:20:37 -0700
-Subject: [PATCH 33/47] ELF: Introduce arch_setup_elf_property()
+Subject: [PATCH 22/40] ELF: Introduce arch_setup_elf_property()
 
 An ELF file's .note.gnu.property indicates architecture features of the
-file.  These features are extracted earlier and stored in the struct
-'arch_elf_state'.  Introduce arch_setup_elf_property() to setup and enable
-these features.  The first use-case of this function is shadow stack.
+file.  These features are extracted by parse_elf_property() and stored in
+the struct 'arch_elf_state'.  Introduce arch_setup_elf_property() to setup
+and enable these features.  The first use-case of this function is shadow
+stack.
 
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 ---
@@ -15,10 +16,10 @@ Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
  2 files changed, 10 insertions(+)
 
 diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c
-index 9eebecfcd331..91ae3e71e2d5 100644
+index 9fe3b51c116a..e9b43b65e619 100644
 --- a/fs/binfmt_elf.c
 +++ b/fs/binfmt_elf.c
-@@ -1216,6 +1216,10 @@ static int load_elf_binary(struct linux_binprm *bprm)
+@@ -1217,6 +1217,10 @@ static int load_elf_binary(struct linux_binprm *bprm)
  
  	set_binfmt(&elf_format);
  
@@ -30,10 +31,10 @@ index 9eebecfcd331..91ae3e71e2d5 100644
  	retval = arch_setup_additional_pages(bprm, !!interpreter);
  	if (retval < 0)
 diff --git a/include/linux/elf.h b/include/linux/elf.h
-index 7bdc6da160c7..81f2161fa4a8 100644
+index 5d5b0321da0b..4827695ca415 100644
 --- a/include/linux/elf.h
 +++ b/include/linux/elf.h
-@@ -78,9 +78,15 @@ static inline int arch_parse_elf_property(u32 type, const void *data,
+@@ -82,9 +82,15 @@ static inline int arch_parse_elf_property(u32 type, const void *data,
  {
  	return 0;
  }
@@ -48,7 +49,7 @@ index 7bdc6da160c7..81f2161fa4a8 100644
 +extern int arch_setup_elf_property(struct arch_elf_state *arch);
  #endif
  
- #endif /* _LINUX_ELF_H */
+ #ifdef CONFIG_ARCH_HAVE_ELF_PROT
 -- 
 2.26.2
 
diff --git a/0034-x86-cet-shstk-ELF-header-parsing-for-shadow-stack.patch b/0023-x86-cet-shstk-ELF-header-parsing-for-shadow-stack.patch
similarity index 84%
rename from 0034-x86-cet-shstk-ELF-header-parsing-for-shadow-stack.patch
rename to 0023-x86-cet-shstk-ELF-header-parsing-for-shadow-stack.patch
index b03950227..a1c29b1aa 100644
--- a/0034-x86-cet-shstk-ELF-header-parsing-for-shadow-stack.patch
+++ b/0023-x86-cet-shstk-ELF-header-parsing-for-shadow-stack.patch
@@ -1,7 +1,7 @@
-From 8c795861545891784657a459783adb1785028f7f Mon Sep 17 00:00:00 2001
+From f0e047792806dbb8153d643e5e0541a810817424 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 3 Oct 2017 16:07:12 -0700
-Subject: [PATCH 34/47] x86/cet/shstk: ELF header parsing for shadow stack
+Subject: [PATCH 23/40] x86/cet/shstk: ELF header parsing for shadow stack
 
 Check an ELF file's .note.gnu.property, and setup shadow stack if the
 application supports it.
@@ -17,10 +17,10 @@ v9:
  3 files changed, 47 insertions(+)
 
 diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
-index df24c4a90ea0..b1d7a2a37e3b 100644
+index 7c0493c41420..93dd52a8eecc 100644
 --- a/arch/x86/Kconfig
 +++ b/arch/x86/Kconfig
-@@ -1971,6 +1971,8 @@ config X86_INTEL_SHADOW_STACK_USER
+@@ -1949,6 +1949,8 @@ config X86_INTEL_SHADOW_STACK_USER
  	select X86_INTEL_CET
  	select ARCH_MAYBE_MKWRITE
  	select ARCH_HAS_SHADOW_STACK
@@ -30,10 +30,10 @@ index df24c4a90ea0..b1d7a2a37e3b 100644
  	  Shadow Stacks provides protection against program stack
  	  corruption.  It's a hardware feature.  This only matters
 diff --git a/arch/x86/include/asm/elf.h b/arch/x86/include/asm/elf.h
-index 69c0f892e310..fac79b621e0a 100644
+index 452beed7892b..14ce5dc116c8 100644
 --- a/arch/x86/include/asm/elf.h
 +++ b/arch/x86/include/asm/elf.h
-@@ -367,6 +367,19 @@ extern int compat_arch_setup_additional_pages(struct linux_binprm *bprm,
+@@ -387,6 +387,19 @@ extern int compat_arch_setup_additional_pages(struct linux_binprm *bprm,
  					      int uses_interp);
  #define compat_arch_setup_additional_pages compat_arch_setup_additional_pages
  
@@ -54,10 +54,10 @@ index 69c0f892e310..fac79b621e0a 100644
  enum align_flags {
  	ALIGN_VA_32	= BIT(0),
 diff --git a/arch/x86/kernel/process_64.c b/arch/x86/kernel/process_64.c
-index 5ef9d8f25b0e..0c0475887d5c 100644
+index 9a97415b2139..d7f85e8a3223 100644
 --- a/arch/x86/kernel/process_64.c
 +++ b/arch/x86/kernel/process_64.c
-@@ -730,3 +730,35 @@ unsigned long KSTK_ESP(struct task_struct *task)
+@@ -729,3 +729,35 @@ unsigned long KSTK_ESP(struct task_struct *task)
  {
  	return task_pt_regs(task)->sp;
  }
diff --git a/0035-x86-cet-shstk-Handle-thread-shadow-stack.patch b/0024-x86-cet-shstk-Handle-thread-shadow-stack.patch
similarity index 91%
rename from 0035-x86-cet-shstk-Handle-thread-shadow-stack.patch
rename to 0024-x86-cet-shstk-Handle-thread-shadow-stack.patch
index ff1a7c0b2..3f8141a11 100644
--- a/0035-x86-cet-shstk-Handle-thread-shadow-stack.patch
+++ b/0024-x86-cet-shstk-Handle-thread-shadow-stack.patch
@@ -1,7 +1,7 @@
-From 099768f8bcc8bca0d73b98119882f54c9da3984c Mon Sep 17 00:00:00 2001
+From 398576718bd7efb62119c035bad85bf2e047a566 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Thu, 3 May 2018 12:40:57 -0700
-Subject: [PATCH 35/47] x86/cet/shstk: Handle thread shadow stack
+Subject: [PATCH 24/40] x86/cet/shstk: Handle thread shadow stack
 
 The kernel allocates (and frees on thread exit) a new shadow stack for a
 pthread child.
@@ -47,7 +47,7 @@ index 56fe08eebae6..71dc92acd2f2 100644
  static inline void cet_restore_signal(struct sc_ext *sc) { return; }
  static inline int cet_setup_signal(bool ia32, unsigned long rstor,
 diff --git a/arch/x86/include/asm/mmu_context.h b/arch/x86/include/asm/mmu_context.h
-index 4e55370e48e8..bb7a4a2d6923 100644
+index 47562147e70b..dbbbab947a0d 100644
 --- a/arch/x86/include/asm/mmu_context.h
 +++ b/arch/x86/include/asm/mmu_context.h
 @@ -12,6 +12,7 @@
@@ -58,7 +58,7 @@ index 4e55370e48e8..bb7a4a2d6923 100644
  #include <asm/debugreg.h>
  
  extern atomic64_t last_mm_ctx_id;
-@@ -155,6 +156,8 @@ do {						\
+@@ -143,6 +144,8 @@ do {						\
  #else
  #define deactivate_mm(tsk, mm)			\
  do {						\
@@ -68,10 +68,10 @@ index 4e55370e48e8..bb7a4a2d6923 100644
  	loadsegment(fs, 0);			\
  } while (0)
 diff --git a/arch/x86/kernel/cet.c b/arch/x86/kernel/cet.c
-index e95bd2b3c394..736652b9b73f 100644
+index 7e8dc7ffd5a9..268a0be04464 100644
 --- a/arch/x86/kernel/cet.c
 +++ b/arch/x86/kernel/cet.c
-@@ -169,6 +169,47 @@ int cet_setup_shstk(void)
+@@ -172,6 +172,47 @@ int cet_setup_shstk(void)
  	return 0;
  }
  
@@ -101,9 +101,9 @@ index e95bd2b3c394..736652b9b73f 100644
 +	if (in_compat_syscall())
 +		size /= 4;
 +	size = round_up(size, PAGE_SIZE);
-+	addr = alloc_shstk(size);
++	addr = alloc_shstk(0, size, 0);
 +
-+	if (IS_ERR((void *)addr)) {
++	if (IS_ERR_VALUE(addr)) {
 +		cet->shstk_base = 0;
 +		cet->shstk_size = 0;
 +		return PTR_ERR((void *)addr);
@@ -120,7 +120,7 @@ index e95bd2b3c394..736652b9b73f 100644
  {
  	struct cet_status *cet = &tsk->thread.cet;
 diff --git a/arch/x86/kernel/process.c b/arch/x86/kernel/process.c
-index 56587051df5a..aa896833f074 100644
+index 9b2c84cbf805..abc27ed0f502 100644
 --- a/arch/x86/kernel/process.c
 +++ b/arch/x86/kernel/process.c
 @@ -109,6 +109,7 @@ void exit_thread(struct task_struct *tsk)
diff --git a/0036-x86-cet-shstk-Add-arch_prctl-functions-for-shadow-st.patch b/0025-x86-cet-shstk-Add-arch_prctl-functions-for-shadow-st.patch
similarity index 71%
rename from 0036-x86-cet-shstk-Add-arch_prctl-functions-for-shadow-st.patch
rename to 0025-x86-cet-shstk-Add-arch_prctl-functions-for-shadow-st.patch
index 15d289219..f1756c0ea 100644
--- a/0036-x86-cet-shstk-Add-arch_prctl-functions-for-shadow-st.patch
+++ b/0025-x86-cet-shstk-Add-arch_prctl-functions-for-shadow-st.patch
@@ -1,7 +1,7 @@
-From e87c40b026539d4a8774044e3c463940c759fd6c Mon Sep 17 00:00:00 2001
+From 6a70fbacde94a04c70cdda450d303142504b5557 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Thu, 3 May 2018 13:04:29 -0700
-Subject: [PATCH 36/47] x86/cet/shstk: Add arch_prctl functions for shadow
+Subject: [PATCH 25/40] x86/cet/shstk: Add arch_prctl functions for shadow
  stack
 
 arch_prctl(ARCH_X86_CET_STATUS, u64 *args)
@@ -28,6 +28,15 @@ arch_prctl(ARCH_X86_CET_ALLOC_SHSTK, u64 *args)
     desired size to allocate.  The kernel returns the allocated shadow
     stack address in *args.
 
+arch_prctl(ARCH_X86_CET_MMAP_SHSTK, u64 *args)
+    Allocate a new shadow stack.
+
+    The parameter 'args' is a pointer to a user buffer.
+
+    *args = allocated shadow stack address
+    *(args + 1) = desired size
+    *(args + 2) = MAP_32BIT or MAP_POPULATE
+
 Also change do_arch_prctl_common()'s parameter 'cpuid_enabled' to
 'arg2', as it is now also passed to prctl_cet().
 
@@ -36,24 +45,25 @@ Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 v11:
 - Check input for invalid features.
 - Fix prctl_cet() return values.
+- Introduce ARCH_X86_CET_MMAP_SHSTK.
 
 v10:
 - Verify CET is enabled before handling arch_prctl.
 - Change input parameters from unsigned long to u64, to make it clear they
   are 64-bit.
 ---
- arch/x86/include/asm/cet.h              |  4 ++
- arch/x86/include/uapi/asm/prctl.h       |  5 ++
- arch/x86/kernel/Makefile                |  2 +-
- arch/x86/kernel/cet.c                   | 29 ++++++++
- arch/x86/kernel/cet_prctl.c             | 91 +++++++++++++++++++++++++
- arch/x86/kernel/process.c               |  6 +-
- tools/arch/x86/include/uapi/asm/prctl.h |  5 ++
- 7 files changed, 138 insertions(+), 4 deletions(-)
+ arch/x86/include/asm/cet.h              |   4 +
+ arch/x86/include/uapi/asm/prctl.h       |   6 ++
+ arch/x86/kernel/Makefile                |   2 +-
+ arch/x86/kernel/cet.c                   |  26 +++++
+ arch/x86/kernel/cet_prctl.c             | 124 ++++++++++++++++++++++++
+ arch/x86/kernel/process.c               |   6 +-
+ tools/arch/x86/include/uapi/asm/prctl.h |   6 ++
+ 7 files changed, 170 insertions(+), 4 deletions(-)
  create mode 100644 arch/x86/kernel/cet_prctl.c
 
 diff --git a/arch/x86/include/asm/cet.h b/arch/x86/include/asm/cet.h
-index 71dc92acd2f2..99e6e741d28c 100644
+index 71dc92acd2f2..07d2ed6378f7 100644
 --- a/arch/x86/include/asm/cet.h
 +++ b/arch/x86/include/asm/cet.h
 @@ -14,16 +14,20 @@ struct sc_ext;
@@ -67,7 +77,7 @@ index 71dc92acd2f2..99e6e741d28c 100644
 +int prctl_cet(int option, u64 arg2);
  int cet_setup_shstk(void);
  int cet_setup_thread_shstk(struct task_struct *p);
-+int cet_alloc_shstk(unsigned long *arg);
++unsigned long cet_alloc_shstk(unsigned long addr, unsigned long size, int flags);
  void cet_disable_free_shstk(struct task_struct *p);
  int cet_verify_rstor_token(bool ia32, unsigned long ssp, unsigned long *new_ssp);
  void cet_restore_signal(struct sc_ext *sc);
@@ -78,10 +88,10 @@ index 71dc92acd2f2..99e6e741d28c 100644
  static inline void cet_disable_free_shstk(struct task_struct *p) {}
  static inline void cet_restore_signal(struct sc_ext *sc) { return; }
 diff --git a/arch/x86/include/uapi/asm/prctl.h b/arch/x86/include/uapi/asm/prctl.h
-index 5a6aac9fa41f..d962f0ec9ccf 100644
+index 5a6aac9fa41f..ae4761566f4b 100644
 --- a/arch/x86/include/uapi/asm/prctl.h
 +++ b/arch/x86/include/uapi/asm/prctl.h
-@@ -14,4 +14,9 @@
+@@ -14,4 +14,10 @@
  #define ARCH_MAP_VDSO_32	0x2002
  #define ARCH_MAP_VDSO_64	0x2003
  
@@ -89,13 +99,14 @@ index 5a6aac9fa41f..d962f0ec9ccf 100644
 +#define ARCH_X86_CET_DISABLE		0x3002
 +#define ARCH_X86_CET_LOCK		0x3003
 +#define ARCH_X86_CET_ALLOC_SHSTK	0x3004
++#define ARCH_X86_CET_MMAP_SHSTK		0x3005
 +
  #endif /* _ASM_X86_PRCTL_H */
 diff --git a/arch/x86/kernel/Makefile b/arch/x86/kernel/Makefile
-index e9cc2551573b..0b621e2afbdc 100644
+index 76f27f518266..97556e4204d6 100644
 --- a/arch/x86/kernel/Makefile
 +++ b/arch/x86/kernel/Makefile
-@@ -144,7 +144,7 @@ obj-$(CONFIG_UNWINDER_ORC)		+= unwind_orc.o
+@@ -145,7 +145,7 @@ obj-$(CONFIG_UNWINDER_ORC)		+= unwind_orc.o
  obj-$(CONFIG_UNWINDER_FRAME_POINTER)	+= unwind_frame.o
  obj-$(CONFIG_UNWINDER_GUESS)		+= unwind_guess.o
  
@@ -105,24 +116,22 @@ index e9cc2551573b..0b621e2afbdc 100644
  ###
  # 64 bit specific files
 diff --git a/arch/x86/kernel/cet.c b/arch/x86/kernel/cet.c
-index 736652b9b73f..b994f0a1e78e 100644
+index 268a0be04464..c6d8a5c9d4b2 100644
 --- a/arch/x86/kernel/cet.c
 +++ b/arch/x86/kernel/cet.c
-@@ -145,6 +145,35 @@ static int create_rstor_token(bool ia32, unsigned long ssp,
+@@ -148,6 +148,32 @@ static int create_rstor_token(bool ia32, unsigned long ssp,
  	return 0;
  }
  
-+int cet_alloc_shstk(unsigned long *arg)
++unsigned long cet_alloc_shstk(unsigned long addr, unsigned long len, int flags)
 +{
-+	unsigned long len = *arg;
-+	unsigned long addr;
 +	unsigned long token;
 +	unsigned long ssp;
 +
-+	addr = alloc_shstk(round_up(len, PAGE_SIZE));
++	addr = alloc_shstk(addr, round_up(len, PAGE_SIZE), flags);
 +
-+	if (IS_ERR((void *)addr))
-+		return PTR_ERR((void *)addr);
++	if (IS_ERR_VALUE(addr))
++		return addr;
 +
 +	/* Restore token is 8 bytes and aligned to 8 bytes */
 +	ssp = addr + len;
@@ -137,8 +146,7 @@ index 736652b9b73f..b994f0a1e78e 100644
 +		return -EINVAL;
 +	}
 +
-+	*arg = addr;
-+	return 0;
++	return addr;
 +}
 +
  int cet_setup_shstk(void)
@@ -146,10 +154,10 @@ index 736652b9b73f..b994f0a1e78e 100644
  	unsigned long addr, size;
 diff --git a/arch/x86/kernel/cet_prctl.c b/arch/x86/kernel/cet_prctl.c
 new file mode 100644
-index 000000000000..844ff7f6d129
+index 000000000000..5a8939d48ff2
 --- /dev/null
 +++ b/arch/x86/kernel/cet_prctl.c
-@@ -0,0 +1,91 @@
+@@ -0,0 +1,124 @@
 +/* SPDX-License-Identifier: GPL-2.0 */
 +
 +#include <linux/errno.h>
@@ -179,20 +187,15 @@ index 000000000000..844ff7f6d129
 +
 +static int handle_alloc_shstk(u64 arg2)
 +{
-+	int err = 0;
-+	unsigned long arg;
-+	unsigned long addr = 0;
-+	unsigned long size = 0;
++	unsigned long addr, size;
 +
-+	if (get_user(arg, (unsigned long __user *)arg2))
++	if (get_user(size, (unsigned long __user *)arg2))
 +		return -EFAULT;
 +
-+	size = arg;
-+	err = cet_alloc_shstk(&arg);
-+	if (err)
-+		return err;
++	addr = cet_alloc_shstk(0, size, 0);
++	if (IS_ERR_VALUE(addr))
++		return PTR_ERR((void *)addr);
 +
-+	addr = arg;
 +	if (put_user((u64)addr, (u64 __user *)arg2)) {
 +		vm_munmap(addr, size);
 +		return -EFAULT;
@@ -201,6 +204,41 @@ index 000000000000..844ff7f6d129
 +	return 0;
 +}
 +
++static int handle_mmap_shstk(u64 arg2)
++{
++	u64 buf[3];
++	unsigned long addr, size;
++	int allowed_flags;
++
++	if (copy_from_user(buf, (unsigned long __user *)arg2, sizeof(buf)))
++		return -EFAULT;
++
++	addr = buf[0];
++	size = buf[1];
++
++	/*
++	 * Check invalid flags
++	 */
++	allowed_flags = MAP_ANONYMOUS | MAP_PRIVATE | MAP_32BIT | MAP_POPULATE;
++
++	if (buf[2] & ~allowed_flags)
++		return -EINVAL;
++
++	if (!addr && (buf[2] & MAP_FIXED))
++		return -EINVAL;
++
++	addr = cet_alloc_shstk(addr, size, buf[2]);
++	if (IS_ERR_VALUE(addr))
++		return PTR_ERR((void *)addr);
++
++	if (put_user(addr, (u64 __user *)arg2)) {
++		vm_munmap(addr, size);
++		return -EFAULT;
++	}
++
++	return 0;
++}
++
 +int prctl_cet(int option, u64 arg2)
 +{
 +	struct cet_status *cet;
@@ -237,15 +275,18 @@ index 000000000000..844ff7f6d129
 +	case ARCH_X86_CET_ALLOC_SHSTK:
 +		return handle_alloc_shstk(arg2);
 +
++	case ARCH_X86_CET_MMAP_SHSTK:
++		return handle_mmap_shstk(arg2);
++
 +	default:
 +		return -ENOSYS;
 +	}
 +}
 diff --git a/arch/x86/kernel/process.c b/arch/x86/kernel/process.c
-index aa896833f074..c50ace4e6c52 100644
+index abc27ed0f502..426557c89b21 100644
 --- a/arch/x86/kernel/process.c
 +++ b/arch/x86/kernel/process.c
-@@ -989,14 +989,14 @@ unsigned long get_wchan(struct task_struct *p)
+@@ -978,14 +978,14 @@ unsigned long get_wchan(struct task_struct *p)
  }
  
  long do_arch_prctl_common(struct task_struct *task, int option,
@@ -264,10 +305,10 @@ index aa896833f074..c50ace4e6c52 100644
 +	return prctl_cet(option, arg2);
  }
 diff --git a/tools/arch/x86/include/uapi/asm/prctl.h b/tools/arch/x86/include/uapi/asm/prctl.h
-index 5a6aac9fa41f..d962f0ec9ccf 100644
+index 5a6aac9fa41f..ae4761566f4b 100644
 --- a/tools/arch/x86/include/uapi/asm/prctl.h
 +++ b/tools/arch/x86/include/uapi/asm/prctl.h
-@@ -14,4 +14,9 @@
+@@ -14,4 +14,10 @@
  #define ARCH_MAP_VDSO_32	0x2002
  #define ARCH_MAP_VDSO_64	0x2003
  
@@ -275,6 +316,7 @@ index 5a6aac9fa41f..d962f0ec9ccf 100644
 +#define ARCH_X86_CET_DISABLE		0x3002
 +#define ARCH_X86_CET_LOCK		0x3003
 +#define ARCH_X86_CET_ALLOC_SHSTK	0x3004
++#define ARCH_X86_CET_MMAP_SHSTK		0x3005
 +
  #endif /* _ASM_X86_PRCTL_H */
 -- 
diff --git a/0037-x86-cet-ibt-Add-Kconfig-option-for-user-mode-Indirec.patch b/0026-x86-cet-ibt-Add-Kconfig-option-for-user-mode-Indirec.patch
similarity index 86%
rename from 0037-x86-cet-ibt-Add-Kconfig-option-for-user-mode-Indirec.patch
rename to 0026-x86-cet-ibt-Add-Kconfig-option-for-user-mode-Indirec.patch
index 6469be780..d49217792 100644
--- a/0037-x86-cet-ibt-Add-Kconfig-option-for-user-mode-Indirec.patch
+++ b/0026-x86-cet-ibt-Add-Kconfig-option-for-user-mode-Indirec.patch
@@ -1,7 +1,7 @@
-From 5c3f3ca62796d7360a3fc4abf29119b40d72267e Mon Sep 17 00:00:00 2001
+From 851cf03480300f2b11196187ee7117844b8a7ed4 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Wed, 4 Oct 2017 12:35:32 -0700
-Subject: [PATCH 37/47] x86/cet/ibt: Add Kconfig option for user-mode Indirect
+Subject: [PATCH 26/40] x86/cet/ibt: Add Kconfig option for user-mode Indirect
  Branch Tracking
 
 Introduce Kconfig option X86_INTEL_BRANCH_TRACKING_USER.
@@ -21,10 +21,10 @@ v10:
  1 file changed, 16 insertions(+)
 
 diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
-index b1d7a2a37e3b..8670b1d5e34f 100644
+index 93dd52a8eecc..1ea6015a26d1 100644
 --- a/arch/x86/Kconfig
 +++ b/arch/x86/Kconfig
-@@ -1984,6 +1984,22 @@ config X86_INTEL_SHADOW_STACK_USER
+@@ -1962,6 +1962,22 @@ config X86_INTEL_SHADOW_STACK_USER
  
  	  If unsure, say y.
  
diff --git a/0038-x86-cet-ibt-User-mode-Indirect-Branch-Tracking-suppo.patch b/0027-x86-cet-ibt-User-mode-Indirect-Branch-Tracking-suppo.patch
similarity index 92%
rename from 0038-x86-cet-ibt-User-mode-Indirect-Branch-Tracking-suppo.patch
rename to 0027-x86-cet-ibt-User-mode-Indirect-Branch-Tracking-suppo.patch
index 179d71d71..7bf4d29e4 100644
--- a/0038-x86-cet-ibt-User-mode-Indirect-Branch-Tracking-suppo.patch
+++ b/0027-x86-cet-ibt-User-mode-Indirect-Branch-Tracking-suppo.patch
@@ -1,7 +1,7 @@
-From 58eae73614da310ee02f46ee5aa1434a89c5e273 Mon Sep 17 00:00:00 2001
+From eabf563fdd784f185b027d45e0d68e72c4f79d85 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Thu, 3 May 2018 13:30:56 -0700
-Subject: [PATCH 38/47] x86/cet/ibt: User-mode Indirect Branch Tracking support
+Subject: [PATCH 27/40] x86/cet/ibt: User-mode Indirect Branch Tracking support
 
 Introduce user-mode Indirect Branch Tracking (IBT) support.  Update setup
 routines to include IBT.
@@ -25,7 +25,7 @@ v2:
  5 files changed, 67 insertions(+), 2 deletions(-)
 
 diff --git a/arch/x86/include/asm/cet.h b/arch/x86/include/asm/cet.h
-index 99e6e741d28c..f163c805a559 100644
+index 07d2ed6378f7..96372eda0c63 100644
 --- a/arch/x86/include/asm/cet.h
 +++ b/arch/x86/include/asm/cet.h
 @@ -15,6 +15,7 @@ struct cet_status {
@@ -72,7 +72,7 @@ index a0e1b24cfa02..52c9c07cfacc 100644
  
  #endif /* _ASM_X86_DISABLED_FEATURES_H */
 diff --git a/arch/x86/kernel/cet.c b/arch/x86/kernel/cet.c
-index b994f0a1e78e..fe4ff3590331 100644
+index c6d8a5c9d4b2..fde7972a245c 100644
 --- a/arch/x86/kernel/cet.c
 +++ b/arch/x86/kernel/cet.c
 @@ -13,6 +13,8 @@
@@ -98,7 +98,7 @@ index b994f0a1e78e..fe4ff3590331 100644
 +
 +	start_update_msrs();
 +	rdmsrl(MSR_IA32_U_CET, msr_val);
-+	msr_val |= (MSR_IA32_CET_ENDBR_EN | MSR_IA32_CET_NO_TRACK_EN);
++	msr_val |= (CET_ENDBR_EN | CET_NO_TRACK_EN);
 +	wrmsrl(MSR_IA32_U_CET, msr_val);
 +	end_update_msrs();
 +	current->thread.cet.ibt_enabled = 1;
@@ -114,16 +114,16 @@ index b994f0a1e78e..fe4ff3590331 100644
 +
 +	start_update_msrs();
 +	rdmsrl(MSR_IA32_U_CET, msr_val);
-+	msr_val &= MSR_IA32_CET_SHSTK_EN;
++	msr_val &= CET_SHSTK_EN;
 +	wrmsrl(MSR_IA32_U_CET, msr_val);
 +	end_update_msrs();
 +	current->thread.cet.ibt_enabled = 0;
 +}
 diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c
-index 1563b472e0f9..896a07675eee 100644
+index 44d51d8008cc..dd36f1ad8950 100644
 --- a/arch/x86/kernel/cpu/common.c
 +++ b/arch/x86/kernel/cpu/common.c
-@@ -496,6 +496,23 @@ static __init int setup_disable_shstk(char *s)
+@@ -519,6 +519,23 @@ static __init int setup_disable_shstk(char *s)
  __setup("no_user_shstk", setup_disable_shstk);
  #endif
  
diff --git a/0039-x86-cet-ibt-Handle-signals-for-Indirect-Branch-Track.patch b/0028-x86-cet-ibt-Handle-signals-for-Indirect-Branch-Track.patch
similarity index 85%
rename from 0039-x86-cet-ibt-Handle-signals-for-Indirect-Branch-Track.patch
rename to 0028-x86-cet-ibt-Handle-signals-for-Indirect-Branch-Track.patch
index 0a4d73519..88775bced 100644
--- a/0039-x86-cet-ibt-Handle-signals-for-Indirect-Branch-Track.patch
+++ b/0028-x86-cet-ibt-Handle-signals-for-Indirect-Branch-Track.patch
@@ -1,7 +1,7 @@
-From 06687de015e319f7ad4c32f431cab3c4c6592569 Mon Sep 17 00:00:00 2001
+From 4afaeac2dea969397aac4c672fb8f229a235f77c Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 28 May 2019 12:29:14 -0700
-Subject: [PATCH 39/47] x86/cet/ibt: Handle signals for Indirect Branch
+Subject: [PATCH 28/40] x86/cet/ibt: Handle signals for Indirect Branch
  Tracking
 
 Indirect Branch Tracking setting does not change in signal delivering or
@@ -22,18 +22,18 @@ v9:
  2 files changed, 30 insertions(+), 5 deletions(-)
 
 diff --git a/arch/x86/kernel/cet.c b/arch/x86/kernel/cet.c
-index fe4ff3590331..b1d592699964 100644
+index fde7972a245c..73e156c6f65f 100644
 --- a/arch/x86/kernel/cet.c
 +++ b/arch/x86/kernel/cet.c
 @@ -309,6 +309,13 @@ void cet_restore_signal(struct sc_ext *sc_ext)
- 		msr_val |= MSR_IA32_CET_SHSTK_EN;
+ 		msr_val |= CET_SHSTK_EN;
  	}
  
 +	if (cet->ibt_enabled) {
-+		msr_val |= (MSR_IA32_CET_ENDBR_EN | MSR_IA32_CET_NO_TRACK_EN);
++		msr_val |= (CET_ENDBR_EN | CET_NO_TRACK_EN);
 +
 +		if (sc_ext->wait_endbr)
-+			msr_val |= MSR_IA32_CET_WAIT_ENDBR;
++			msr_val |= CET_WAIT_ENDBR;
 +	}
 +
  	if (test_thread_flag(TIF_NEED_FPU_LOAD))
@@ -57,9 +57,9 @@ index fe4ff3590331..b1d592699964 100644
 +
 +			rdmsrl(MSR_IA32_U_CET, r);
 +
-+			if (r & MSR_IA32_CET_WAIT_ENDBR) {
++			if (r & CET_WAIT_ENDBR) {
 +				sc_ext->wait_endbr = 1;
-+				r &= ~MSR_IA32_CET_WAIT_ENDBR;
++				r &= ~CET_WAIT_ENDBR;
 +				wrmsrl(MSR_IA32_U_CET, r);
 +			}
 +		}
@@ -68,7 +68,7 @@ index fe4ff3590331..b1d592699964 100644
  	}
  
 diff --git a/arch/x86/kernel/fpu/signal.c b/arch/x86/kernel/fpu/signal.c
-index 163a17772ca0..43e4464674c2 100644
+index c58b9ba0e29b..ffd34a9f5e67 100644
 --- a/arch/x86/kernel/fpu/signal.c
 +++ b/arch/x86/kernel/fpu/signal.c
 @@ -57,7 +57,8 @@ int save_cet_to_sigframe(int ia32, void __user *fp, unsigned long restorer)
diff --git a/0040-x86-cet-ibt-ELF-header-parsing-for-Indirect-Branch-T.patch b/0029-x86-cet-ibt-ELF-header-parsing-for-Indirect-Branch-T.patch
similarity index 78%
rename from 0040-x86-cet-ibt-ELF-header-parsing-for-Indirect-Branch-T.patch
rename to 0029-x86-cet-ibt-ELF-header-parsing-for-Indirect-Branch-T.patch
index 15602260f..fdf234a9a 100644
--- a/0040-x86-cet-ibt-ELF-header-parsing-for-Indirect-Branch-T.patch
+++ b/0029-x86-cet-ibt-ELF-header-parsing-for-Indirect-Branch-T.patch
@@ -1,7 +1,7 @@
-From 777d0c94585c2f82e7f570020cc5e3df3569ea81 Mon Sep 17 00:00:00 2001
+From bfb60c5d34e201492e10bee322ae14aa9196b76a Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 30 Apr 2019 15:16:22 -0700
-Subject: [PATCH 40/47] x86/cet/ibt: ELF header parsing for Indirect Branch
+Subject: [PATCH 29/40] x86/cet/ibt: ELF header parsing for Indirect Branch
  Tracking
 
 Update arch_setup_elf_property() for Indirect Branch Tracking.
@@ -16,10 +16,10 @@ v9:
  2 files changed, 10 insertions(+)
 
 diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
-index 8670b1d5e34f..bb0e2a9feab7 100644
+index 1ea6015a26d1..dd642d6ff14b 100644
 --- a/arch/x86/Kconfig
 +++ b/arch/x86/Kconfig
-@@ -1990,6 +1990,8 @@ config X86_INTEL_BRANCH_TRACKING_USER
+@@ -1968,6 +1968,8 @@ config X86_INTEL_BRANCH_TRACKING_USER
  	depends on CPU_SUP_INTEL && X86_64
  	depends on $(cc-option,-fcf-protection)
  	select X86_INTEL_CET
@@ -29,10 +29,10 @@ index 8670b1d5e34f..bb0e2a9feab7 100644
  	  Indirect Branch Tracking (IBT) provides protection against
  	  CALL-/JMP-oriented programming attacks.  It is active when
 diff --git a/arch/x86/kernel/process_64.c b/arch/x86/kernel/process_64.c
-index 0c0475887d5c..d21c9cd90ced 100644
+index d7f85e8a3223..1cc74eaa61ba 100644
 --- a/arch/x86/kernel/process_64.c
 +++ b/arch/x86/kernel/process_64.c
-@@ -759,6 +759,14 @@ int arch_setup_elf_property(struct arch_elf_state *state)
+@@ -758,6 +758,14 @@ int arch_setup_elf_property(struct arch_elf_state *state)
  			r = cet_setup_shstk();
  	}
  
diff --git a/0041-x86-cet-ibt-Add-arch_prctl-functions-for-Indirect-Br.patch b/0030-x86-cet-ibt-Add-arch_prctl-functions-for-Indirect-Br.patch
similarity index 81%
rename from 0041-x86-cet-ibt-Add-arch_prctl-functions-for-Indirect-Br.patch
rename to 0030-x86-cet-ibt-Add-arch_prctl-functions-for-Indirect-Br.patch
index d29114eb9..eb09bc2da 100644
--- a/0041-x86-cet-ibt-Add-arch_prctl-functions-for-Indirect-Br.patch
+++ b/0030-x86-cet-ibt-Add-arch_prctl-functions-for-Indirect-Br.patch
@@ -1,7 +1,7 @@
-From 0e6450cf06c92f42840ab364588504e66c8d9f67 Mon Sep 17 00:00:00 2001
+From f6adf06dde24d968a7d9990f8c115630eb7dfa42 Mon Sep 17 00:00:00 2001
 From: "H.J. Lu" <hjl.tools@gmail.com>
 Date: Tue, 21 Aug 2018 14:13:05 -0700
-Subject: [PATCH 41/47] x86/cet/ibt: Add arch_prctl functions for Indirect
+Subject: [PATCH 30/40] x86/cet/ibt: Add arch_prctl functions for Indirect
  Branch Tracking
 
 Update ARCH_X86_CET_STATUS and ARCH_X86_CET_DISABLE for Indirect Branch
@@ -14,7 +14,7 @@ Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
  1 file changed, 7 insertions(+), 1 deletion(-)
 
 diff --git a/arch/x86/kernel/cet_prctl.c b/arch/x86/kernel/cet_prctl.c
-index 844ff7f6d129..81c8d76cac18 100644
+index 5a8939d48ff2..d4688dda3d0c 100644
 --- a/arch/x86/kernel/cet_prctl.c
 +++ b/arch/x86/kernel/cet_prctl.c
 @@ -22,6 +22,9 @@ static int copy_status_to_user(struct cet_status *cet, u64 arg2)
@@ -27,7 +27,7 @@ index 844ff7f6d129..81c8d76cac18 100644
  	return copy_to_user((u64 __user *)arg2, buf, sizeof(buf));
  }
  
-@@ -65,7 +68,8 @@ int prctl_cet(int option, u64 arg2)
+@@ -95,7 +98,8 @@ int prctl_cet(int option, u64 arg2)
  	if (option == ARCH_X86_CET_STATUS)
  		return copy_status_to_user(cet, arg2);
  
@@ -37,7 +37,7 @@ index 844ff7f6d129..81c8d76cac18 100644
  		return -EOPNOTSUPP;
  
  	switch (option) {
-@@ -76,6 +80,8 @@ int prctl_cet(int option, u64 arg2)
+@@ -106,6 +110,8 @@ int prctl_cet(int option, u64 arg2)
  			return -EINVAL;
  		if (arg2 & GNU_PROPERTY_X86_FEATURE_1_SHSTK)
  			cet_disable_free_shstk(current);
diff --git a/0031-ELF-UAPI-and-Kconfig-additions-for-ELF-program-prope.patch b/0031-ELF-UAPI-and-Kconfig-additions-for-ELF-program-prope.patch
deleted file mode 100644
index ac4f75a34..000000000
--- a/0031-ELF-UAPI-and-Kconfig-additions-for-ELF-program-prope.patch
+++ /dev/null
@@ -1,87 +0,0 @@
-From b917d33bc0bb3db931d0c6a70cb446665483a755 Mon Sep 17 00:00:00 2001
-From: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Date: Fri, 18 Oct 2019 18:25:34 +0100
-Subject: [PATCH 31/47] ELF: UAPI and Kconfig additions for ELF program
- properties
-
-Introduce basic ELF definitions relating to the NT_GNU_PROPERTY_TYPE_0
-note.
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Kees Cook <keescook@chromium.org>
-
-v10:
-- Merge GNU_PROPERTY_X86_FEATURE_1_* from a separate patch.
----
- fs/Kconfig.binfmt        |  3 +++
- include/linux/elf.h      |  8 ++++++++
- include/uapi/linux/elf.h | 10 ++++++++++
- 3 files changed, 21 insertions(+)
-
-diff --git a/fs/Kconfig.binfmt b/fs/Kconfig.binfmt
-index 62dc4f577ba1..d2cfe0729a73 100644
---- a/fs/Kconfig.binfmt
-+++ b/fs/Kconfig.binfmt
-@@ -36,6 +36,9 @@ config COMPAT_BINFMT_ELF
- config ARCH_BINFMT_ELF_STATE
- 	bool
- 
-+config ARCH_USE_GNU_PROPERTY
-+	bool
-+
- config BINFMT_ELF_FDPIC
- 	bool "Kernel support for FDPIC ELF binaries"
- 	default y if !BINFMT_ELF
-diff --git a/include/linux/elf.h b/include/linux/elf.h
-index e3649b3e970e..459cddcceaac 100644
---- a/include/linux/elf.h
-+++ b/include/linux/elf.h
-@@ -2,6 +2,7 @@
- #ifndef _LINUX_ELF_H
- #define _LINUX_ELF_H
- 
-+#include <linux/types.h>
- #include <asm/elf.h>
- #include <uapi/linux/elf.h>
- 
-@@ -56,4 +57,11 @@ static inline int elf_coredump_extra_notes_write(struct coredump_params *cprm) {
- extern int elf_coredump_extra_notes_size(void);
- extern int elf_coredump_extra_notes_write(struct coredump_params *cprm);
- #endif
-+
-+/* NT_GNU_PROPERTY_TYPE_0 header */
-+struct gnu_property {
-+	u32 pr_type;
-+	u32 pr_datasz;
-+};
-+
- #endif /* _LINUX_ELF_H */
-diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
-index 34c02e4290fe..509fd27c6f93 100644
---- a/include/uapi/linux/elf.h
-+++ b/include/uapi/linux/elf.h
-@@ -36,6 +36,7 @@ typedef __s64	Elf64_Sxword;
- #define PT_LOPROC  0x70000000
- #define PT_HIPROC  0x7fffffff
- #define PT_GNU_EH_FRAME		0x6474e550
-+#define PT_GNU_PROPERTY		0x6474e553
- 
- #define PT_GNU_STACK	(PT_LOOS + 0x474e551)
- 
-@@ -443,4 +444,13 @@ typedef struct elf64_note {
-   Elf64_Word n_type;	/* Content type */
- } Elf64_Nhdr;
- 
-+/* .note.gnu.property types */
-+#define GNU_PROPERTY_X86_FEATURE_1_AND		0xc0000002
-+
-+/* Bits of GNU_PROPERTY_X86_FEATURE_1_AND */
-+#define GNU_PROPERTY_X86_FEATURE_1_IBT		0x00000001
-+#define GNU_PROPERTY_X86_FEATURE_1_SHSTK	0x00000002
-+#define GNU_PROPERTY_X86_FEATURE_1_INVAL ~(GNU_PROPERTY_X86_FEATURE_1_IBT | \
-+					    GNU_PROPERTY_X86_FEATURE_1_SHSTK)
-+
- #endif /* _UAPI_LINUX_ELF_H */
--- 
-2.26.2
-
diff --git a/0042-x86-cet-Add-PTRACE-interface-for-CET.patch b/0031-x86-cet-Add-PTRACE-interface-for-CET.patch
similarity index 92%
rename from 0042-x86-cet-Add-PTRACE-interface-for-CET.patch
rename to 0031-x86-cet-Add-PTRACE-interface-for-CET.patch
index 48da92f7b..5cf041f4c 100644
--- a/0042-x86-cet-Add-PTRACE-interface-for-CET.patch
+++ b/0031-x86-cet-Add-PTRACE-interface-for-CET.patch
@@ -1,7 +1,7 @@
-From c45c0ee32e70d7712f021a9998d9a34b6bde9227 Mon Sep 17 00:00:00 2001
+From 474b55fd91e80f49c338affac772f439174a1c92 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Mon, 23 Apr 2018 12:55:13 -0700
-Subject: [PATCH 42/47] x86/cet: Add PTRACE interface for CET
+Subject: [PATCH 31/40] x86/cet: Add PTRACE interface for CET
 
 Add REGSET_CET64/REGSET_CET32 to get/set CET MSRs:
 
@@ -93,10 +93,10 @@ index bd1d0649f8ce..dcb86ccd2b7e 100644
  
  /*
 diff --git a/arch/x86/kernel/ptrace.c b/arch/x86/kernel/ptrace.c
-index f0e1ddbc2fd7..c362abdf6ef1 100644
+index 44130588987f..064c0fbe0ef8 100644
 --- a/arch/x86/kernel/ptrace.c
 +++ b/arch/x86/kernel/ptrace.c
-@@ -53,7 +53,9 @@ enum x86_regset {
+@@ -52,7 +52,9 @@ enum x86_regset {
  	REGSET_IOPERM64 = REGSET_XFP,
  	REGSET_XSTATE,
  	REGSET_TLS,
@@ -106,7 +106,7 @@ index f0e1ddbc2fd7..c362abdf6ef1 100644
  };
  
  struct pt_regs_offset {
-@@ -1255,6 +1257,13 @@ static struct user_regset x86_64_regsets[] __ro_after_init = {
+@@ -1254,6 +1256,13 @@ static struct user_regset x86_64_regsets[] __ro_after_init = {
  		.size = sizeof(long), .align = sizeof(long),
  		.active = ioperm_active, .get = ioperm_get
  	},
@@ -120,7 +120,7 @@ index f0e1ddbc2fd7..c362abdf6ef1 100644
  };
  
  static const struct user_regset_view user_x86_64_view = {
-@@ -1310,6 +1319,13 @@ static struct user_regset x86_32_regsets[] __ro_after_init = {
+@@ -1309,6 +1318,13 @@ static struct user_regset x86_32_regsets[] __ro_after_init = {
  		.size = sizeof(u32), .align = sizeof(u32),
  		.active = ioperm_active, .get = ioperm_get
  	},
@@ -135,7 +135,7 @@ index f0e1ddbc2fd7..c362abdf6ef1 100644
  
  static const struct user_regset_view user_x86_32_view = {
 diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
-index 49c026ce8d97..6502906ef47c 100644
+index e294a5ac98aa..641b5cff3467 100644
 --- a/include/uapi/linux/elf.h
 +++ b/include/uapi/linux/elf.h
 @@ -402,6 +402,7 @@ typedef struct elf64_shdr {
diff --git a/0032-ELF-Add-ELF-program-property-parsing-support.patch b/0032-ELF-Add-ELF-program-property-parsing-support.patch
deleted file mode 100644
index e34da1aa9..000000000
--- a/0032-ELF-Add-ELF-program-property-parsing-support.patch
+++ /dev/null
@@ -1,310 +0,0 @@
-From 4a1799148638787d64eaeb67482794034bfe2647 Mon Sep 17 00:00:00 2001
-From: Dave Martin <Dave.Martin@arm.com>
-Date: Mon, 16 Mar 2020 16:50:44 +0000
-Subject: [PATCH 32/47] ELF: Add ELF program property parsing support
-
-ELF program properties will be needed for detecting whether to
-enable optional architecture or ABI features for a new ELF process.
-
-For now, there are no generic properties that we care about, so do
-nothing unless CONFIG_ARCH_USE_GNU_PROPERTY=y.
-
-Otherwise, the presence of properties using the PT_PROGRAM_PROPERTY
-phdrs entry (if any), and notify each property to the arch code.
-
-For now, the added code is not used.
-
-Signed-off-by: Dave Martin <Dave.Martin@arm.com>
-Reviewed-by: Kees Cook <keescook@chromium.org>
-Signed-off-by: Mark Brown <broonie@kernel.org>
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
----
- fs/binfmt_elf.c          | 127 +++++++++++++++++++++++++++++++++++++++
- fs/compat_binfmt_elf.c   |   4 ++
- include/linux/elf.h      |  19 ++++++
- include/uapi/linux/elf.h |   4 ++
- 4 files changed, 154 insertions(+)
-
-diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c
-index 25d489bc9453..9eebecfcd331 100644
---- a/fs/binfmt_elf.c
-+++ b/fs/binfmt_elf.c
-@@ -40,12 +40,18 @@
- #include <linux/sched/coredump.h>
- #include <linux/sched/task_stack.h>
- #include <linux/sched/cputime.h>
-+#include <linux/sizes.h>
-+#include <linux/types.h>
- #include <linux/cred.h>
- #include <linux/dax.h>
- #include <linux/uaccess.h>
- #include <asm/param.h>
- #include <asm/page.h>
- 
-+#ifndef ELF_COMPAT
-+#define ELF_COMPAT 0
-+#endif
-+
- #ifndef user_long_t
- #define user_long_t long
- #endif
-@@ -682,6 +688,111 @@ static unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,
-  * libraries.  There is no binary dependent code anywhere else.
-  */
- 
-+static int parse_elf_property(const char *data, size_t *off, size_t datasz,
-+			      struct arch_elf_state *arch,
-+			      bool have_prev_type, u32 *prev_type)
-+{
-+	size_t o, step;
-+	const struct gnu_property *pr;
-+	int ret;
-+
-+	if (*off == datasz)
-+		return -ENOENT;
-+
-+	if (WARN_ON_ONCE(*off > datasz || *off % ELF_GNU_PROPERTY_ALIGN))
-+		return -EIO;
-+	o = *off;
-+	datasz -= *off;
-+
-+	if (datasz < sizeof(*pr))
-+		return -ENOEXEC;
-+	pr = (const struct gnu_property *)(data + o);
-+	o += sizeof(*pr);
-+	datasz -= sizeof(*pr);
-+
-+	if (pr->pr_datasz > datasz)
-+		return -ENOEXEC;
-+
-+	WARN_ON_ONCE(o % ELF_GNU_PROPERTY_ALIGN);
-+	step = round_up(pr->pr_datasz, ELF_GNU_PROPERTY_ALIGN);
-+	if (step > datasz)
-+		return -ENOEXEC;
-+
-+	/* Properties are supposed to be unique and sorted on pr_type: */
-+	if (have_prev_type && pr->pr_type <= *prev_type)
-+		return -ENOEXEC;
-+	*prev_type = pr->pr_type;
-+
-+	ret = arch_parse_elf_property(pr->pr_type, data + o,
-+				      pr->pr_datasz, ELF_COMPAT, arch);
-+	if (ret)
-+		return ret;
-+
-+	*off = o + step;
-+	return 0;
-+}
-+
-+#define NOTE_DATA_SZ SZ_1K
-+#define GNU_PROPERTY_TYPE_0_NAME "GNU"
-+#define NOTE_NAME_SZ (sizeof(GNU_PROPERTY_TYPE_0_NAME))
-+
-+static int parse_elf_properties(struct file *f, const struct elf_phdr *phdr,
-+				struct arch_elf_state *arch)
-+{
-+	union {
-+		struct elf_note nhdr;
-+		char data[NOTE_DATA_SZ];
-+	} note;
-+	loff_t pos;
-+	ssize_t n;
-+	size_t off, datasz;
-+	int ret;
-+	bool have_prev_type;
-+	u32 prev_type;
-+
-+	if (!IS_ENABLED(CONFIG_ARCH_USE_GNU_PROPERTY) || !phdr)
-+		return 0;
-+
-+	/* load_elf_binary() shouldn't call us unless this is true... */
-+	if (WARN_ON_ONCE(phdr->p_type != PT_GNU_PROPERTY))
-+		return -ENOEXEC;
-+
-+	/* If the properties are crazy large, that's too bad (for now): */
-+	if (phdr->p_filesz > sizeof(note))
-+		return -ENOEXEC;
-+
-+	pos = phdr->p_offset;
-+	n = kernel_read(f, &note, phdr->p_filesz, &pos);
-+
-+	BUILD_BUG_ON(sizeof(note) < sizeof(note.nhdr) + NOTE_NAME_SZ);
-+	if (n < 0 || n < sizeof(note.nhdr) + NOTE_NAME_SZ)
-+		return -EIO;
-+
-+	if (note.nhdr.n_type != NT_GNU_PROPERTY_TYPE_0 ||
-+	    note.nhdr.n_namesz != NOTE_NAME_SZ ||
-+	    strncmp(note.data + sizeof(note.nhdr),
-+		    GNU_PROPERTY_TYPE_0_NAME, n - sizeof(note.nhdr)))
-+		return -ENOEXEC;
-+
-+	off = round_up(sizeof(note.nhdr) + NOTE_NAME_SZ,
-+		       ELF_GNU_PROPERTY_ALIGN);
-+	if (off > n)
-+		return -ENOEXEC;
-+
-+	if (note.nhdr.n_descsz > n - off)
-+		return -ENOEXEC;
-+	datasz = off + note.nhdr.n_descsz;
-+
-+	have_prev_type = false;
-+	do {
-+		ret = parse_elf_property(note.data, &off, datasz, arch,
-+					 have_prev_type, &prev_type);
-+		have_prev_type = true;
-+	} while (!ret);
-+
-+	return ret == -ENOENT ? 0 : ret;
-+}
-+
- static int load_elf_binary(struct linux_binprm *bprm)
- {
- 	struct file *interpreter = NULL; /* to shut gcc up */
-@@ -689,6 +800,7 @@ static int load_elf_binary(struct linux_binprm *bprm)
- 	int load_addr_set = 0;
- 	unsigned long error;
- 	struct elf_phdr *elf_ppnt, *elf_phdata, *interp_elf_phdata = NULL;
-+	struct elf_phdr *elf_property_phdata = NULL;
- 	unsigned long elf_bss, elf_brk;
- 	int bss_prot = 0;
- 	int retval, i;
-@@ -726,6 +838,11 @@ static int load_elf_binary(struct linux_binprm *bprm)
- 	for (i = 0; i < elf_ex->e_phnum; i++, elf_ppnt++) {
- 		char *elf_interpreter;
- 
-+		if (elf_ppnt->p_type == PT_GNU_PROPERTY) {
-+			elf_property_phdata = elf_ppnt;
-+			continue;
-+		}
-+
- 		if (elf_ppnt->p_type != PT_INTERP)
- 			continue;
- 
-@@ -819,9 +936,14 @@ static int load_elf_binary(struct linux_binprm *bprm)
- 			goto out_free_dentry;
- 
- 		/* Pass PT_LOPROC..PT_HIPROC headers to arch code */
-+		elf_property_phdata = NULL;
- 		elf_ppnt = interp_elf_phdata;
- 		for (i = 0; i < interp_elf_ex->e_phnum; i++, elf_ppnt++)
- 			switch (elf_ppnt->p_type) {
-+			case PT_GNU_PROPERTY:
-+				elf_property_phdata = elf_ppnt;
-+				break;
-+
- 			case PT_LOPROC ... PT_HIPROC:
- 				retval = arch_elf_pt_proc(interp_elf_ex,
- 							  elf_ppnt, interpreter,
-@@ -832,6 +954,11 @@ static int load_elf_binary(struct linux_binprm *bprm)
- 			}
- 	}
- 
-+	retval = parse_elf_properties(interpreter ?: bprm->file,
-+				      elf_property_phdata, &arch_state);
-+	if (retval)
-+		goto out_free_dentry;
-+
- 	/*
- 	 * Allow arch code to reject the ELF at this point, whilst it's
- 	 * still possible to return an error to the code that invoked
-diff --git a/fs/compat_binfmt_elf.c b/fs/compat_binfmt_elf.c
-index aaad4ca1217e..13a087bc816b 100644
---- a/fs/compat_binfmt_elf.c
-+++ b/fs/compat_binfmt_elf.c
-@@ -17,6 +17,8 @@
- #include <linux/elfcore-compat.h>
- #include <linux/time.h>
- 
-+#define ELF_COMPAT	1
-+
- /*
-  * Rename the basic ELF layout types to refer to the 32-bit class of files.
-  */
-@@ -28,11 +30,13 @@
- #undef	elf_shdr
- #undef	elf_note
- #undef	elf_addr_t
-+#undef	ELF_GNU_PROPERTY_ALIGN
- #define elfhdr		elf32_hdr
- #define elf_phdr	elf32_phdr
- #define elf_shdr	elf32_shdr
- #define elf_note	elf32_note
- #define elf_addr_t	Elf32_Addr
-+#define ELF_GNU_PROPERTY_ALIGN	ELF32_GNU_PROPERTY_ALIGN
- 
- /*
-  * Some data types as stored in coredump.
-diff --git a/include/linux/elf.h b/include/linux/elf.h
-index 459cddcceaac..7bdc6da160c7 100644
---- a/include/linux/elf.h
-+++ b/include/linux/elf.h
-@@ -22,6 +22,9 @@
- 	SET_PERSONALITY(ex)
- #endif
- 
-+#define ELF32_GNU_PROPERTY_ALIGN	4
-+#define ELF64_GNU_PROPERTY_ALIGN	8
-+
- #if ELF_CLASS == ELFCLASS32
- 
- extern Elf32_Dyn _DYNAMIC [];
-@@ -32,6 +35,7 @@ extern Elf32_Dyn _DYNAMIC [];
- #define elf_addr_t	Elf32_Off
- #define Elf_Half	Elf32_Half
- #define Elf_Word	Elf32_Word
-+#define ELF_GNU_PROPERTY_ALIGN	ELF32_GNU_PROPERTY_ALIGN
- 
- #else
- 
-@@ -43,6 +47,7 @@ extern Elf64_Dyn _DYNAMIC [];
- #define elf_addr_t	Elf64_Off
- #define Elf_Half	Elf64_Half
- #define Elf_Word	Elf64_Word
-+#define ELF_GNU_PROPERTY_ALIGN	ELF64_GNU_PROPERTY_ALIGN
- 
- #endif
- 
-@@ -64,4 +69,18 @@ struct gnu_property {
- 	u32 pr_datasz;
- };
- 
-+struct arch_elf_state;
-+
-+#ifndef CONFIG_ARCH_USE_GNU_PROPERTY
-+static inline int arch_parse_elf_property(u32 type, const void *data,
-+					  size_t datasz, bool compat,
-+					  struct arch_elf_state *arch)
-+{
-+	return 0;
-+}
-+#else
-+extern int arch_parse_elf_property(u32 type, const void *data, size_t datasz,
-+				   bool compat, struct arch_elf_state *arch);
-+#endif
-+
- #endif /* _LINUX_ELF_H */
-diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
-index 509fd27c6f93..49c026ce8d97 100644
---- a/include/uapi/linux/elf.h
-+++ b/include/uapi/linux/elf.h
-@@ -368,6 +368,7 @@ typedef struct elf64_shdr {
-  * Notes used in ET_CORE. Architectures export some of the arch register sets
-  * using the corresponding note types via the PTRACE_GETREGSET and
-  * PTRACE_SETREGSET requests.
-+ * The note name for all these is "LINUX".
-  */
- #define NT_PRSTATUS	1
- #define NT_PRFPREG	2
-@@ -430,6 +431,9 @@ typedef struct elf64_shdr {
- #define NT_MIPS_FP_MODE	0x801		/* MIPS floating-point mode */
- #define NT_MIPS_MSA	0x802		/* MIPS SIMD registers */
- 
-+/* Note types with note name "GNU" */
-+#define NT_GNU_PROPERTY_TYPE_0	5
-+
- /* Note header in a PT_NOTE section */
- typedef struct elf32_note {
-   Elf32_Word	n_namesz;	/* Name size */
--- 
-2.26.2
-
diff --git a/0043-x86-vdso-32-Add-ENDBR32-to-__kernel_vsyscall-entry-p.patch b/0032-x86-vdso-32-Add-ENDBR32-to-__kernel_vsyscall-entry-p.patch
similarity index 82%
rename from 0043-x86-vdso-32-Add-ENDBR32-to-__kernel_vsyscall-entry-p.patch
rename to 0032-x86-vdso-32-Add-ENDBR32-to-__kernel_vsyscall-entry-p.patch
index b4b764a85..540530d63 100644
--- a/0043-x86-vdso-32-Add-ENDBR32-to-__kernel_vsyscall-entry-p.patch
+++ b/0032-x86-vdso-32-Add-ENDBR32-to-__kernel_vsyscall-entry-p.patch
@@ -1,14 +1,13 @@
-From ad9ffb6c49123c8f94e10b2a8405f455de24dcf7 Mon Sep 17 00:00:00 2001
+From 79f0c7ee6b3709027532eaf2583efa271678b487 Mon Sep 17 00:00:00 2001
 From: "H.J. Lu" <hjl.tools@gmail.com>
 Date: Fri, 28 Sep 2018 06:21:50 -0700
-Subject: [PATCH 43/47] x86/vdso/32: Add ENDBR32 to __kernel_vsyscall entry
+Subject: [PATCH 32/40] x86/vdso/32: Add ENDBR32 to __kernel_vsyscall entry
  point
 
 Add ENDBR32 to __kernel_vsyscall entry point.
 
 Signed-off-by: H.J. Lu <hjl.tools@gmail.com>
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Acked-by: Andy Lutomirski <luto@kernel.org>
 ---
  arch/x86/entry/vdso/vdso32/system_call.S | 3 +++
  1 file changed, 3 insertions(+)
diff --git a/0044-x86-vdso-Insert-endbr32-endbr64-to-vDSO.patch b/0033-x86-vdso-Insert-endbr32-endbr64-to-vDSO.patch
similarity index 78%
rename from 0044-x86-vdso-Insert-endbr32-endbr64-to-vDSO.patch
rename to 0033-x86-vdso-Insert-endbr32-endbr64-to-vDSO.patch
index 76a005f4d..6a453d715 100644
--- a/0044-x86-vdso-Insert-endbr32-endbr64-to-vDSO.patch
+++ b/0033-x86-vdso-Insert-endbr32-endbr64-to-vDSO.patch
@@ -1,7 +1,7 @@
-From 348373388783ef8fc26c0cc7f2a6022fdc34c7fc Mon Sep 17 00:00:00 2001
+From bd6ed276cff59a2567a497b928bbfe40529de953 Mon Sep 17 00:00:00 2001
 From: "H.J. Lu" <hjl.tools@gmail.com>
 Date: Fri, 16 Mar 2018 04:18:48 -0700
-Subject: [PATCH 44/47] x86/vdso: Insert endbr32/endbr64 to vDSO
+Subject: [PATCH 33/40] x86/vdso: Insert endbr32/endbr64 to vDSO
 
 When Indirect Branch Tracking (IBT) is enabled, vDSO functions may be
 called indirectly, and must have ENDBR32 or ENDBR64 as the first
@@ -10,16 +10,15 @@ can be used to compile vDSO.
 
 Signed-off-by: H.J. Lu <hjl.tools@gmail.com>
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Acked-by: Andy Lutomirski <luto@kernel.org>
 ---
  arch/x86/entry/vdso/Makefile | 4 ++++
  1 file changed, 4 insertions(+)
 
 diff --git a/arch/x86/entry/vdso/Makefile b/arch/x86/entry/vdso/Makefile
-index 433a1259f61d..6de3493acfe4 100644
+index 04e65f0698f6..240530b58457 100644
 --- a/arch/x86/entry/vdso/Makefile
 +++ b/arch/x86/entry/vdso/Makefile
-@@ -120,6 +120,10 @@ $(obj)/%-x32.o: $(obj)/%.o FORCE
+@@ -130,6 +130,10 @@ $(obj)/%-x32.o: $(obj)/%.o FORCE
  
  targets += vdsox32.lds $(vobjx32s-y)
  
diff --git a/0045-x86-Disallow-vsyscall-emulation-when-CET-is-enabled.patch b/0034-x86-Disallow-vsyscall-emulation-when-CET-is-enabled.patch
similarity index 81%
rename from 0045-x86-Disallow-vsyscall-emulation-when-CET-is-enabled.patch
rename to 0034-x86-Disallow-vsyscall-emulation-when-CET-is-enabled.patch
index 7c929b96f..68b19533b 100644
--- a/0045-x86-Disallow-vsyscall-emulation-when-CET-is-enabled.patch
+++ b/0034-x86-Disallow-vsyscall-emulation-when-CET-is-enabled.patch
@@ -1,7 +1,7 @@
-From db93aeb7cf62532a740a82c6194424309b9272bb Mon Sep 17 00:00:00 2001
+From 2a0abf7fc7b425920e95589229161e18b0964333 Mon Sep 17 00:00:00 2001
 From: "H.J. Lu" <hjl.tools@gmail.com>
 Date: Wed, 29 Jan 2020 08:44:11 -0800
-Subject: [PATCH 45/47] x86: Disallow vsyscall emulation when CET is enabled
+Subject: [PATCH 34/40] x86: Disallow vsyscall emulation when CET is enabled
 
 Emulation of the legacy vsyscall page is required by some programs built
 before 2013.  Newer programs after 2013 don't use it.  Disallow vsyscall
@@ -15,19 +15,19 @@ Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
  1 file changed, 6 insertions(+), 2 deletions(-)
 
 diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
-index bb0e2a9feab7..a1d82f0bea6b 100644
+index dd642d6ff14b..3e8f5a66dc5a 100644
 --- a/arch/x86/Kconfig
 +++ b/arch/x86/Kconfig
-@@ -1211,7 +1211,7 @@ config X86_ESPFIX64
+@@ -1206,7 +1206,7 @@ config X86_ESPFIX64
  config X86_VSYSCALL_EMULATION
  	bool "Enable vsyscall emulation" if EXPERT
  	default y
 -	depends on X86_64
 +	depends on X86_64 && !X86_INTEL_CET
- 	---help---
+ 	help
  	 This enables emulation of the legacy vsyscall page.  Disabling
  	 it is roughly equivalent to booting with vsyscall=none, except
-@@ -1226,6 +1226,8 @@ config X86_VSYSCALL_EMULATION
+@@ -1221,6 +1221,8 @@ config X86_VSYSCALL_EMULATION
  	 Disabling this option saves about 7K of kernel size and
  	 possibly 4K of additional runtime pagetable memory.
  
@@ -36,7 +36,7 @@ index bb0e2a9feab7..a1d82f0bea6b 100644
  config X86_IOPL_IOPERM
  	bool "IOPERM and IOPL Emulation"
  	default y
-@@ -2382,7 +2384,7 @@ config COMPAT_VDSO
+@@ -2360,7 +2362,7 @@ config COMPAT_VDSO
  
  choice
  	prompt "vsyscall table for legacy applications"
@@ -45,7 +45,7 @@ index bb0e2a9feab7..a1d82f0bea6b 100644
  	default LEGACY_VSYSCALL_XONLY
  	help
  	  Legacy user code that does not know how to find the vDSO expects
-@@ -2399,6 +2401,8 @@ choice
+@@ -2377,6 +2379,8 @@ choice
  
  	  If unsure, select "Emulate execution only".
  
diff --git a/0046-powerpc-Keep-.rela-sections-when-CONFIG_RELOCATABLE-.patch b/0035-powerpc-Keep-.rela-sections-when-CONFIG_RELOCATABLE-.patch
similarity index 88%
rename from 0046-powerpc-Keep-.rela-sections-when-CONFIG_RELOCATABLE-.patch
rename to 0035-powerpc-Keep-.rela-sections-when-CONFIG_RELOCATABLE-.patch
index c09e10bd7..2f9f1be04 100644
--- a/0046-powerpc-Keep-.rela-sections-when-CONFIG_RELOCATABLE-.patch
+++ b/0035-powerpc-Keep-.rela-sections-when-CONFIG_RELOCATABLE-.patch
@@ -1,7 +1,7 @@
-From eecc5257e67990c5277abc0f9e69bb5fc8c13a99 Mon Sep 17 00:00:00 2001
+From 9b666dbe3a582f76fee031cb9ec2f3fc8d168f5a Mon Sep 17 00:00:00 2001
 From: "H.J. Lu" <hjl.tools@gmail.com>
 Date: Mon, 27 Apr 2020 14:04:48 -0700
-Subject: [PATCH 46/47] powerpc: Keep .rela* sections when CONFIG_RELOCATABLE
+Subject: [PATCH 35/40] powerpc: Keep .rela* sections when CONFIG_RELOCATABLE
  is defined
 
 arch/powerpc/kernel/vmlinux.lds.S has
@@ -34,7 +34,7 @@ Acked-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
  1 file changed, 4 insertions(+), 1 deletion(-)
 
 diff --git a/arch/powerpc/kernel/vmlinux.lds.S b/arch/powerpc/kernel/vmlinux.lds.S
-index 31a0f201fb6f..4ba07734a210 100644
+index 326e113d2e45..7f839c30619e 100644
 --- a/arch/powerpc/kernel/vmlinux.lds.S
 +++ b/arch/powerpc/kernel/vmlinux.lds.S
 @@ -366,9 +366,12 @@ SECTIONS
diff --git a/0047-Discard-.note.gnu.property-sections-in-generic-NOTES.patch b/0036-Discard-.note.gnu.property-sections-in-generic-NOTES.patch
similarity index 92%
rename from 0047-Discard-.note.gnu.property-sections-in-generic-NOTES.patch
rename to 0036-Discard-.note.gnu.property-sections-in-generic-NOTES.patch
index 37a422891..cc9e43096 100644
--- a/0047-Discard-.note.gnu.property-sections-in-generic-NOTES.patch
+++ b/0036-Discard-.note.gnu.property-sections-in-generic-NOTES.patch
@@ -1,7 +1,7 @@
-From 6b194ba038dc1936e319028eb95dd1cfe56aea8e Mon Sep 17 00:00:00 2001
+From 80d436746749bc46f62613e4f2f397f53b01864d Mon Sep 17 00:00:00 2001
 From: "H.J. Lu" <hjl.tools@gmail.com>
 Date: Thu, 30 Jan 2020 12:39:09 -0800
-Subject: [PATCH 47/47] Discard .note.gnu.property sections in generic NOTES
+Subject: [PATCH 36/40] Discard .note.gnu.property sections in generic NOTES
 
 With the command-line option, -mx86-used-note=yes, the x86 assembler
 in binutils 2.32 and above generates a program property note in a note
@@ -58,10 +58,10 @@ Reviewed-by: Kees Cook <keescook@chromium.org>
  1 file changed, 7 insertions(+)
 
 diff --git a/include/asm-generic/vmlinux.lds.h b/include/asm-generic/vmlinux.lds.h
-index 71e387a5fe90..95cd678428f4 100644
+index 052e0f05a984..2a7034da4e12 100644
 --- a/include/asm-generic/vmlinux.lds.h
 +++ b/include/asm-generic/vmlinux.lds.h
-@@ -833,7 +833,14 @@
+@@ -846,7 +846,14 @@
  #define TRACEDATA
  #endif
  
diff --git a/0037-selftest-x86-Enable-CET-for-selftests-x86.patch b/0037-selftest-x86-Enable-CET-for-selftests-x86.patch
new file mode 100644
index 000000000..81d2934ab
--- /dev/null
+++ b/0037-selftest-x86-Enable-CET-for-selftests-x86.patch
@@ -0,0 +1,54 @@
+From fa88801777012bc0e5223ded8ac7a21a58c917ca Mon Sep 17 00:00:00 2001
+From: Yu-cheng Yu <yu-cheng.yu@intel.com>
+Date: Tue, 2 Oct 2018 10:38:38 -0700
+Subject: [PATCH 37/40] selftest/x86: Enable CET for selftests/x86
+
+To build a shadow stack-enabled application written in C language, only the
+latest linker (ld) is necessary for marking .note.gnu.property in the ELF
+header.  If a shadow stack-enabled application contains assembly code, the
+latest assembler is also needed.  It is possible to hard-code shadow stack
+instructions and build the application without assembler support.
+
+To build an indirect branch tracking application, the latest toolchain,
+including compiler, assembler, and linker, is needed.  This is because
+branch targets are evaluated and labeled by the compiler.
+
+Shadow stack and indirect branch tracking complement each other, and are
+most effective when both are enabled.  An updated toolchain can build both
+without additional efforts.  Update makefile to detect and enable CET build
+for x86 selftest.
+
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
+
+v2:
+- Export CAN_BUILD_CET to source code.
+---
+ tools/testing/selftests/x86/Makefile | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+diff --git a/tools/testing/selftests/x86/Makefile b/tools/testing/selftests/x86/Makefile
+index d2796ea98c5a..018518737e47 100644
+--- a/tools/testing/selftests/x86/Makefile
++++ b/tools/testing/selftests/x86/Makefile
+@@ -9,6 +9,7 @@ UNAME_M := $(shell uname -m)
+ CAN_BUILD_I386 := $(shell ./check_cc.sh $(CC) trivial_32bit_program.c -m32)
+ CAN_BUILD_X86_64 := $(shell ./check_cc.sh $(CC) trivial_64bit_program.c)
+ CAN_BUILD_WITH_NOPIE := $(shell ./check_cc.sh $(CC) trivial_program.c -no-pie)
++CAN_BUILD_CET := $(shell ./check_cc.sh $(CC) trivial_program.c -fcf-protection)
+ 
+ TARGETS_C_BOTHBITS := single_step_syscall sysret_ss_attrs syscall_nt test_mremap_vdso \
+ 			check_initial_reg_state sigreturn iopl ioperm \
+@@ -35,6 +36,10 @@ BINARIES_64 := $(patsubst %,$(OUTPUT)/%,$(BINARIES_64))
+ 
+ CFLAGS := -O2 -g -std=gnu99 -pthread -Wall
+ 
++ifeq ($(CAN_BUILD_CET),1)
++CFLAGS += -fcf-protection -mshstk -DCAN_BUILD_CET
++endif
++
+ # call32_from_64 in thunks.S uses absolute addresses.
+ ifeq ($(CAN_BUILD_WITH_NOPIE),1)
+ CFLAGS += -no-pie
+-- 
+2.26.2
+
diff --git a/0038-selftest-x86-Fix-sigreturn_64-test.patch b/0038-selftest-x86-Fix-sigreturn_64-test.patch
new file mode 100644
index 000000000..a7f891216
--- /dev/null
+++ b/0038-selftest-x86-Fix-sigreturn_64-test.patch
@@ -0,0 +1,93 @@
+From 32ea3682e2e778a2f49feb118d8bd735d0d2b613 Mon Sep 17 00:00:00 2001
+From: Yu-cheng Yu <yu-cheng.yu@intel.com>
+Date: Wed, 20 May 2020 10:47:47 -0700
+Subject: [PATCH 38/40] selftest/x86: Fix sigreturn_64 test.
+
+When shadow stack is enabled, x86/sigreturn_64 triggers a fault upon doing
+sigreturn to 32-bit context with a 64-bit shadow stack pointer.
+
+Fix it by:
+- Allocate a small shadow stack within 32-bit address range,
+- Switch to the new shadow stack,
+- Run tests,
+- Switch back to the original 64-bit shadow stack.
+
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
+
+v2:
+- Test CAN_BUILD_CET before including shadow stack instructions.
+- Pull ARCH_X86_CET_ALLOC_SHSTK definition from the header file.
+- Add more comments.
+---
+ tools/testing/selftests/x86/sigreturn.c | 41 +++++++++++++++++++++++++
+ 1 file changed, 41 insertions(+)
+
+diff --git a/tools/testing/selftests/x86/sigreturn.c b/tools/testing/selftests/x86/sigreturn.c
+index 57c4f67f16ef..b6af4ecd2ca2 100644
+--- a/tools/testing/selftests/x86/sigreturn.c
++++ b/tools/testing/selftests/x86/sigreturn.c
+@@ -45,6 +45,12 @@
+ #include <stdbool.h>
+ #include <sys/ptrace.h>
+ #include <sys/user.h>
++#include <sys/mman.h>
++#include <x86intrin.h>
++
++/* Pull in ARCH_X86_CET_MMAP_SHSTK */
++#include "../../../../arch/x86/include/uapi/asm/prctl.h"
++int arch_prctl(int code, unsigned long *addr);
+ 
+ /* Pull in AR_xyz defines. */
+ typedef unsigned int u32;
+@@ -766,6 +772,31 @@ int main()
+ 	int total_nerrs = 0;
+ 	unsigned short my_cs, my_ss;
+ 
++#if defined(__x86_64__) && defined(CAN_BUILD_CET)
++	unsigned long arg[3], ssp_64, ssp_32;
++
++	ssp_64 = _get_ssp();
++
++	if (ssp_64 != 0) {
++		/* Alloc a shadow stack within 32-bit address range */
++		arg[0] = 0x0;
++		arg[1] = 0x1000;
++		arg[2] = MAP_32BIT;
++		if (arch_prctl(ARCH_X86_CET_MMAP_SHSTK, arg)) {
++			printf("[FAIL]\tCannot allocate shadow stack\n");
++			return 1;
++		}
++
++		/*
++		 * The top of shadow stack is an 8-byte token, point ssp_32
++		 * to the token.
++		 */
++		ssp_32 = arg[0] + 0x1000 - 8;
++		asm volatile("rstorssp (%0)\n":: "r" (ssp_32));
++		asm volatile("saveprevssp");
++	}
++#endif
++
+ 	asm volatile ("mov %%cs,%0" : "=r" (my_cs));
+ 	asm volatile ("mov %%ss,%0" : "=r" (my_ss));
+ 	setup_ldt();
+@@ -870,6 +901,16 @@ int main()
+ 
+ #ifdef __x86_64__
+ 	total_nerrs += test_nonstrict_ss();
++
++#ifdef CAN_BUILD_CET
++	if (ssp_64 != 0) {
++		/* Point ssp_64 to the restore token */
++		ssp_64 -= 8;
++		asm volatile("rstorssp (%0)\n":: "r" (ssp_64));
++		asm volatile("saveprevssp");
++		munmap((void *)arg[0], 0x1000);
++	}
++#endif
+ #endif
+ 
+ 	return total_nerrs ? 1 : 0;
+-- 
+2.26.2
+
diff --git a/0039-selftest-x86-Fix-sysret_rip-with-ENDBR.patch b/0039-selftest-x86-Fix-sysret_rip-with-ENDBR.patch
new file mode 100644
index 000000000..7ef45e87c
--- /dev/null
+++ b/0039-selftest-x86-Fix-sysret_rip-with-ENDBR.patch
@@ -0,0 +1,46 @@
+From ada51744e8de56435208092e8805303f65e5835c Mon Sep 17 00:00:00 2001
+From: Yu-cheng Yu <yu-cheng.yu@intel.com>
+Date: Tue, 2 Oct 2018 10:38:38 -0700
+Subject: [PATCH 39/40] selftest/x86: Fix sysret_rip with ENDBR
+
+When indirect branch tracking is enabled, an indirect near CALL/JMP,
+without the 'notrack' prefix, must land at an ENDBR instruction, otherwise
+a control-protection fault is triggered.
+
+The compiler inserts ENDBR's for C code, but assembly code must be updated
+manually.  Fix that for x86/sysret_rip.
+
+When CET is not enabled, ENDBR is a nop and has no effect.
+
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
+---
+ tools/testing/selftests/x86/sysret_rip.c | 5 +++--
+ 1 file changed, 3 insertions(+), 2 deletions(-)
+
+diff --git a/tools/testing/selftests/x86/sysret_rip.c b/tools/testing/selftests/x86/sysret_rip.c
+index 84d74be1d902..027682a0f377 100644
+--- a/tools/testing/selftests/x86/sysret_rip.c
++++ b/tools/testing/selftests/x86/sysret_rip.c
+@@ -27,8 +27,9 @@ asm (
+ 	".pushsection \".text\", \"ax\"\n\t"
+ 	".balign 4096\n\t"
+ 	"test_page: .globl test_page\n\t"
+-	".fill 4094,1,0xcc\n\t"
++	".fill 4090,1,0xcc\n\t"
+ 	"test_syscall_insn:\n\t"
++	"endbr64\n\t"
+ 	"syscall\n\t"
+ 	".ifne . - test_page - 4096\n\t"
+ 	".error \"test page is not one page long\"\n\t"
+@@ -151,7 +152,7 @@ static void test_syscall_fallthrough_to(unsigned long ip)
+ 
+ 	if (sigsetjmp(jmpbuf, 1) == 0) {
+ 		asm volatile ("call *%[syscall_insn]" :: "a" (SYS_getpid),
+-			      [syscall_insn] "rm" (ip - 2));
++			      [syscall_insn] "rm" (ip - 6));
+ 		errx(1, "[FAIL]\tSyscall trampoline returned");
+ 	}
+ 
+-- 
+2.26.2
+
diff --git a/0040-selftest-x86-Add-CET-quick-test.patch b/0040-selftest-x86-Add-CET-quick-test.patch
new file mode 100644
index 000000000..63a312b11
--- /dev/null
+++ b/0040-selftest-x86-Add-CET-quick-test.patch
@@ -0,0 +1,191 @@
+From d01814c5f0810f6bba256a8f10636ea487469c6e Mon Sep 17 00:00:00 2001
+From: Yu-cheng Yu <yu-cheng.yu@intel.com>
+Date: Wed, 20 May 2020 15:38:29 -0700
+Subject: [PATCH 40/40] selftest/x86: Add CET quick test
+
+Introduce a quick test to verify shadow stack and IBT are working.
+
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
+
+v2:
+- Rewrite assembly code and remove compiler conditionals.
+- Update return code to include 'not_tested'.
+- Verify in segv_handler the fault is a control-protection fault, otherwise
+  exit the test.
+- Use only one user signal SIGUSR1.
+---
+ tools/testing/selftests/x86/Makefile         |   2 +-
+ tools/testing/selftests/x86/cet_quick_test.c | 148 +++++++++++++++++++
+ 2 files changed, 149 insertions(+), 1 deletion(-)
+ create mode 100644 tools/testing/selftests/x86/cet_quick_test.c
+
+diff --git a/tools/testing/selftests/x86/Makefile b/tools/testing/selftests/x86/Makefile
+index 018518737e47..61f1639f3ab0 100644
+--- a/tools/testing/selftests/x86/Makefile
++++ b/tools/testing/selftests/x86/Makefile
+@@ -14,7 +14,7 @@ CAN_BUILD_CET := $(shell ./check_cc.sh $(CC) trivial_program.c -fcf-protection)
+ TARGETS_C_BOTHBITS := single_step_syscall sysret_ss_attrs syscall_nt test_mremap_vdso \
+ 			check_initial_reg_state sigreturn iopl ioperm \
+ 			test_vdso test_vsyscall mov_ss_trap \
+-			syscall_arg_fault
++			syscall_arg_fault cet_quick_test
+ TARGETS_C_32BIT_ONLY := entry_from_vm86 test_syscall_vdso unwind_vdso \
+ 			test_FCMOV test_FCOMI test_FISTTP \
+ 			vdso_restorer
+diff --git a/tools/testing/selftests/x86/cet_quick_test.c b/tools/testing/selftests/x86/cet_quick_test.c
+new file mode 100644
+index 000000000000..8480cf303a3b
+--- /dev/null
++++ b/tools/testing/selftests/x86/cet_quick_test.c
+@@ -0,0 +1,148 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/* Quick tests to verify Shadow Stack and IBT are working */
++
++#include <stdio.h>
++#include <stdlib.h>
++#include <signal.h>
++#include <string.h>
++#include <ucontext.h>
++
++ucontext_t ucp;
++
++enum {
++	r_not_tested = -1,
++	r_fail = 0,
++	r_ok = 1,
++};
++
++int result[4] = {r_not_tested, r_not_tested, r_not_tested, r_not_tested};
++int test_id;
++
++/* Defined in include/uapi/asm-generic/siginfo.h */
++#define SEGV_CPERR 8
++
++/*
++ * Do an indirect jmp to a location without endbr to trigger a control
++ * protection fault.  Verify in segv_handler that ibt is working.
++ */
++void ibt_violation(void)
++{
++	void *ptr;
++
++	asm volatile("lea 1f, %0\n\t"
++		     "jmp *%0\n\t"
++		     "1:" : "=r"(ptr));
++
++	result[test_id] = r_fail;
++	test_id++;
++	setcontext(&ucp);
++}
++
++/*
++ * Do a push and ret to cause shadow stack mismatch and trigger a control
++ * protection fault.  Verify in segv_handler that shadow stack is working.
++ */
++void shstk_violation(void)
++{
++	void *ptr;
++
++	asm volatile("lea 1f, %0\n\t"
++		     "push %0\n\t"
++		     "ret\n\t"
++		     "1:" : "=r"(ptr));
++
++	result[test_id] = r_fail;
++	test_id++;
++	setcontext(&ucp);
++}
++
++void segv_handler(int signum, siginfo_t *si, void *uc)
++{
++	if (si->si_code == SEGV_CPERR) {
++		result[test_id] = r_ok;
++		test_id++;
++	} else {
++		printf("Unexpected seg fault\n");
++		exit(1);
++	}
++
++	setcontext(&ucp);
++}
++
++/*
++ * Verify shadow stack and ibt are working in a signal handler.
++ */
++void user1_handler(int signum, siginfo_t *si, void *uc)
++{
++	if (test_id == 2)
++		shstk_violation();
++
++	if (test_id == 3)
++		ibt_violation();
++}
++
++int main(int argc, char *argv[])
++{
++	struct sigaction sa;
++	int r;
++
++	r = sigemptyset(&sa.sa_mask);
++	if (r)
++		return -1;
++
++	sa.sa_flags = SA_SIGINFO;
++
++	/*
++	 * Control protection fault handler
++	 */
++	sa.sa_sigaction = segv_handler;
++	r = sigaction(SIGSEGV, &sa, NULL);
++	if (r)
++		return -1;
++
++	/*
++	 * Test shadow stack/ibt in signal handler
++	 */
++	sa.sa_sigaction = user1_handler;
++	r = sigaction(SIGUSR1, &sa, NULL);
++	if (r)
++		return -1;
++
++	test_id = 0;
++
++	/*
++	 * Pass or fail, each test returns here with test_id incremented to
++	 * the next test.
++	 */
++	r = getcontext(&ucp);
++	if (r)
++		return -1;
++
++	if (test_id == 0)
++		shstk_violation();
++	else if (test_id == 1)
++		ibt_violation();
++	else if (test_id == 2)
++		raise(SIGUSR1);
++	else if (test_id == 3)
++		raise(SIGUSR1);
++
++	r = 0;
++	printf("[%s]\tShadow stack\n", result[0] == -1 ? "untested" :
++	       (result[0] ? "OK" : "FAIL"));
++	r += result[0];
++
++	printf("[%s]\tIBT\n", result[1] == -1 ? "untested" :
++	       (result[1] ? "OK" : "FAIL"));
++	r += result[1];
++
++	printf("[%s]\tShadow stack in signal\n", result[2] == -1 ? "untested" :
++	       (result[2] ? "OK" : "FAIL"));
++	r += result[2];
++
++	printf("[%s]\tIBT in signal\n", result[3] == -1 ? "untested" :
++	       (result[3] ? "OK" : "FAIL"));
++	r += result[3];
++
++	return r;
++}
+-- 
+2.26.2
+
diff --git a/kernel.spec b/kernel.spec
index 5d1aa8ec3..5655fa8d5 100644
--- a/kernel.spec
+++ b/kernel.spec
@@ -1,50 +1,43 @@
-Patch200001: 0001-x86-fpu-xstate-Rename-validate_xstate_header-to-vali.patch
-Patch200002: 0002-x86-fpu-xstate-Define-new-macros-for-supervisor-and-.patch
-Patch200003: 0003-x86-fpu-xstate-Separate-user-and-supervisor-xfeature.patch
-Patch200004: 0004-x86-fpu-xstate-Introduce-XSAVES-supervisor-states.patch
-Patch200005: 0005-x86-fpu-xstate-Define-new-functions-for-clearing-fpr.patch
-Patch200006: 0006-x86-fpu-xstate-Update-sanitize_restored_xstate-for-s.patch
-Patch200007: 0007-x86-fpu-xstate-Update-copy_kernel_to_xregs_err-for-X.patch
-Patch200008: 0008-x86-fpu-Introduce-copy_supervisor_to_kernel.patch
-Patch200009: 0009-x86-fpu-xstate-Preserve-supervisor-states-for-slow-p.patch
-Patch200010: 0010-x86-fpu-xstate-Restore-supervisor-states-for-signal-.patch
-Patch200011: 0011-Documentation-x86-Add-CET-description.patch
-Patch200012: 0012-x86-cpufeatures-Add-CET-CPU-feature-flags-for-Contro.patch
-Patch200013: 0013-x86-fpu-xstate-Introduce-CET-MSR-XSAVES-supervisor-s.patch
-Patch200014: 0014-x86-cet-Add-control-protection-fault-handler.patch
-Patch200015: 0015-x86-cet-shstk-Add-Kconfig-option-for-user-mode-Shado.patch
-Patch200016: 0016-x86-mm-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_HW.patch
-Patch200017: 0017-x86-mm-Remove-_PAGE_DIRTY_HW-from-kernel-RO-pages.patch
-Patch200018: 0018-x86-mm-Introduce-_PAGE_COW.patch
-Patch200019: 0019-drm-i915-gvt-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_BITS.patch
-Patch200020: 0020-x86-mm-Update-pte_modify-for-_PAGE_COW.patch
-Patch200021: 0021-x86-mm-Update-ptep_set_wrprotect-and-pmdp_set_wrprot.patch
-Patch200022: 0022-mm-Introduce-VM_SHSTK-for-shadow-stack-memory.patch
-Patch200023: 0023-x86-mm-Shadow-Stack-page-fault-error-checking.patch
-Patch200024: 0024-x86-mm-Update-maybe_mkwrite-for-shadow-stack.patch
-Patch200025: 0025-mm-Fixup-places-that-call-pte_mkwrite-directly.patch
-Patch200026: 0026-mm-Add-guard-pages-around-a-shadow-stack.patch
-Patch200027: 0027-mm-mmap-Add-shadow-stack-pages-to-memory-accounting.patch
-Patch200028: 0028-mm-Update-can_follow_write_pte-for-shadow-stack.patch
-Patch200029: 0029-x86-cet-shstk-User-mode-shadow-stack-support.patch
-Patch200030: 0030-x86-cet-shstk-Handle-signals-for-shadow-stack.patch
-Patch200031: 0031-ELF-UAPI-and-Kconfig-additions-for-ELF-program-prope.patch
-Patch200032: 0032-ELF-Add-ELF-program-property-parsing-support.patch
-Patch200033: 0033-ELF-Introduce-arch_setup_elf_property.patch
-Patch200034: 0034-x86-cet-shstk-ELF-header-parsing-for-shadow-stack.patch
-Patch200035: 0035-x86-cet-shstk-Handle-thread-shadow-stack.patch
-Patch200036: 0036-x86-cet-shstk-Add-arch_prctl-functions-for-shadow-st.patch
-Patch200037: 0037-x86-cet-ibt-Add-Kconfig-option-for-user-mode-Indirec.patch
-Patch200038: 0038-x86-cet-ibt-User-mode-Indirect-Branch-Tracking-suppo.patch
-Patch200039: 0039-x86-cet-ibt-Handle-signals-for-Indirect-Branch-Track.patch
-Patch200040: 0040-x86-cet-ibt-ELF-header-parsing-for-Indirect-Branch-T.patch
-Patch200041: 0041-x86-cet-ibt-Add-arch_prctl-functions-for-Indirect-Br.patch
-Patch200042: 0042-x86-cet-Add-PTRACE-interface-for-CET.patch
-Patch200043: 0043-x86-vdso-32-Add-ENDBR32-to-__kernel_vsyscall-entry-p.patch
-Patch200044: 0044-x86-vdso-Insert-endbr32-endbr64-to-vDSO.patch
-Patch200045: 0045-x86-Disallow-vsyscall-emulation-when-CET-is-enabled.patch
-Patch200046: 0046-powerpc-Keep-.rela-sections-when-CONFIG_RELOCATABLE-.patch
-Patch200047: 0047-Discard-.note.gnu.property-sections-in-generic-NOTES.patch
+Patch200001: 0001-Documentation-x86-Add-CET-description.patch
+Patch200002: 0002-x86-cpufeatures-Add-CET-CPU-feature-flags-for-Contro.patch
+Patch200003: 0003-x86-fpu-xstate-Introduce-CET-MSR-XSAVES-supervisor-s.patch
+Patch200004: 0004-x86-cet-Add-control-protection-fault-handler.patch
+Patch200005: 0005-x86-cet-shstk-Add-Kconfig-option-for-user-mode-Shado.patch
+Patch200006: 0006-x86-mm-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_HW.patch
+Patch200007: 0007-x86-mm-Remove-_PAGE_DIRTY_HW-from-kernel-RO-pages.patch
+Patch200008: 0008-x86-mm-Introduce-_PAGE_COW.patch
+Patch200009: 0009-drm-i915-gvt-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_BITS.patch
+Patch200010: 0010-x86-mm-Update-pte_modify-for-_PAGE_COW.patch
+Patch200011: 0011-x86-mm-Update-ptep_set_wrprotect-and-pmdp_set_wrprot.patch
+Patch200012: 0012-mm-Introduce-VM_SHSTK-for-shadow-stack-memory.patch
+Patch200013: 0013-x86-mm-Shadow-Stack-page-fault-error-checking.patch
+Patch200014: 0014-x86-mm-Update-maybe_mkwrite-for-shadow-stack.patch
+Patch200015: 0015-mm-Fixup-places-that-call-pte_mkwrite-directly.patch
+Patch200016: 0016-mm-Add-guard-pages-around-a-shadow-stack.patch
+Patch200017: 0017-mm-mmap-Add-shadow-stack-pages-to-memory-accounting.patch
+Patch200018: 0018-mm-Update-can_follow_write_pte-for-shadow-stack.patch
+Patch200019: 0019-x86-cet-shstk-User-mode-shadow-stack-support.patch
+Patch200020: 0020-x86-cet-shstk-Handle-signals-for-shadow-stack.patch
+Patch200021: 0021-binfmt_elf-Define-GNU_PROPERTY_X86_FEATURE_1_AND-pro.patch
+Patch200022: 0022-ELF-Introduce-arch_setup_elf_property.patch
+Patch200023: 0023-x86-cet-shstk-ELF-header-parsing-for-shadow-stack.patch
+Patch200024: 0024-x86-cet-shstk-Handle-thread-shadow-stack.patch
+Patch200025: 0025-x86-cet-shstk-Add-arch_prctl-functions-for-shadow-st.patch
+Patch200026: 0026-x86-cet-ibt-Add-Kconfig-option-for-user-mode-Indirec.patch
+Patch200027: 0027-x86-cet-ibt-User-mode-Indirect-Branch-Tracking-suppo.patch
+Patch200028: 0028-x86-cet-ibt-Handle-signals-for-Indirect-Branch-Track.patch
+Patch200029: 0029-x86-cet-ibt-ELF-header-parsing-for-Indirect-Branch-T.patch
+Patch200030: 0030-x86-cet-ibt-Add-arch_prctl-functions-for-Indirect-Br.patch
+Patch200031: 0031-x86-cet-Add-PTRACE-interface-for-CET.patch
+Patch200032: 0032-x86-vdso-32-Add-ENDBR32-to-__kernel_vsyscall-entry-p.patch
+Patch200033: 0033-x86-vdso-Insert-endbr32-endbr64-to-vDSO.patch
+Patch200034: 0034-x86-Disallow-vsyscall-emulation-when-CET-is-enabled.patch
+Patch200035: 0035-powerpc-Keep-.rela-sections-when-CONFIG_RELOCATABLE-.patch
+Patch200036: 0036-Discard-.note.gnu.property-sections-in-generic-NOTES.patch
+Patch200037: 0037-selftest-x86-Enable-CET-for-selftests-x86.patch
+Patch200038: 0038-selftest-x86-Fix-sigreturn_64-test.patch
+Patch200039: 0039-selftest-x86-Fix-sysret_rip-with-ENDBR.patch
+Patch200040: 0040-selftest-x86-Add-CET-quick-test.patch
 
 # We have to override the new %%install behavior because, well... the kernel is special.
 %global __spec_install_pre %{___build_pre}
-- 
2.26.2

