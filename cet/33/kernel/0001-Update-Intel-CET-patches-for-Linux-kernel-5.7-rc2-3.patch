From 4b76d6cec50dc44f6d815b48abfdeb7975fb8556 Mon Sep 17 00:00:00 2001
From: "H.J. Lu" <hjl.tools@gmail.com>
Date: Tue, 28 Apr 2020 11:27:25 -0700
Subject: [PATCH 1/3] Update Intel CET patches for Linux kernel 5.7-rc2 3

Fix CET signal handling
---
 ...ename-validate_xstate_header-to-vali.patch |   6 +-
 ...efine-new-macros-for-supervisor-and-.patch |   6 +-
 ...eparate-user-and-supervisor-xfeature.patch |   6 +-
 ...e-Introduce-XSAVES-supervisor-states.patch |   6 +-
 ...efine-new-functions-for-clearing-fpr.patch |   6 +-
 ...pdate-sanitize_restored_xstate-for-s.patch |   6 +-
 ...pdate-copy_kernel_to_xregs_err-for-X.patch |   6 +-
 ...-Introduce-copy_supervisor_to_kernel.patch |   6 +-
 ...reserve-supervisor-states-for-slow-p.patch |   6 +-
 ...estore-supervisor-states-for-signal-.patch |   6 +-
 ...ocumentation-x86-Add-CET-description.patch |  14 +-
 ...Add-CET-CPU-feature-flags-for-Contro.patch |   6 +-
 ...ntroduce-CET-MSR-XSAVES-supervisor-s.patch |  12 +-
 ...Add-control-protection-fault-handler.patch |  12 +-
 ...d-Kconfig-option-for-user-mode-Shado.patch |  23 ++-
 ...Change-_PAGE_DIRTY-to-_PAGE_DIRTY_HW.patch |  16 +-
 ...-_PAGE_DIRTY_HW-from-kernel-RO-pages.patch |  14 +-
 0018-x86-mm-Introduce-_PAGE_COW.patch         |  76 +++++-----
 ...ange-_PAGE_DIRTY-to-_PAGE_DIRTY_BITS.patch |  16 +-
 ...6-mm-Update-pte_modify-for-_PAGE_COW.patch |  24 ++-
 ...ep_set_wrprotect-and-pmdp_set_wrprot.patch |  32 ++--
 ...uce-VM_SHSTK-for-shadow-stack-memory.patch |  14 +-
 ...adow-Stack-page-fault-error-checking.patch |  31 ++--
 ...pdate-maybe_mkwrite-for-shadow-stack.patch |  93 ++++++------
 ...laces-that-call-pte_mkwrite-directly.patch |  42 ++++--
 ...dd-guard-pages-around-a-shadow-stack.patch |  28 ++--
 ...dow-stack-pages-to-memory-accounting.patch |  32 ++--
 ...an_follow_write_pte-for-shadow-stack.patch |  32 ++--
 ...shstk-User-mode-shadow-stack-support.patch |  20 +--
 ...hstk-Handle-signals-for-shadow-stack.patch | 139 ++++++++++--------
 ...nfig-additions-for-ELF-program-prope.patch |  12 +-
 ...ELF-program-property-parsing-support.patch |   6 +-
 ...LF-Introduce-arch_setup_elf_property.patch |   9 +-
 ...-ELF-header-parsing-for-shadow-stack.patch |  16 +-
 ...cet-shstk-Handle-thread-shadow-stack.patch |  43 ++----
 ...d-arch_prctl-functions-for-shadow-st.patch |  67 ++++-----
 ...Kconfig-option-for-user-mode-Indirec.patch |  12 +-
 ...-mode-Indirect-Branch-Tracking-suppo.patch |  22 +--
 ...le-signals-for-Indirect-Branch-Track.patch |  28 ++--
 ...header-parsing-for-Indirect-Branch-T.patch |  12 +-
 ...arch_prctl-functions-for-Indirect-Br.patch |  29 ++--
 ...x86-cet-Add-PTRACE-interface-for-CET.patch |  26 ++--
 ...ENDBR32-to-__kernel_vsyscall-entry-p.patch |   6 +-
 ...-vdso-Insert-endbr32-endbr64-to-vDSO.patch |   6 +-
 ...yscall-emulation-when-CET-is-enabled.patch |   8 +-
 ...la-sections-when-CONFIG_RELOCATABLE-.patch |  56 +++++++
 ...u.property-sections-in-generic-NOTES.patch |   6 +-
 kernel.spec                                   |  67 +++++----
 48 files changed, 623 insertions(+), 544 deletions(-)
 rename 0020-x86-mm-Update-pte_modify-and-pmd_modify-for-_PAGE_CO.patch => 0020-x86-mm-Update-pte_modify-for-_PAGE_COW.patch (76%)
 rename 0022-mm-Introduce-VM_SHSTK-for-Shadow-Stack-memory.patch => 0022-mm-Introduce-VM_SHSTK-for-shadow-stack-memory.patch (92%)
 rename 0024-x86-mm-Update-is_cow_mapping-and-maybe_mkwrite-for-s.patch => 0024-x86-mm-Update-maybe_mkwrite-for-shadow-stack.patch (57%)
 rename 0025-mm-Update-do_anonymous_page-and-do_numa_page.patch => 0025-mm-Fixup-places-that-call-pte_mkwrite-directly.patch (50%)
 rename 0027-x86-mm-Add-guard-pages-around-a-Shadow-Stack.patch => 0026-mm-Add-guard-pages-around-a-shadow-stack.patch (79%)
 rename 0028-mm-mmap-Add-Shadow-Stack-pages-to-memory-accounting.patch => 0027-mm-mmap-Add-shadow-stack-pages-to-memory-accounting.patch (74%)
 rename 0026-mm-Update-can_follow_write_pte-for-Shadow-Stack.patch => 0028-mm-Update-can_follow_write_pte-for-shadow-stack.patch (74%)
 rename 0029-x86-cet-shstk-User-mode-Shadow-Stack-support.patch => 0029-x86-cet-shstk-User-mode-shadow-stack-support.patch (95%)
 rename 0030-x86-cet-shstk-Handle-signals-for-Shadow-Stack.patch => 0030-x86-cet-shstk-Handle-signals-for-shadow-stack.patch (79%)
 rename 0034-x86-cet-shstk-ELF-header-parsing-for-Shadow-Stack.patch => 0034-x86-cet-shstk-ELF-header-parsing-for-shadow-stack.patch (90%)
 rename 0035-x86-cet-shstk-Handle-thread-Shadow-Stack.patch => 0035-x86-cet-shstk-Handle-thread-shadow-stack.patch (77%)
 rename 0036-x86-cet-shstk-Add-arch_prctl-functions-for-Shadow-St.patch => 0036-x86-cet-shstk-Add-arch_prctl-functions-for-shadow-st.patch (80%)
 rename 0044-x86-vdso-32-Add-ENDBR32-to-__kernel_vsyscall-entry-p.patch => 0043-x86-vdso-32-Add-ENDBR32-to-__kernel_vsyscall-entry-p.patch (86%)
 rename 0045-x86-vdso-Insert-endbr32-endbr64-to-vDSO.patch => 0044-x86-vdso-Insert-endbr32-endbr64-to-vDSO.patch (89%)
 rename 0046-x86-Disallow-vsyscall-emulation-when-CET-is-enabled.patch => 0045-x86-Disallow-vsyscall-emulation-when-CET-is-enabled.patch (90%)
 create mode 100644 0046-powerpc-Keep-.rela-sections-when-CONFIG_RELOCATABLE-.patch
 rename 0043-Discard-.note.gnu.property-sections-in-generic-NOTES.patch => 0047-Discard-.note.gnu.property-sections-in-generic-NOTES.patch (94%)

diff --git a/0001-x86-fpu-xstate-Rename-validate_xstate_header-to-vali.patch b/0001-x86-fpu-xstate-Rename-validate_xstate_header-to-vali.patch
index c39bfe78f..d4e837e14 100644
--- a/0001-x86-fpu-xstate-Rename-validate_xstate_header-to-vali.patch
+++ b/0001-x86-fpu-xstate-Rename-validate_xstate_header-to-vali.patch
@@ -1,7 +1,7 @@
-From d0dd3ca22227bbe2b8ff8500aebe16665527faf7 Mon Sep 17 00:00:00 2001
+From f553a0ef0d589641cfb9a441eb82d41ae0f4a5c4 Mon Sep 17 00:00:00 2001
 From: Fenghua Yu <fenghua.yu@intel.com>
 Date: Wed, 13 Dec 2017 16:08:28 -0800
-Subject: [PATCH 01/46] x86/fpu/xstate: Rename validate_xstate_header() to
+Subject: [PATCH 01/47] x86/fpu/xstate: Rename validate_xstate_header() to
  validate_user_xstate_header()
 
 The function validate_xstate_header() validates an xstate header coming
@@ -94,5 +94,5 @@ index 32b153d38748..8ed64397c78b 100644
  
  	for (i = 0; i < XFEATURE_MAX; i++) {
 -- 
-2.26.1
+2.26.2
 
diff --git a/0002-x86-fpu-xstate-Define-new-macros-for-supervisor-and-.patch b/0002-x86-fpu-xstate-Define-new-macros-for-supervisor-and-.patch
index 09d8a884e..5648394ba 100644
--- a/0002-x86-fpu-xstate-Define-new-macros-for-supervisor-and-.patch
+++ b/0002-x86-fpu-xstate-Define-new-macros-for-supervisor-and-.patch
@@ -1,7 +1,7 @@
-From 736f1e23d3c53f356a05c0d3c483a6b6fb412992 Mon Sep 17 00:00:00 2001
+From fd5e637da4fac8991d16b2e654c1921444e05e36 Mon Sep 17 00:00:00 2001
 From: Fenghua Yu <fenghua.yu@intel.com>
 Date: Thu, 10 Nov 2016 10:13:56 -0800
-Subject: [PATCH 02/46] x86/fpu/xstate: Define new macros for supervisor and
+Subject: [PATCH 02/47] x86/fpu/xstate: Define new macros for supervisor and
  user xstates
 
 XCNTXT_MASK is 'all supported xfeatures' before introducing supervisor
@@ -180,5 +180,5 @@ index 8ed64397c78b..9997df717339 100644
  	/*
  	 * Add back in the features that came in from userspace:
 -- 
-2.26.1
+2.26.2
 
diff --git a/0003-x86-fpu-xstate-Separate-user-and-supervisor-xfeature.patch b/0003-x86-fpu-xstate-Separate-user-and-supervisor-xfeature.patch
index a97134b92..41419455f 100644
--- a/0003-x86-fpu-xstate-Separate-user-and-supervisor-xfeature.patch
+++ b/0003-x86-fpu-xstate-Separate-user-and-supervisor-xfeature.patch
@@ -1,7 +1,7 @@
-From d336c82158e8051ef7c3769c09a1a88475899560 Mon Sep 17 00:00:00 2001
+From ae1c4634f360e27999c347af6b18eaa835ffe5a1 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Wed, 13 Dec 2017 16:08:28 -0800
-Subject: [PATCH 03/46] x86/fpu/xstate: Separate user and supervisor xfeatures
+Subject: [PATCH 03/47] x86/fpu/xstate: Separate user and supervisor xfeatures
  mask
 
 Before the introduction of XSAVES supervisor states, 'xfeatures_mask' is
@@ -349,5 +349,5 @@ index 9997df717339..fa71af643025 100644
  	/*
  	 * Copy xregs_state->header:
 -- 
-2.26.1
+2.26.2
 
diff --git a/0004-x86-fpu-xstate-Introduce-XSAVES-supervisor-states.patch b/0004-x86-fpu-xstate-Introduce-XSAVES-supervisor-states.patch
index cc7c943a7..e9dda37e7 100644
--- a/0004-x86-fpu-xstate-Introduce-XSAVES-supervisor-states.patch
+++ b/0004-x86-fpu-xstate-Introduce-XSAVES-supervisor-states.patch
@@ -1,7 +1,7 @@
-From 2c3c6fbdb39595c0ca944b8390bce25a4fb3c639 Mon Sep 17 00:00:00 2001
+From 38a61047cc8404c72f9e18a0e24b7c8aeecf714f Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Thu, 10 Nov 2016 10:13:56 -0800
-Subject: [PATCH 04/46] x86/fpu/xstate: Introduce XSAVES supervisor states
+Subject: [PATCH 04/47] x86/fpu/xstate: Introduce XSAVES supervisor states
 
 Enable XSAVES supervisor states by setting MSR_IA32_XSS bits according to
 CPUID enumeration results.  Also revise comments at various places.
@@ -81,5 +81,5 @@ index fa71af643025..a68213ed5be6 100644
  
  /*
 -- 
-2.26.1
+2.26.2
 
diff --git a/0005-x86-fpu-xstate-Define-new-functions-for-clearing-fpr.patch b/0005-x86-fpu-xstate-Define-new-functions-for-clearing-fpr.patch
index 700abdaf3..f28e6d34a 100644
--- a/0005-x86-fpu-xstate-Define-new-functions-for-clearing-fpr.patch
+++ b/0005-x86-fpu-xstate-Define-new-functions-for-clearing-fpr.patch
@@ -1,7 +1,7 @@
-From f96afa328e2fe1975eefb44bfb36e0b1a1d3301e Mon Sep 17 00:00:00 2001
+From 9b9e9bbbf5db49a9c1c514da05d58d4374409718 Mon Sep 17 00:00:00 2001
 From: Fenghua Yu <fenghua.yu@intel.com>
 Date: Thu, 10 Nov 2016 10:13:56 -0800
-Subject: [PATCH 05/46] x86/fpu/xstate: Define new functions for clearing
+Subject: [PATCH 05/47] x86/fpu/xstate: Define new functions for clearing
  fpregs and xstates
 
 Currently, fpu__clear() clears all fpregs and xstates.  Once XSAVES
@@ -178,5 +178,5 @@ index 83b74fb38c8f..0052bbe5dfd4 100644
  	signal_setup_done(failed, ksig, stepping);
  }
 -- 
-2.26.1
+2.26.2
 
diff --git a/0006-x86-fpu-xstate-Update-sanitize_restored_xstate-for-s.patch b/0006-x86-fpu-xstate-Update-sanitize_restored_xstate-for-s.patch
index b1c2e3b3e..11a52ec99 100644
--- a/0006-x86-fpu-xstate-Update-sanitize_restored_xstate-for-s.patch
+++ b/0006-x86-fpu-xstate-Update-sanitize_restored_xstate-for-s.patch
@@ -1,7 +1,7 @@
-From fd92d8b54bc60d0e680301a1acb1cd90d4c7fa50 Mon Sep 17 00:00:00 2001
+From 0b85cfbf2c48b351243bbbcc266bcbccea8e3b81 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 12 Nov 2019 09:09:10 -0800
-Subject: [PATCH 06/46] x86/fpu/xstate: Update sanitize_restored_xstate() for
+Subject: [PATCH 06/47] x86/fpu/xstate: Update sanitize_restored_xstate() for
  supervisor xstates
 
 The function sanitize_restored_xstate() sanitizes user xstates of an XSAVE
@@ -133,5 +133,5 @@ index cd6eafba12da..d09d72334a12 100644
  		fpregs_lock();
  		if (use_xsave()) {
 -- 
-2.26.1
+2.26.2
 
diff --git a/0007-x86-fpu-xstate-Update-copy_kernel_to_xregs_err-for-X.patch b/0007-x86-fpu-xstate-Update-copy_kernel_to_xregs_err-for-X.patch
index d2b874080..16b5d3c22 100644
--- a/0007-x86-fpu-xstate-Update-copy_kernel_to_xregs_err-for-X.patch
+++ b/0007-x86-fpu-xstate-Update-copy_kernel_to_xregs_err-for-X.patch
@@ -1,7 +1,7 @@
-From eef73dcb50a2407de922ef8e8f65a34cfa8de5e6 Mon Sep 17 00:00:00 2001
+From c101a20b303a6958624c6e2830308fc3bcd1e1a3 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 29 Oct 2019 12:42:06 -0700
-Subject: [PATCH 07/46] x86/fpu/xstate: Update copy_kernel_to_xregs_err() for
+Subject: [PATCH 07/47] x86/fpu/xstate: Update copy_kernel_to_xregs_err() for
  XSAVES supervisor states
 
 The function copy_kernel_to_xregs_err() uses XRSTOR, which can work with
@@ -43,5 +43,5 @@ index a42fcb4b690d..42159f45bf9c 100644
  	return err;
  }
 -- 
-2.26.1
+2.26.2
 
diff --git a/0008-x86-fpu-Introduce-copy_supervisor_to_kernel.patch b/0008-x86-fpu-Introduce-copy_supervisor_to_kernel.patch
index e047401ef..fac0a6efa 100644
--- a/0008-x86-fpu-Introduce-copy_supervisor_to_kernel.patch
+++ b/0008-x86-fpu-Introduce-copy_supervisor_to_kernel.patch
@@ -1,7 +1,7 @@
-From 4b53db43eb933b3af205a891511c37f9835cdfa4 Mon Sep 17 00:00:00 2001
+From 2c61ab4deb08a35437041ddb5d69b79c04695b62 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Mon, 16 Mar 2020 10:29:12 -0700
-Subject: [PATCH 08/46] x86/fpu: Introduce copy_supervisor_to_kernel()
+Subject: [PATCH 08/47] x86/fpu: Introduce copy_supervisor_to_kernel()
 
 The XSAVES instruction takes a mask and saves only the features specified
 in that mask.  The kernel normally specifies that all features be saved.
@@ -150,5 +150,5 @@ index a68213ed5be6..587e03f0094d 100644
  /*
   * Report the amount of time elapsed in millisecond since last AVX512
 -- 
-2.26.1
+2.26.2
 
diff --git a/0009-x86-fpu-xstate-Preserve-supervisor-states-for-slow-p.patch b/0009-x86-fpu-xstate-Preserve-supervisor-states-for-slow-p.patch
index cbc88336f..b2d5e65f7 100644
--- a/0009-x86-fpu-xstate-Preserve-supervisor-states-for-slow-p.patch
+++ b/0009-x86-fpu-xstate-Preserve-supervisor-states-for-slow-p.patch
@@ -1,7 +1,7 @@
-From 69fddb3e15935dec61ce57dd4220a751dd9ab805 Mon Sep 17 00:00:00 2001
+From c57db4a5052c27e4ec86232e35470edbf0905d80 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 29 Oct 2019 13:03:10 -0700
-Subject: [PATCH 09/46] x86/fpu/xstate: Preserve supervisor states for slow
+Subject: [PATCH 09/47] x86/fpu/xstate: Preserve supervisor states for slow
  path of __fpu__restore_sig()
 
 The signal return code is responsible for taking an XSAVE buffer present
@@ -135,5 +135,5 @@ index d09d72334a12..545ca4314096 100644
  	if (use_xsave() && !fx_only) {
  		u64 init_bv = xfeatures_mask_user() & ~user_xfeatures;
 -- 
-2.26.1
+2.26.2
 
diff --git a/0010-x86-fpu-xstate-Restore-supervisor-states-for-signal-.patch b/0010-x86-fpu-xstate-Restore-supervisor-states-for-signal-.patch
index baae796b3..7726e107f 100644
--- a/0010-x86-fpu-xstate-Restore-supervisor-states-for-signal-.patch
+++ b/0010-x86-fpu-xstate-Restore-supervisor-states-for-signal-.patch
@@ -1,7 +1,7 @@
-From 7ff5712cee8e7ba8913cae898582ed0aa11ea256 Mon Sep 17 00:00:00 2001
+From 7eb433524e29ddb7143ed2d397e6d45233af68da Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Fri, 27 Mar 2020 09:42:02 -0700
-Subject: [PATCH 10/46] x86/fpu/xstate: Restore supervisor states for signal
+Subject: [PATCH 10/47] x86/fpu/xstate: Restore supervisor states for signal
  return
 
 As described in the previous patch, the signal return fast path directly
@@ -108,5 +108,5 @@ index 545ca4314096..4dad5afc938d 100644
  	} else if (use_fxsr()) {
  		ret = __copy_from_user(&fpu->state.fxsave, buf_fx, state_size);
 -- 
-2.26.1
+2.26.2
 
diff --git a/0011-Documentation-x86-Add-CET-description.patch b/0011-Documentation-x86-Add-CET-description.patch
index d9eee183b..adf447d6d 100644
--- a/0011-Documentation-x86-Add-CET-description.patch
+++ b/0011-Documentation-x86-Add-CET-description.patch
@@ -1,11 +1,14 @@
-From 7f01ce5e8cdb2b5e23b60f31657fabf8cb6eb479 Mon Sep 17 00:00:00 2001
+From 9ddde2fd720f3c6128bc02cbc50fcfacdd38b13b Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Sun, 17 Dec 2017 09:09:23 -0800
-Subject: [PATCH 11/46] Documentation/x86: Add CET description
+Subject: [PATCH 11/47] Documentation/x86: Add CET description
 
 Explain no_user_shstk/no_user_ibt kernel parameters, and introduce a new
 document on Control-flow Enforcement Technology (CET).
 
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
+Reviewed-by: Kees Cook <keescook@chromium.org>
+
 v10:
 - Change no_cet_shstk and no_cet_ibt to no_user_shstk and no_user_ibt.
 - Remove the opcode section, as it is already in the Intel SDM.
@@ -15,9 +18,6 @@ v10:
 - Remove legacy bitmap related information, as it is not supported now.
 - Fix arch_ioctl() related text.
 - Change SHSTK, IBT to plain English.
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Kees Cook <keescook@chromium.org>
 ---
  .../admin-guide/kernel-parameters.txt         |   6 +
  Documentation/x86/index.rst                   |   1 +
@@ -26,7 +26,7 @@ Reviewed-by: Kees Cook <keescook@chromium.org>
  create mode 100644 Documentation/x86/intel_cet.rst
 
 diff --git a/Documentation/admin-guide/kernel-parameters.txt b/Documentation/admin-guide/kernel-parameters.txt
-index f2a93c8679e8..1727de3435c6 100644
+index 7bc83f3d9bdf..be715675df6d 100644
 --- a/Documentation/admin-guide/kernel-parameters.txt
 +++ b/Documentation/admin-guide/kernel-parameters.txt
 @@ -3093,6 +3093,12 @@
@@ -190,5 +190,5 @@ index 000000000000..746eda8c82f3
 +When a pthread child is created, the kernel allocates a new shadow stack
 +for the new thread.
 -- 
-2.26.1
+2.26.2
 
diff --git a/0012-x86-cpufeatures-Add-CET-CPU-feature-flags-for-Contro.patch b/0012-x86-cpufeatures-Add-CET-CPU-feature-flags-for-Contro.patch
index 56224e474..6cd528c38 100644
--- a/0012-x86-cpufeatures-Add-CET-CPU-feature-flags-for-Contro.patch
+++ b/0012-x86-cpufeatures-Add-CET-CPU-feature-flags-for-Contro.patch
@@ -1,7 +1,7 @@
-From b0b472e3b037101c01aee284c306550e97483a8c Mon Sep 17 00:00:00 2001
+From cf3f9d0a44b599c3ee997db579daaae2676d2a9c Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Wed, 9 Nov 2016 16:26:37 -0800
-Subject: [PATCH 12/46] x86/cpufeatures: Add CET CPU feature flags for
+Subject: [PATCH 12/47] x86/cpufeatures: Add CET CPU feature flags for
  Control-flow Enforcement Technology (CET)
 
 Add CPU feature flags for Control-flow Enforcement Technology (CET).
@@ -51,5 +51,5 @@ index 3cbe24ca80ab..fec83cc74b9e 100644
  };
  
 -- 
-2.26.1
+2.26.2
 
diff --git a/0013-x86-fpu-xstate-Introduce-CET-MSR-XSAVES-supervisor-s.patch b/0013-x86-fpu-xstate-Introduce-CET-MSR-XSAVES-supervisor-s.patch
index 146bb207e..4c6a80819 100644
--- a/0013-x86-fpu-xstate-Introduce-CET-MSR-XSAVES-supervisor-s.patch
+++ b/0013-x86-fpu-xstate-Introduce-CET-MSR-XSAVES-supervisor-s.patch
@@ -1,7 +1,7 @@
-From dbe1258b8e7b344ba57e00bffb86c21948330315 Mon Sep 17 00:00:00 2001
+From 5af647a00c24ddeed4f9d4f95d9dfeabd206a7d7 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Thu, 10 Nov 2016 10:13:56 -0800
-Subject: [PATCH 13/46] x86/fpu/xstate: Introduce CET MSR XSAVES supervisor
+Subject: [PATCH 13/47] x86/fpu/xstate: Introduce CET MSR XSAVES supervisor
  states
 
 Control-flow Enforcement Technology (CET) adds five MSRs.  Introduce them
@@ -13,11 +13,11 @@ and their XSAVES supervisor states:
     MSR_IA32_PL1_SSP (Privilege Level 1 Shadow Stack pointer),
     MSR_IA32_PL2_SSP (Privilege Level 2 Shadow Stack pointer).
 
-v6:
-- Remove __packed from struct cet_user_state, struct cet_kernel_state.
-
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Reviewed-by: Kees Cook <keescook@chromium.org>
+
+v6:
+- Remove __packed from struct cet_user_state, struct cet_kernel_state.
 ---
  arch/x86/include/asm/fpu/types.h            | 22 ++++++++++++++++++
  arch/x86/include/asm/fpu/xstate.h           |  5 +++--
@@ -199,5 +199,5 @@ index 587e03f0094d..7c7be482e6f3 100644
  
  	xfeatures_mask_all &= fpu__get_supported_xfeatures_mask();
 -- 
-2.26.1
+2.26.2
 
diff --git a/0014-x86-cet-Add-control-protection-fault-handler.patch b/0014-x86-cet-Add-control-protection-fault-handler.patch
index c60ec2aa4..da20ba782 100644
--- a/0014-x86-cet-Add-control-protection-fault-handler.patch
+++ b/0014-x86-cet-Add-control-protection-fault-handler.patch
@@ -1,7 +1,7 @@
-From a75f840a57683a1b1f1465c4d809d8764a28ee9f Mon Sep 17 00:00:00 2001
+From 3ba6585c450076b395252edbc4bf40172b9d801f Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Thu, 10 Nov 2016 13:17:46 -0800
-Subject: [PATCH 14/46] x86/cet: Add control-protection fault handler
+Subject: [PATCH 14/47] x86/cet: Add control-protection fault handler
 
 A control-protection fault is triggered when a control-flow transfer
 attempt violates Shadow Stack or Indirect Branch Tracking constraints.
@@ -13,14 +13,14 @@ The control-protection fault handler works in a similar way as the general
 protection fault handler.  It provides the si_code SEGV_CPERR to the signal
 handler.
 
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
+Reviewed-by: Kees Cook <keescook@chromium.org>
+
 v10:
 - Change CONFIG_X86_64 to CONFIG_X86_INTEL_CET.
 
 v9:
 - Add Shadow Stack pointer to the fault printout.
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Kees Cook <keescook@chromium.org>
 ---
  arch/x86/entry/entry_64.S          |  2 +-
  arch/x86/include/asm/traps.h       |  5 +++
@@ -186,5 +186,5 @@ index cb3d6c267181..693071dbe641 100644
  /*
   * SIGBUS si_codes
 -- 
-2.26.1
+2.26.2
 
diff --git a/0015-x86-cet-shstk-Add-Kconfig-option-for-user-mode-Shado.patch b/0015-x86-cet-shstk-Add-Kconfig-option-for-user-mode-Shado.patch
index c728a7d92..9c07edc14 100644
--- a/0015-x86-cet-shstk-Add-Kconfig-option-for-user-mode-Shado.patch
+++ b/0015-x86-cet-shstk-Add-Kconfig-option-for-user-mode-Shado.patch
@@ -1,7 +1,7 @@
-From 64a9c2a4a6ab29196b09dade489f3cd2f2666d65 Mon Sep 17 00:00:00 2001
+From fd6f0a0a21ef88571c92dbc2a0a4d7b5eca2f8fb Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 3 Oct 2017 12:55:03 -0700
-Subject: [PATCH 15/46] x86/cet/shstk: Add Kconfig option for user-mode Shadow
+Subject: [PATCH 15/47] x86/cet/shstk: Add Kconfig option for user-mode Shadow
  Stack
 
 Shadow Stack provides protection against function return address
@@ -11,24 +11,23 @@ feature.  This is only implemented for the 64-bit kernel.  When it is
 enabled, legacy non-shadow stack applications continue to work, but without
 protection.
 
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
+
 v10:
 - Change SHSTK to shadow stack in the help text.
 - Change build-time check to config-time check.
 - Change ARCH_HAS_SHSTK to ARCH_HAS_SHADOW_STACK.
-- Add ARCH_HAS_COW_MAPPING.
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 ---
- arch/x86/Kconfig                      | 34 +++++++++++++++++++++++++++
+ arch/x86/Kconfig                      | 30 +++++++++++++++++++++++++++
  scripts/as-x86_64-has-shadow-stack.sh |  4 ++++
- 2 files changed, 38 insertions(+)
+ 2 files changed, 34 insertions(+)
  create mode 100755 scripts/as-x86_64-has-shadow-stack.sh
 
 diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
-index 1d6104ea8af0..5a598741da67 100644
+index 1197b5596d5a..c98f82fffe85 100644
 --- a/arch/x86/Kconfig
 +++ b/arch/x86/Kconfig
-@@ -1947,6 +1947,40 @@ config X86_INTEL_TSX_MODE_AUTO
+@@ -1947,6 +1947,36 @@ config X86_INTEL_TSX_MODE_AUTO
  	  side channel attacks- equals the tsx=auto command line parameter.
  endchoice
  
@@ -40,9 +39,6 @@ index 1d6104ea8af0..5a598741da67 100644
 +config X86_INTEL_CET
 +	def_bool n
 +
-+config ARCH_HAS_COW_MAPPING
-+	def_bool n
-+
 +config ARCH_HAS_SHADOW_STACK
 +	def_bool n
 +
@@ -53,7 +49,6 @@ index 1d6104ea8af0..5a598741da67 100644
 +	depends on AS_HAS_SHADOW_STACK
 +	select ARCH_USES_HIGH_VMA_FLAGS
 +	select X86_INTEL_CET
-+	select ARCH_HAS_COW_MAPPING
 +	select ARCH_HAS_SHADOW_STACK
 +	help
 +	  Shadow Stacks provides protection against program stack
@@ -80,5 +75,5 @@ index 000000000000..fac1d363a1b8
 +
 +echo "wrussq %rax, (%rbx)" | $* -x assembler -c -
 -- 
-2.26.1
+2.26.2
 
diff --git a/0016-x86-mm-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_HW.patch b/0016-x86-mm-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_HW.patch
index 7c318658f..21778a23f 100644
--- a/0016-x86-mm-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_HW.patch
+++ b/0016-x86-mm-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_HW.patch
@@ -1,22 +1,22 @@
-From 629a765ef18915c8e0ee4ce849b555e3ae6e0c53 Mon Sep 17 00:00:00 2001
+From caf3659fd970ce24ecc98984b7b31847d761e5e6 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Thu, 12 Apr 2018 09:32:59 -0700
-Subject: [PATCH 16/46] x86/mm: Change _PAGE_DIRTY to _PAGE_DIRTY_HW
+Subject: [PATCH 16/47] x86/mm: Change _PAGE_DIRTY to _PAGE_DIRTY_HW
 
 Before introducing _PAGE_COW for non-hardware memory management purposes in
 the next patch, rename _PAGE_DIRTY to _PAGE_DIRTY_HW and _PAGE_BIT_DIRTY to
 _PAGE_BIT_DIRTY_HW to make meanings more clear.  There are no functional
 changes from this patch.
 
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
+Reviewed-by: Kees Cook <keescook@chromium.org>
+Reviewed-by: Dave Hansen <dave.hansen@intel.com>
+
 v9:
 - At some places _PAGE_DIRTY were not changed to _PAGE_DIRTY_HW, because
   they will be changed again in the next patch to _PAGE_DIRTY_BITS.
   However, this causes compile issues if the next patch is not yet applied.
   Fix it by changing all _PAGE_DIRTY to _PAGE_DRITY_HW.
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Kees Cook <keescook@chromium.org>
-Reviewed-by: Dave Hansen <dave.hansen@intel.com>
 ---
  arch/x86/include/asm/pgtable.h       | 18 +++++++++---------
  arch/x86/include/asm/pgtable_types.h | 11 +++++------
@@ -180,7 +180,7 @@ index a4d9a261425b..e3bb4ff95523 100644
  /*
   * control_page + KEXEC_CONTROL_CODE_MAX_SIZE
 diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.c
-index 83050977490c..c24ecbb9aebd 100644
+index c2c6335a998c..d52d470e36b1 100644
 --- a/arch/x86/kvm/vmx/vmx.c
 +++ b/arch/x86/kvm/vmx/vmx.c
 @@ -3501,7 +3501,7 @@ static int init_rmode_identity_map(struct kvm *kvm)
@@ -193,5 +193,5 @@ index 83050977490c..c24ecbb9aebd 100644
  				&tmp, i * sizeof(tmp), sizeof(tmp));
  		if (r < 0)
 -- 
-2.26.1
+2.26.2
 
diff --git a/0017-x86-mm-Remove-_PAGE_DIRTY_HW-from-kernel-RO-pages.patch b/0017-x86-mm-Remove-_PAGE_DIRTY_HW-from-kernel-RO-pages.patch
index 0b5c1fe76..12aa656d9 100644
--- a/0017-x86-mm-Remove-_PAGE_DIRTY_HW-from-kernel-RO-pages.patch
+++ b/0017-x86-mm-Remove-_PAGE_DIRTY_HW-from-kernel-RO-pages.patch
@@ -1,20 +1,20 @@
-From 55aef37d468c2e18f5cc75265b5fea11f587de4a Mon Sep 17 00:00:00 2001
+From 4b55d512cf545ccf2a3593d9de87f56691b74784 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 14 Apr 2020 14:48:14 -0700
-Subject: [PATCH 17/46] x86/mm: Remove _PAGE_DIRTY_HW from kernel RO pages
+Subject: [PATCH 17/47] x86/mm: Remove _PAGE_DIRTY_HW from kernel RO pages
 
 Kernel read-only PTEs are setup as _PAGE_DIRTY_HW.  Since these become
 shadow stack PTEs, remove the dirty bit.
 
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Cc: Thomas Gleixner <tglx@linutronix.de>
-Cc: Ingo Molnar <mingo@redhat.com>
-Cc: Borislav Petkov <bp@alien8.de>
 Cc: "H. Peter Anvin" <hpa@zytor.com>
+Cc: Kees Cook <keescook@chromium.org>
+Cc: Thomas Gleixner <tglx@linutronix.de>
 Cc: Dave Hansen <dave.hansen@linux.intel.com>
 Cc: Andy Lutomirski <luto@kernel.org>
+Cc: Ingo Molnar <mingo@redhat.com>
+Cc: Borislav Petkov <bp@alien8.de>
 Cc: Peter Zijlstra <peterz@infradead.org>
-Cc: Kees Cook <keescook@chromium.org>
 ---
  arch/x86/include/asm/pgtable_types.h | 6 +++---
  arch/x86/mm/pat/set_memory.c         | 2 +-
@@ -52,5 +52,5 @@ index 59eca6a94ce7..87751b7e2131 100644
  
  int set_memory_rw(unsigned long addr, int numpages)
 -- 
-2.26.1
+2.26.2
 
diff --git a/0018-x86-mm-Introduce-_PAGE_COW.patch b/0018-x86-mm-Introduce-_PAGE_COW.patch
index e3b3cb8b6..e8487b23a 100644
--- a/0018-x86-mm-Introduce-_PAGE_COW.patch
+++ b/0018-x86-mm-Introduce-_PAGE_COW.patch
@@ -1,7 +1,7 @@
-From dc6d34ad649835234a09635b2557014c241f5e74 Mon Sep 17 00:00:00 2001
+From 93d1d825020671c51454524726b2fb2799ca2d96 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Wed, 24 Jan 2018 10:27:13 -0800
-Subject: [PATCH 18/46] x86/mm: Introduce _PAGE_COW
+Subject: [PATCH 18/47] x86/mm: Introduce _PAGE_COW
 
 There is essentially no room left in the x86 hardware PTEs on some OSes
 (not Linux).  That left the hardware architects looking for a way to
@@ -41,11 +41,15 @@ When this patch is applied, there are six free bits left in the 64-bit PTE.
 There are no more free bits in the 32-bit PTE (except for PAE) and shadow
 stack is not implemented for the 32-bit kernel.
 
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
+Reviewed-by: Kees Cook <keescook@chromium.org>
+
 v10:
 - Change _PAGE_BIT_DIRTY_SW to _PAGE_BIT_COW, as it is used for copy-on-
   write PTEs.
 - Update pte_write() and treat shadow stack as writable.
-- Use bit test & shifts for moving _PAGE_BIT_DIRTY_HW to _PAGE_BIT_COW.
+- Change *_mkdirty_shstk() to *_mkwrite_shstk().
+- Use bit test & shift to move _PAGE_BIT_DIRTY_HW to _PAGE_BIT_COW.
 - Change static_cpu_has() to cpu_feature_enabled().
 - Revise commit log.
 
@@ -55,16 +59,13 @@ v9:
 - Change compile-time conditionals to run-time checks.
 - Split out pte_modify()/pmd_modify() to a new patch.
 - Update comments.
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Kees Cook <keescook@chromium.org>
 ---
- arch/x86/include/asm/pgtable.h       | 120 ++++++++++++++++++++++++---
- arch/x86/include/asm/pgtable_types.h |  37 ++++++++-
- 2 files changed, 145 insertions(+), 12 deletions(-)
+ arch/x86/include/asm/pgtable.h       | 121 ++++++++++++++++++++++++---
+ arch/x86/include/asm/pgtable_types.h |  41 ++++++++-
+ 2 files changed, 150 insertions(+), 12 deletions(-)
 
 diff --git a/arch/x86/include/asm/pgtable.h b/arch/x86/include/asm/pgtable.h
-index 90f9a73881ad..fd03ed24ef65 100644
+index 90f9a73881ad..11bd5f223ff3 100644
 --- a/arch/x86/include/asm/pgtable.h
 +++ b/arch/x86/include/asm/pgtable.h
 @@ -122,12 +122,11 @@ extern pmdval_t early_pmd_flags;
@@ -128,7 +129,7 @@ index 90f9a73881ad..fd03ed24ef65 100644
  }
  
  static inline pte_t pte_mkold(pte_t pte)
-@@ -343,6 +348,18 @@ static inline pte_t pte_mkold(pte_t pte)
+@@ -343,6 +348,17 @@ static inline pte_t pte_mkold(pte_t pte)
  
  static inline pte_t pte_wrprotect(pte_t pte)
  {
@@ -137,8 +138,7 @@ index 90f9a73881ad..fd03ed24ef65 100644
 +	 * a shadow stack PTE (RW=0,Dirty=1).  Move the hardware
 +	 * dirty value to the software bit.
 +	 */
-+	if (cpu_feature_enabled(X86_FEATURE_SHSTK) &&
-+	    (BITS_PER_BYTE *sizeof(pte) > _PAGE_BIT_COW)) {
++	if (cpu_feature_enabled(X86_FEATURE_SHSTK)) {
 +		pte.pte |= (pte.pte & _PAGE_DIRTY_HW) >>
 +			   _PAGE_BIT_DIRTY_HW << _PAGE_BIT_COW;
 +		pte = pte_clear_flags(pte, _PAGE_DIRTY_HW);
@@ -147,7 +147,7 @@ index 90f9a73881ad..fd03ed24ef65 100644
  	return pte_clear_flags(pte, _PAGE_RW);
  }
  
-@@ -353,6 +370,18 @@ static inline pte_t pte_mkexec(pte_t pte)
+@@ -353,6 +369,18 @@ static inline pte_t pte_mkexec(pte_t pte)
  
  static inline pte_t pte_mkdirty(pte_t pte)
  {
@@ -160,13 +160,13 @@ index 90f9a73881ad..fd03ed24ef65 100644
 +	return pte_set_flags(pte, dirty | _PAGE_SOFT_DIRTY);
 +}
 +
-+static inline pte_t pte_mkdirty_shstk(pte_t pte)
++static inline pte_t pte_mkwrite_shstk(pte_t pte)
 +{
 +	pte = pte_clear_flags(pte, _PAGE_COW);
  	return pte_set_flags(pte, _PAGE_DIRTY_HW | _PAGE_SOFT_DIRTY);
  }
  
-@@ -363,6 +392,13 @@ static inline pte_t pte_mkyoung(pte_t pte)
+@@ -363,6 +391,13 @@ static inline pte_t pte_mkyoung(pte_t pte)
  
  static inline pte_t pte_mkwrite(pte_t pte)
  {
@@ -180,7 +180,7 @@ index 90f9a73881ad..fd03ed24ef65 100644
  	return pte_set_flags(pte, _PAGE_RW);
  }
  
-@@ -434,16 +470,40 @@ static inline pmd_t pmd_mkold(pmd_t pmd)
+@@ -434,16 +469,41 @@ static inline pmd_t pmd_mkold(pmd_t pmd)
  
  static inline pmd_t pmd_mkclean(pmd_t pmd)
  {
@@ -195,11 +195,12 @@ index 90f9a73881ad..fd03ed24ef65 100644
 +	 * a shadow stack PMD (RW=0,Dirty=1).  Move the hardware
 +	 * dirty value to the software bit.
 +	 */
-+	if (cpu_feature_enabled(X86_FEATURE_SHSTK) &&
-+	    (BITS_PER_BYTE * sizeof(pmd) > _PAGE_BIT_COW)) {
-+		pmd.pmd |= (pmd.pmd & _PAGE_DIRTY_HW) >>
-+			   _PAGE_BIT_DIRTY_HW << _PAGE_BIT_COW;
-+		pmd = pmd_clear_flags(pmd, _PAGE_DIRTY_HW);
++	if (cpu_feature_enabled(X86_FEATURE_SHSTK)) {
++		pmdval_t v = native_pmd_val(pmd);
++
++		v |= (v & _PAGE_DIRTY_HW) >> _PAGE_BIT_DIRTY_HW <<
++		     _PAGE_BIT_COW;
++		pmd = pmd_clear_flags(__pmd(v), _PAGE_DIRTY_HW);
 +	}
 +
  	return pmd_clear_flags(pmd, _PAGE_RW);
@@ -216,7 +217,7 @@ index 90f9a73881ad..fd03ed24ef65 100644
 +	return pmd_set_flags(pmd, dirty | _PAGE_SOFT_DIRTY);
 +}
 +
-+static inline pmd_t pmd_mkdirty_shstk(pmd_t pmd)
++static inline pmd_t pmd_mkwrite_shstk(pmd_t pmd)
 +{
 +	pmd = pmd_clear_flags(pmd, _PAGE_COW);
  	return pmd_set_flags(pmd, _PAGE_DIRTY_HW | _PAGE_SOFT_DIRTY);
@@ -236,7 +237,7 @@ index 90f9a73881ad..fd03ed24ef65 100644
  	return pmd_set_flags(pmd, _PAGE_RW);
  }
  
-@@ -488,17 +555,35 @@ static inline pud_t pud_mkold(pud_t pud)
+@@ -488,17 +555,36 @@ static inline pud_t pud_mkold(pud_t pud)
  
  static inline pud_t pud_mkclean(pud_t pud)
  {
@@ -251,11 +252,12 @@ index 90f9a73881ad..fd03ed24ef65 100644
 +	 * a shadow stack PUD (RW=0,Dirty=1).  Move the hardware
 +	 * dirty value to the software bit.
 +	 */
-+	if (cpu_feature_enabled(X86_FEATURE_SHSTK) &&
-+	    (BITS_PER_BYTE * sizeof(pud) > _PAGE_BIT_COW)) {
-+		pud.pud |= (pud.pud & _PAGE_DIRTY_HW) >>
-+			   _PAGE_BIT_DIRTY_HW << _PAGE_BIT_COW;
-+		pud = pud_clear_flags(pud, _PAGE_DIRTY_HW);
++	if (cpu_feature_enabled(X86_FEATURE_SHSTK)) {
++		pudval_t v = native_pud_val(pud);
++
++		v |= (v & _PAGE_DIRTY_HW) >> _PAGE_BIT_DIRTY_HW <<
++		     _PAGE_BIT_COW;
++		pud = pud_clear_flags(__pud(v), _PAGE_DIRTY_HW);
 +	}
 +
  	return pud_clear_flags(pud, _PAGE_RW);
@@ -274,7 +276,7 @@ index 90f9a73881ad..fd03ed24ef65 100644
  }
  
  static inline pud_t pud_mkdevmap(pud_t pud)
-@@ -518,6 +603,13 @@ static inline pud_t pud_mkyoung(pud_t pud)
+@@ -518,6 +604,13 @@ static inline pud_t pud_mkyoung(pud_t pud)
  
  static inline pud_t pud_mkwrite(pud_t pud)
  {
@@ -288,7 +290,7 @@ index 90f9a73881ad..fd03ed24ef65 100644
  	return pud_set_flags(pud, _PAGE_RW);
  }
  
-@@ -1218,6 +1310,12 @@ extern int pmdp_clear_flush_young(struct vm_area_struct *vma,
+@@ -1218,6 +1311,12 @@ extern int pmdp_clear_flush_young(struct vm_area_struct *vma,
  #define pmd_write pmd_write
  static inline int pmd_write(pmd_t pmd)
  {
@@ -302,7 +304,7 @@ index 90f9a73881ad..fd03ed24ef65 100644
  }
  
 diff --git a/arch/x86/include/asm/pgtable_types.h b/arch/x86/include/asm/pgtable_types.h
-index 522b80b952f4..4fff9acf9c20 100644
+index 522b80b952f4..74229db078ce 100644
 --- a/arch/x86/include/asm/pgtable_types.h
 +++ b/arch/x86/include/asm/pgtable_types.h
 @@ -23,7 +23,8 @@
@@ -315,7 +317,7 @@ index 522b80b952f4..4fff9acf9c20 100644
  #define _PAGE_BIT_PKEY_BIT0	59	/* Protection Keys, bit 1/4 */
  #define _PAGE_BIT_PKEY_BIT1	60	/* Protection Keys, bit 2/4 */
  #define _PAGE_BIT_PKEY_BIT2	61	/* Protection Keys, bit 3/4 */
-@@ -36,6 +37,12 @@
+@@ -36,6 +37,16 @@
  #define _PAGE_BIT_SOFT_DIRTY	_PAGE_BIT_SOFTW3 /* software dirty tracking */
  #define _PAGE_BIT_DEVMAP	_PAGE_BIT_SOFTW4
  
@@ -323,12 +325,16 @@ index 522b80b952f4..4fff9acf9c20 100644
 + * This bit indicates a copy-on-write page, and is different from
 + * _PAGE_BIT_SOFT_DIRTY, which tracks which pages a task writes to.
 + */
++#ifdef CONFIG_X86_64
 +#define _PAGE_BIT_COW		_PAGE_BIT_SOFTW5 /* copy-on-write */
++#else
++#define _PAGE_BIT_COW		0
++#endif
 +
  /* If _PAGE_BIT_PRESENT is clear, we use these: */
  /* - if the user mapped it with PROT_NONE; pte_present gives true */
  #define _PAGE_BIT_PROTNONE	_PAGE_BIT_GLOBAL
-@@ -117,6 +124,34 @@
+@@ -117,6 +128,34 @@
  #define _PAGE_DEVMAP	(_AT(pteval_t, 0))
  #endif
  
@@ -364,5 +370,5 @@ index 522b80b952f4..4fff9acf9c20 100644
  
  /*
 -- 
-2.26.1
+2.26.2
 
diff --git a/0019-drm-i915-gvt-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_BITS.patch b/0019-drm-i915-gvt-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_BITS.patch
index 2f67768ae..60b8de0c1 100644
--- a/0019-drm-i915-gvt-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_BITS.patch
+++ b/0019-drm-i915-gvt-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_BITS.patch
@@ -1,20 +1,20 @@
-From 8dc377a603eeea9c0e39790f25a77a87a2479743 Mon Sep 17 00:00:00 2001
+From 88427bff1167889913116f2144ddcdd272997c27 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 28 Aug 2018 13:01:49 -0700
-Subject: [PATCH 19/46] drm/i915/gvt: Change _PAGE_DIRTY to _PAGE_DIRTY_BITS
+Subject: [PATCH 19/47] drm/i915/gvt: Change _PAGE_DIRTY to _PAGE_DIRTY_BITS
 
 After the introduction of _PAGE_COW, a modified page's PTE can have either
 _PAGE_DIRTY_HW or _PAGE_COW.  Change _PAGE_DIRTY to _PAGE_DIRTY_BITS.
 
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Reviewed-by: Kees Cook <keescook@chromium.org>
-Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
-Cc: Zhi Wang <zhi.a.wang@intel.com>
-Cc: Jani Nikula <jani.nikula@linux.intel.com>
-Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
-Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
 Cc: David Airlie <airlied@linux.ie>
+Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
+Cc: Jani Nikula <jani.nikula@linux.intel.com>
 Cc: Daniel Vetter <daniel@ffwll.ch>
+Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
+Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
+Cc: Zhi Wang <zhi.a.wang@intel.com>
 ---
  drivers/gpu/drm/i915/gvt/gtt.c | 2 +-
  1 file changed, 1 insertion(+), 1 deletion(-)
@@ -33,5 +33,5 @@ index 2a4b23f8aa74..789dce23424b 100644
  	ops->clear_pse(se);
  	ops->clear_ips(se);
 -- 
-2.26.1
+2.26.2
 
diff --git a/0020-x86-mm-Update-pte_modify-and-pmd_modify-for-_PAGE_CO.patch b/0020-x86-mm-Update-pte_modify-for-_PAGE_COW.patch
similarity index 76%
rename from 0020-x86-mm-Update-pte_modify-and-pmd_modify-for-_PAGE_CO.patch
rename to 0020-x86-mm-Update-pte_modify-for-_PAGE_COW.patch
index 85863b1dd..5db1f749d 100644
--- a/0020-x86-mm-Update-pte_modify-and-pmd_modify-for-_PAGE_CO.patch
+++ b/0020-x86-mm-Update-pte_modify-for-_PAGE_COW.patch
@@ -1,30 +1,28 @@
-From 8becbf5cf32370dfaca6b7317328ac5c08869335 Mon Sep 17 00:00:00 2001
+From 92a167472789becb0b80014b326c674a2f9d495c Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Thu, 29 Aug 2019 09:24:13 -0700
-Subject: [PATCH 20/46] x86/mm: Update pte_modify and pmd_modify for _PAGE_COW
+Subject: [PATCH 20/47] x86/mm: Update pte_modify for _PAGE_COW
 
 Pte_modify() changes a PTE to 'newprot'.  It doesn't use the pte_*()
 helpers that a previous patch fixed up, so we need a new site.
 
-Introduce fixup_dirty_pte() to fixup the PTE, depending on the PTE is
-writable or copy-on-write.  Apply the same changes to pmd_modify().
+Introduce fixup_dirty_pte() to set the dirty bits based on _PAGE_RW, and
+apply the same changes to pmd_modify().
+
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 
 v10:
 - Change static_cpu_has() to cpu_feature_enabled().
-- Revsrse _PAGE_CHG_MASK changes, because the mask's purpose is to filter
-  out bits not supposed to be in 'newprot'.  Instead, introduce
-  fixup_dirty_pte().
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
+- Replace _PAGE_CHG_MASK approach with fixup functions.
 ---
  arch/x86/include/asm/pgtable.h | 33 +++++++++++++++++++++++++++++++++
  1 file changed, 33 insertions(+)
 
 diff --git a/arch/x86/include/asm/pgtable.h b/arch/x86/include/asm/pgtable.h
-index fd03ed24ef65..b76b9491e11f 100644
+index 11bd5f223ff3..931e7ff53ae3 100644
 --- a/arch/x86/include/asm/pgtable.h
 +++ b/arch/x86/include/asm/pgtable.h
-@@ -724,6 +724,21 @@ static inline pmd_t pmd_mknotpresent(pmd_t pmd)
+@@ -725,6 +725,21 @@ static inline pmd_t pmd_mknotpresent(pmd_t pmd)
  
  static inline u64 flip_protnone_guard(u64 oldval, u64 val, u64 mask);
  
@@ -46,7 +44,7 @@ index fd03ed24ef65..b76b9491e11f 100644
  static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
  {
  	pteval_t val = pte_val(pte), oldval = val;
-@@ -734,16 +749,34 @@ static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
+@@ -735,16 +750,34 @@ static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
  	 */
  	val &= _PAGE_CHG_MASK;
  	val |= check_pgprot(newprot) & ~_PAGE_CHG_MASK;
@@ -82,5 +80,5 @@ index fd03ed24ef65..b76b9491e11f 100644
  	return __pmd(val);
  }
 -- 
-2.26.1
+2.26.2
 
diff --git a/0021-x86-mm-Update-ptep_set_wrprotect-and-pmdp_set_wrprot.patch b/0021-x86-mm-Update-ptep_set_wrprotect-and-pmdp_set_wrprot.patch
index 950fdcfef..242e57683 100644
--- a/0021-x86-mm-Update-ptep_set_wrprotect-and-pmdp_set_wrprot.patch
+++ b/0021-x86-mm-Update-ptep_set_wrprotect-and-pmdp_set_wrprot.patch
@@ -1,15 +1,14 @@
-From c7c743ec52a2c96212a048e0d5011dc6e80dcc21 Mon Sep 17 00:00:00 2001
+From 3309b285e36e78e729a4e544b0155f0294efff3f Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Fri, 15 Jun 2018 09:33:40 -0700
-Subject: [PATCH 21/46] x86/mm: Update ptep_set_wrprotect() and
+Subject: [PATCH 21/47] x86/mm: Update ptep_set_wrprotect() and
  pmdp_set_wrprotect() for transition from _PAGE_DIRTY_HW to _PAGE_COW
 
-When shadow stack is enabled, [R/O + _PAGE_DIRTY_HW] PTE is reserved only
-for (non copy-on-write) shadow stack.  Copy-on-write PTEs have
-[R/O + _PAGE_COW].
+When shadow stack is introduced, [R/O + _PAGE_DIRTY_HW] PTE is reserved
+for shadow stack.  Copy-on-write PTEs have [R/O + _PAGE_COW].
 
 When a PTE goes from [R/W + _PAGE_DIRTY_HW] to [R/O + _PAGE_COW], it could
-become a transient shadow stack PTE in two cases.
+become a transient shadow stack PTE in two cases:
 
 The first case is that some processors can start a write but end up seeing
 a read-only PTE by the time they get to the Dirty bit, creating a transient
@@ -23,12 +22,14 @@ This is prevented with cmpxchg.
 Dave Hansen, Jann Horn, Andy Lutomirski, and Peter Zijlstra provided many
 insights to the issue.  Jann Horn provided the cmpxchg solution.
 
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
+Reviewed-by: Kees Cook <keescook@chromium.org>
+
 v10:
-- Replace bit shifts with pte_wrprotect()/pmd_wrprotect(), which use bit
-  test & shifts.
+- Replace bit shift with pte_wrprotect()/pmd_wrprotect(), which use bit
+  test & shift.
 - Move READ_ONCE of old_pte into try_cmpxchg() loop.
 - Change static_cpu_has() to cpu_feature_enabled().
-- Remove #ifdef CONFIG_X86_64.
 
 v9:
 - Change compile-time conditionals to runtime checks.
@@ -37,18 +38,15 @@ v9:
 
 v4:
 - Implement try_cmpxchg().
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
-Reviewed-by: Kees Cook <keescook@chromium.org>
 ---
  arch/x86/include/asm/pgtable.h | 52 ++++++++++++++++++++++++++++++++++
  1 file changed, 52 insertions(+)
 
 diff --git a/arch/x86/include/asm/pgtable.h b/arch/x86/include/asm/pgtable.h
-index b76b9491e11f..0270e04e3505 100644
+index 931e7ff53ae3..30adef6a354b 100644
 --- a/arch/x86/include/asm/pgtable.h
 +++ b/arch/x86/include/asm/pgtable.h
-@@ -1314,6 +1314,32 @@ static inline pte_t ptep_get_and_clear_full(struct mm_struct *mm,
+@@ -1315,6 +1315,32 @@ static inline pte_t ptep_get_and_clear_full(struct mm_struct *mm,
  static inline void ptep_set_wrprotect(struct mm_struct *mm,
  				      unsigned long addr, pte_t *ptep)
  {
@@ -81,7 +79,7 @@ index b76b9491e11f..0270e04e3505 100644
  	clear_bit(_PAGE_BIT_RW, (unsigned long *)&ptep->pte);
  }
  
-@@ -1370,6 +1396,32 @@ static inline pud_t pudp_huge_get_and_clear(struct mm_struct *mm,
+@@ -1371,6 +1397,32 @@ static inline pud_t pudp_huge_get_and_clear(struct mm_struct *mm,
  static inline void pmdp_set_wrprotect(struct mm_struct *mm,
  				      unsigned long addr, pmd_t *pmdp)
  {
@@ -107,7 +105,7 @@ index b76b9491e11f..0270e04e3505 100644
 +			old_pmd = READ_ONCE(*pmdp);
 +			new_pmd = pmd_wrprotect(old_pmd);
 +
-+		} while (!try_cmpxchg(&pmdp->pmd, &old_pmd.pmd, new_pmd.pmd));
++		} while (!try_cmpxchg((pmdval_t *)pmdp, (pmdval_t *)&old_pmd, pmd_val(new_pmd)));
 +
 +		return;
 +	}
@@ -115,5 +113,5 @@ index b76b9491e11f..0270e04e3505 100644
  }
  
 -- 
-2.26.1
+2.26.2
 
diff --git a/0022-mm-Introduce-VM_SHSTK-for-Shadow-Stack-memory.patch b/0022-mm-Introduce-VM_SHSTK-for-shadow-stack-memory.patch
similarity index 92%
rename from 0022-mm-Introduce-VM_SHSTK-for-Shadow-Stack-memory.patch
rename to 0022-mm-Introduce-VM_SHSTK-for-shadow-stack-memory.patch
index c6c4e9218..7ec03bb24 100644
--- a/0022-mm-Introduce-VM_SHSTK-for-Shadow-Stack-memory.patch
+++ b/0022-mm-Introduce-VM_SHSTK-for-shadow-stack-memory.patch
@@ -1,19 +1,19 @@
-From edf3dfe3b124a17554a49a902e12b67c17382c1e Mon Sep 17 00:00:00 2001
+From 41a0c9d094b064ff51d9b778675caddcf8878472 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Fri, 12 Jan 2018 15:04:54 -0800
-Subject: [PATCH 22/46] mm: Introduce VM_SHSTK for Shadow Stack memory
+Subject: [PATCH 22/47] mm: Introduce VM_SHSTK for shadow stack memory
 
 A Shadow Stack PTE must be read-only and have _PAGE_DIRTY set.  However,
 read-only and Dirty PTEs also exist for copy-on-write (COW) pages.  These
 two cases are handled differently for page faults.  Introduce VM_SHSTK to
 track shadow stack VMAs.
 
-v9:
-- Add VM_SHSTK case to arch_vma_name().
-- Revise the commit log to explain why a new VM flag is needed.
-
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Reviewed-by: Kees Cook <keescook@chromium.org>
+
+v9:
+- Add VM_SHSTK case to arch_vma_name().
+- Revise the commit log to explain why adding a new VM flag.
 ---
  arch/x86/mm/mmap.c | 2 ++
  fs/proc/task_mmu.c | 3 +++
@@ -79,5 +79,5 @@ index 5a323422d783..54bb4cd9fee8 100644
  # define VM_GROWSUP	VM_NONE
  #endif
 -- 
-2.26.1
+2.26.2
 
diff --git a/0023-x86-mm-Shadow-Stack-page-fault-error-checking.patch b/0023-x86-mm-Shadow-Stack-page-fault-error-checking.patch
index c288c4b6a..835a3ad7f 100644
--- a/0023-x86-mm-Shadow-Stack-page-fault-error-checking.patch
+++ b/0023-x86-mm-Shadow-Stack-page-fault-error-checking.patch
@@ -1,7 +1,7 @@
-From c04abb64d583f5b2f84dce10e209191961454b5b Mon Sep 17 00:00:00 2001
+From c4005a84cd3d7f71943e00b349922b12363854f1 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 28 Nov 2017 13:01:18 -0800
-Subject: [PATCH 23/46] x86/mm: Shadow Stack page fault error checking
+Subject: [PATCH 23/47] x86/mm: Shadow Stack page fault error checking
 
 Shadow stack accesses are those that are performed by the CPU where it
 expects to encounter a shadow stack mapping.  These accesses are performed
@@ -18,17 +18,18 @@ Shadow stack accesses can also result in errors, such as when a shadow
 stack overflows, or if a shadow stack access occurs to a non-shadow-stack
 mapping.
 
-Verify a shadow stack page fault is within a shadow mapping.  It is always
-an error otherwise.  For valid shadow stack accesses, always set
-FAULT_FLAG_WRITE to effect copy-on-write.   This is because clearing
-_PAGE_DIRTY_HW from shadow stack PTEs is used to detect the next shadow
-stack access, and this method cannot distinguish read versus write.
-
-v10:
--Revise commit log.
+In handling a shadow stack page fault, verify it occurs within a shadow
+stack mapping.  It is always an error otherwise.  For valid shadow stack
+accesses, set FAULT_FLAG_WRITE to effect copy-on-write.  Because clearing
+_PAGE_DIRTY_HW (vs. _PAGE_RW) is used to trigger the fault, shadow stack
+read fault and shadow stack write fault are not differentiated and both are
+handled as a write access.
 
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Reviewed-by: Kees Cook <keescook@chromium.org>
+
+v10:
+-Revise commit log.
 ---
  arch/x86/include/asm/traps.h |  2 ++
  arch/x86/mm/fault.c          | 19 +++++++++++++++++++
@@ -54,7 +55,7 @@ index 9bf804709ee6..b4f4c725a350 100644
  };
  #endif /* _ASM_X86_TRAPS_H */
 diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c
-index a51df516b87b..e95eee82b48e 100644
+index a51df516b87b..a4a3c8f016f0 100644
 --- a/arch/x86/mm/fault.c
 +++ b/arch/x86/mm/fault.c
 @@ -1210,6 +1210,17 @@ access_error(unsigned long error_code, struct vm_area_struct *vma)
@@ -64,7 +65,7 @@ index a51df516b87b..e95eee82b48e 100644
 +	/*
 +	 * Verify a shadow stack access is within a shadow stack VMA.
 +	 * It is always an error otherwise.  Normal data access to a
-+	 * shadow stack area is checked in the next case.
++	 * shadow stack area is checked in the case followed.
 +	 */
 +	if (error_code & X86_PF_SHSTK) {
 +		if (!(vma->vm_flags & VM_SHSTK))
@@ -82,8 +83,8 @@ index a51df516b87b..e95eee82b48e 100644
 +	/*
 +	 * Clearing _PAGE_DIRTY_HW is used to detect shadow stack access.
 +	 * This method cannot distinguish shadow stack read vs. write.
-+	 * For a valid shadow stack access, always set FAULT_FLAG_WRITE to
-+	 * effect copy-on-write.
++	 * For valid shadow stack accesses, set FAULT_FLAG_WRITE to effect
++	 * copy-on-write.
 +	 */
 +	if (hw_error_code & X86_PF_SHSTK)
 +		flags |= FAULT_FLAG_WRITE;
@@ -91,5 +92,5 @@ index a51df516b87b..e95eee82b48e 100644
  		flags |= FAULT_FLAG_WRITE;
  	if (hw_error_code & X86_PF_INSTR)
 -- 
-2.26.1
+2.26.2
 
diff --git a/0024-x86-mm-Update-is_cow_mapping-and-maybe_mkwrite-for-s.patch b/0024-x86-mm-Update-maybe_mkwrite-for-shadow-stack.patch
similarity index 57%
rename from 0024-x86-mm-Update-is_cow_mapping-and-maybe_mkwrite-for-s.patch
rename to 0024-x86-mm-Update-maybe_mkwrite-for-shadow-stack.patch
index 124642881..c7c716306 100644
--- a/0024-x86-mm-Update-is_cow_mapping-and-maybe_mkwrite-for-s.patch
+++ b/0024-x86-mm-Update-maybe_mkwrite-for-shadow-stack.patch
@@ -1,36 +1,55 @@
-From 6d55a34a6b5be63f505cc20edcbde9e3364eabd6 Mon Sep 17 00:00:00 2001
+From 98e15e185a48e9d4022151314a7c7bf512b75d6c Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 7 Apr 2020 16:03:36 -0700
-Subject: [PATCH 24/46] x86/mm: Update is_cow_mapping() and maybe_mkwrite() for
- shadow stack
+Subject: [PATCH 24/47] x86/mm: Update maybe_mkwrite() for shadow stack
 
-Shadow stack is writable by WRUSSQ/WRUSSD and by CALL (but indirectly).
-Thus, in handling page faults, shadow stack is treated as logically
-writable.  Update is_cow_mapping() and maybe_mkwrite() to include the
-shadow stack.
+Shadow stack memory is writable, but its VMA has VM_SHSTK instead of
+VM_WRITE.  Update maybe_mkwrite() to include the shadow stack.
 
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 ---
- arch/x86/mm/pgtable.c         | 25 +++++++++++++++++++++++++
- include/asm-generic/pgtable.h | 29 +++++++++++++++++++++++++++++
+ arch/x86/Kconfig              |  4 ++++
+ arch/x86/mm/pgtable.c         | 18 ++++++++++++++++++
+ include/asm-generic/pgtable.h | 24 ++++++++++++++++++++++++
  include/linux/mm.h            |  2 ++
  mm/huge_memory.c              |  2 ++
- mm/internal.h                 |  3 ++-
- 5 files changed, 60 insertions(+), 1 deletion(-)
+ 5 files changed, 50 insertions(+)
 
+diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
+index c98f82fffe85..ac07e1f6a2bc 100644
+--- a/arch/x86/Kconfig
++++ b/arch/x86/Kconfig
+@@ -1955,6 +1955,9 @@ config AS_HAS_SHADOW_STACK
+ config X86_INTEL_CET
+ 	def_bool n
+ 
++config ARCH_MAYBE_MKWRITE
++	def_bool n
++
+ config ARCH_HAS_SHADOW_STACK
+ 	def_bool n
+ 
+@@ -1965,6 +1968,7 @@ config X86_INTEL_SHADOW_STACK_USER
+ 	depends on AS_HAS_SHADOW_STACK
+ 	select ARCH_USES_HIGH_VMA_FLAGS
+ 	select X86_INTEL_CET
++	select ARCH_MAYBE_MKWRITE
+ 	select ARCH_HAS_SHADOW_STACK
+ 	help
+ 	  Shadow Stacks provides protection against program stack
 diff --git a/arch/x86/mm/pgtable.c b/arch/x86/mm/pgtable.c
-index 7bd2c3a52297..6dddde290d53 100644
+index 7bd2c3a52297..aa4d396ff98d 100644
 --- a/arch/x86/mm/pgtable.c
 +++ b/arch/x86/mm/pgtable.c
 @@ -603,6 +603,24 @@ int pmdp_clear_flush_young(struct vm_area_struct *vma,
  }
  #endif
  
-+#ifdef CONFIG_ARCH_HAS_COW_MAPPING
++#ifdef CONFIG_ARCH_MAYBE_MKWRITE
 +pte_t arch_maybe_mkwrite(pte_t pte, struct vm_area_struct *vma)
 +{
 +	if (likely(vma->vm_flags & VM_SHSTK))
-+		pte = pte_mkdirty_shstk(pte);
++		pte = pte_mkwrite_shstk(pte);
 +	return pte;
 +}
 +
@@ -38,48 +57,32 @@ index 7bd2c3a52297..6dddde290d53 100644
 +pmd_t arch_maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma)
 +{
 +	if (likely(vma->vm_flags & VM_SHSTK))
-+		pmd = pmd_mkdirty_shstk(pmd);
++		pmd = pmd_mkwrite_shstk(pmd);
 +	return pmd;
 +}
 +#endif /* CONFIG_TRANSPARENT_HUGEPAGE */
-+#endif /* CONFIG_ARCH_HAS_COW_MAPPING */
++#endif /* CONFIG_ARCH_MAYBE_MKWRITE */
 +
  /**
   * reserve_top_address - reserves a hole in the top of kernel address space
   * @reserve - size of hole to reserve
-@@ -872,3 +890,10 @@ int pmd_free_pte_page(pmd_t *pmd, unsigned long addr)
- 
- #endif /* CONFIG_X86_64 */
- #endif	/* CONFIG_HAVE_ARCH_HUGE_VMAP */
-+
-+#ifdef CONFIG_ARCH_HAS_COW_MAPPING
-+bool arch_cow_mapping(vm_flags_t vm_flags)
-+{
-+	return (vm_flags & VM_SHSTK);
-+}
-+#endif
 diff --git a/include/asm-generic/pgtable.h b/include/asm-generic/pgtable.h
-index 329b8c8ca703..3aaf192dbef6 100644
+index 329b8c8ca703..2c3875724809 100644
 --- a/include/asm-generic/pgtable.h
 +++ b/include/asm-generic/pgtable.h
-@@ -1191,6 +1191,35 @@ static inline bool arch_has_pfn_modify_check(void)
+@@ -1191,6 +1191,30 @@ static inline bool arch_has_pfn_modify_check(void)
  }
  #endif /* !_HAVE_ARCH_PFN_MODIFY_ALLOWED */
  
 +#ifdef CONFIG_MMU
-+#ifdef CONFIG_ARCH_HAS_COW_MAPPING
-+bool arch_cow_mapping(vm_flags_t vm_flags);
++#ifdef CONFIG_ARCH_MAYBE_MKWRITE
 +pte_t arch_maybe_mkwrite(pte_t pte, struct vm_area_struct *vma);
 +
 +#ifdef CONFIG_TRANSPARENT_HUGEPAGE
 +pmd_t arch_maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma);
 +#endif /* CONFIG_TRANSPARENT_HUGEPAGE */
 +
-+#else /* !CONFIG_ARCH_HAS_COW_MAPPING */
-+static inline bool arch_cow_mapping(vm_flags_t vm_flags)
-+{
-+	return false;
-+}
++#else /* !CONFIG_ARCH_MAYBE_MKWRITE */
 +static inline pte_t arch_maybe_mkwrite(pte_t pte, struct vm_area_struct *vma)
 +{
 +	return pte;
@@ -92,7 +95,7 @@ index 329b8c8ca703..3aaf192dbef6 100644
 +}
 +#endif /* CONFIG_TRANSPARENT_HUGEPAGE */
 +
-+#endif /* CONFIG_ARCH_HAS_COW_MAPPING */
++#endif /* CONFIG_ARCH_MAYBE_MKWRITE */
 +#endif /* CONFIG_MMU */
 +
  /*
@@ -124,20 +127,6 @@ index 6ecd1045113b..608746bb9d19 100644
  	return pmd;
  }
  
-diff --git a/mm/internal.h b/mm/internal.h
-index b5634e78f01d..144b5abd7c0a 100644
---- a/mm/internal.h
-+++ b/mm/internal.h
-@@ -283,7 +283,8 @@ static inline unsigned int page_order(struct page *page)
- 
- static inline bool is_cow_mapping(vm_flags_t flags)
- {
--	return (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;
-+	return ((flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE) ||
-+		arch_cow_mapping(flags);
- }
- 
- /*
 -- 
-2.26.1
+2.26.2
 
diff --git a/0025-mm-Update-do_anonymous_page-and-do_numa_page.patch b/0025-mm-Fixup-places-that-call-pte_mkwrite-directly.patch
similarity index 50%
rename from 0025-mm-Update-do_anonymous_page-and-do_numa_page.patch
rename to 0025-mm-Fixup-places-that-call-pte_mkwrite-directly.patch
index f4174d00b..af5062ade 100644
--- a/0025-mm-Update-do_anonymous_page-and-do_numa_page.patch
+++ b/0025-mm-Fixup-places-that-call-pte_mkwrite-directly.patch
@@ -1,18 +1,29 @@
-From 3951fb7e0e873b59d25859013354e3e1eeb50c21 Mon Sep 17 00:00:00 2001
+From d526800ea9f4f74941b11886b8cc97419b33b3ec Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Mon, 13 Apr 2020 13:21:22 -0700
-Subject: [PATCH 25/46] mm: Update do_anonymous_page() and do_numa_page()
+Subject: [PATCH 25/47] mm: Fixup places that call pte_mkwrite() directly
 
-In handling page faults, do_anonymous_page()/do_numa_page() makes a page
-writable if the VMA is writable.  Update them to include shadow stack.
+A shadow stack page is made writable by pte_mkwrite_shstk(), which sets
+_PAGE_DIRTY_HW.  There are a few places that call pte_mkwrite() directly
+and miss the maybe_mkwrite() fixup in the previous patch.  Fix them with
+maybe_mkwrite():
 
-Also fix a similar situation for migrate_vma_insert_page().
+- do_anonymous_page() and migrate_vma_insert_page() check VM_WRITE directly
+  and call pte_mkwrite(), which is the same as maybe_mkwrite().  Change
+  them to maybe_mkwrite().
+
+- In do_numa_page(), if the numa entry 'was-writable', then pte_mkwrite()
+  is called directly.  Fix it by doing maybe_mkwrite().
+
+- In change_pte_range(), pte_mkwrite() is called directly.  Replace it with
+  maybe_mkwrite().
 
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 ---
- mm/memory.c  | 5 ++---
- mm/migrate.c | 3 +--
- 2 files changed, 3 insertions(+), 5 deletions(-)
+ mm/memory.c   | 5 ++---
+ mm/migrate.c  | 3 +--
+ mm/mprotect.c | 2 +-
+ 3 files changed, 4 insertions(+), 6 deletions(-)
 
 diff --git a/mm/memory.c b/mm/memory.c
 index f703fe8c8346..b9002f644806 100644
@@ -51,6 +62,19 @@ index 7160c1556f79..0fa59b1562c6 100644
  	}
  
  	ptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);
+diff --git a/mm/mprotect.c b/mm/mprotect.c
+index 494192ca954b..02762af1057c 100644
+--- a/mm/mprotect.c
++++ b/mm/mprotect.c
+@@ -135,7 +135,7 @@ static unsigned long change_pte_range(struct vm_area_struct *vma, pmd_t *pmd,
+ 			if (dirty_accountable && pte_dirty(ptent) &&
+ 					(pte_soft_dirty(ptent) ||
+ 					 !(vma->vm_flags & VM_SOFTDIRTY))) {
+-				ptent = pte_mkwrite(ptent);
++				ptent = maybe_mkwrite(ptent, vma);
+ 			}
+ 			ptep_modify_prot_commit(vma, addr, pte, oldpte, ptent);
+ 			pages++;
 -- 
-2.26.1
+2.26.2
 
diff --git a/0027-x86-mm-Add-guard-pages-around-a-Shadow-Stack.patch b/0026-mm-Add-guard-pages-around-a-shadow-stack.patch
similarity index 79%
rename from 0027-x86-mm-Add-guard-pages-around-a-Shadow-Stack.patch
rename to 0026-mm-Add-guard-pages-around-a-shadow-stack.patch
index b56afb164..0dc246a1d 100644
--- a/0027-x86-mm-Add-guard-pages-around-a-Shadow-Stack.patch
+++ b/0026-mm-Add-guard-pages-around-a-shadow-stack.patch
@@ -1,30 +1,28 @@
-From 3051fdf2a90141f0e8094506e183a38bb254e16d Mon Sep 17 00:00:00 2001
+From 7b909123c0b5ccd9aa93292058e34515f86fe547 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Fri, 4 Oct 2019 14:00:58 -0700
-Subject: [PATCH 27/46] x86/mm: Add guard pages around a Shadow Stack.
+Subject: [PATCH 26/47] mm: Add guard pages around a shadow stack.
 
-INCSSPQ/D increment shadow stack pointer and 'pop and discard' the first
-and the last elements in the range, effectively touch those memory areas.
+INCSSP(Q/D) increments shadow stack pointer and 'pops and discards' the
+first and the last elements in the range, effectively touches those memory
+areas.
 
 The maximum moving distance by INCSSPQ is 255 * 8 = 2040 bytes and
-255 * 4 = 1020 bytes for INCSSPD.  Both ranges are far from PAGE_SIZE.
-Putting a gap page on both ends of a shadow stack prevents INCSSP, CALL,
-and RET from going beyond.
+255 * 4 = 1020 bytes by INCSSPD.  Both ranges are far from PAGE_SIZE.
+Thus, putting a gap page on both ends of a shadow stack prevents INCSSP,
+CALL, and RET from going beyond.
 
-Define ARCH_SHADOW_STACK_GUARD_GAP and use that for shadow stack gap size.
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 
 v10:
-- Define and use ARCH_SHADOW_STACK_GUARD_GAP.
-- Add comments.
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
+- Define ARCH_SHADOW_STACK_GUARD_GAP.
 ---
  arch/x86/include/asm/processor.h | 10 ++++++++++
  include/linux/mm.h               | 24 ++++++++++++++++++++----
  2 files changed, 30 insertions(+), 4 deletions(-)
 
 diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h
-index 3bcf27caf6c9..d0e20d31976a 100644
+index 3bcf27caf6c9..eb9536f803f9 100644
 --- a/arch/x86/include/asm/processor.h
 +++ b/arch/x86/include/asm/processor.h
 @@ -907,6 +907,16 @@ static inline void spin_lock_prefetch(const void *x)
@@ -32,7 +30,7 @@ index 3bcf27caf6c9..d0e20d31976a 100644
  #define STACK_TOP_MAX		TASK_SIZE_MAX
  
 +/*
-+ * Shadow stack pointer is moved by CALL, JMP, and INCSSPQ/D.  INCSSPQ
++ * Shadow stack pointer is moved by CALL, JMP, and INCSSP(Q/D).  INCSSPQ
 + * moves shadow stack pointer up to 255 * 8 = ~2 KB (~1KB for INCSSPD) and
 + * touches the first and the last element in the range, which triggers a
 + * page fault if the range is not in a shadow stack.  Because of this,
@@ -96,5 +94,5 @@ index f0669e3cdd37..68eadf2c466d 100644
  			vm_end = -PAGE_SIZE;
  	}
 -- 
-2.26.1
+2.26.2
 
diff --git a/0028-mm-mmap-Add-Shadow-Stack-pages-to-memory-accounting.patch b/0027-mm-mmap-Add-shadow-stack-pages-to-memory-accounting.patch
similarity index 74%
rename from 0028-mm-mmap-Add-Shadow-Stack-pages-to-memory-accounting.patch
rename to 0027-mm-mmap-Add-shadow-stack-pages-to-memory-accounting.patch
index d708c7faa..f4bc33a1c 100644
--- a/0028-mm-mmap-Add-Shadow-Stack-pages-to-memory-accounting.patch
+++ b/0027-mm-mmap-Add-shadow-stack-pages-to-memory-accounting.patch
@@ -1,17 +1,17 @@
-From 48b7ab7747e78297173dc1ffec3d68d467943882 Mon Sep 17 00:00:00 2001
+From c32cabbeda526d7a64ed6f82f1a67a036e261c2b Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Thu, 13 Sep 2018 12:36:48 -0700
-Subject: [PATCH 28/46] mm/mmap: Add Shadow Stack pages to memory accounting
+Subject: [PATCH 27/47] mm/mmap: Add shadow stack pages to memory accounting
 
-Add Shadow Stack pages to memory accounting.
+Account shadow stack pages to stack memory.
+
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 
 v10:
-- Use arch_shadow_stack_mapping() to make the meaning clear.
+- Use arch_shadow_stack_mapping() to make meaning clear.
 
 v8:
-- Change Shadow Stake pages from data_vm to stack_vm.
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
+- Change shadow stake pages from data_vm to stack_vm.
 ---
  arch/x86/mm/pgtable.c         |  7 +++++++
  include/asm-generic/pgtable.h | 11 +++++++++++
@@ -19,13 +19,13 @@ Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
  3 files changed, 23 insertions(+)
 
 diff --git a/arch/x86/mm/pgtable.c b/arch/x86/mm/pgtable.c
-index 6dddde290d53..796a449150c1 100644
+index aa4d396ff98d..f384e0314ba7 100644
 --- a/arch/x86/mm/pgtable.c
 +++ b/arch/x86/mm/pgtable.c
-@@ -897,3 +897,10 @@ bool arch_cow_mapping(vm_flags_t vm_flags)
- 	return (vm_flags & VM_SHSTK);
- }
- #endif
+@@ -890,3 +890,10 @@ int pmd_free_pte_page(pmd_t *pmd, unsigned long addr)
+ 
+ #endif /* CONFIG_X86_64 */
+ #endif	/* CONFIG_HAVE_ARCH_HUGE_VMAP */
 +
 +#ifdef CONFIG_ARCH_HAS_SHADOW_STACK
 +bool arch_shadow_stack_mapping(vm_flags_t vm_flags)
@@ -34,11 +34,11 @@ index 6dddde290d53..796a449150c1 100644
 +}
 +#endif
 diff --git a/include/asm-generic/pgtable.h b/include/asm-generic/pgtable.h
-index 3aaf192dbef6..aee89979c0df 100644
+index 2c3875724809..dbd415ab7dd8 100644
 --- a/include/asm-generic/pgtable.h
 +++ b/include/asm-generic/pgtable.h
-@@ -1220,6 +1220,17 @@ static inline pmd_t arch_maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma
- #endif /* CONFIG_ARCH_HAS_COW_MAPPING */
+@@ -1215,6 +1215,17 @@ static inline pmd_t arch_maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma
+ #endif /* CONFIG_ARCH_MAYBE_MKWRITE */
  #endif /* CONFIG_MMU */
  
 +#ifdef CONFIG_MMU
@@ -79,5 +79,5 @@ index f609e9ec4a25..70d240b3559c 100644
  
  static vm_fault_t special_mapping_fault(struct vm_fault *vmf);
 -- 
-2.26.1
+2.26.2
 
diff --git a/0026-mm-Update-can_follow_write_pte-for-Shadow-Stack.patch b/0028-mm-Update-can_follow_write_pte-for-shadow-stack.patch
similarity index 74%
rename from 0026-mm-Update-can_follow_write_pte-for-Shadow-Stack.patch
rename to 0028-mm-Update-can_follow_write_pte-for-shadow-stack.patch
index 234ce44dc..34e2cc7cc 100644
--- a/0026-mm-Update-can_follow_write_pte-for-Shadow-Stack.patch
+++ b/0028-mm-Update-can_follow_write_pte-for-shadow-stack.patch
@@ -1,28 +1,28 @@
-From 7daa42ad1b2a7fcfe1876d9a0d44bdb10d61b3ea Mon Sep 17 00:00:00 2001
+From f81911cf4ecc4d82816b9131a0a807f5205414d5 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 3 Jul 2018 13:07:12 -0700
-Subject: [PATCH 26/46] mm: Update can_follow_write_pte() for Shadow Stack
+Subject: [PATCH 28/47] mm: Update can_follow_write_pte() for shadow stack
 
-Can_follow_write_pte() verifies that a read-only page is the task's own
-copy by ensuring the page has gone through faultin_page() and the PTE is
-Dirty.  However, a shadow stack PTE in copy-on-write status is still dirty.
-Update the read-only check to exclude the case.
+Can_follow_write_pte() ensures a read-only page is COWed by checking the
+FOLL_COW flag, and uses pte_dirty() to validate the flag is still valid.
 
-Also apply same changes to the huge memory case.
+Like a writable data page, a shadow stack page is writable, and becomes
+read-only during copy-on-write, but it is always dirty.  Thus, in the
+can_follow_write_pte() check, it belongs to the writable page case and
+should be exclueded from the read-only page pte_dirty() check.  Apply
+the same changes to can_follow_write_pmd().
+
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 
 v10:
 - Reverse name changes to can_follow_write_*().
-- Since a shadow stack PTE is considered pte_write(), update the
-  read-only, dirty case.
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 ---
  mm/gup.c         | 8 +++++---
  mm/huge_memory.c | 8 +++++---
  2 files changed, 10 insertions(+), 6 deletions(-)
 
 diff --git a/mm/gup.c b/mm/gup.c
-index 6076df8e04a4..a2e413d26f96 100644
+index 50681f0286de..c737782403ee 100644
 --- a/mm/gup.c
 +++ b/mm/gup.c
 @@ -385,10 +385,12 @@ static int follow_pfn_pte(struct vm_area_struct *vma, unsigned long address,
@@ -36,7 +36,7 @@ index 6076df8e04a4..a2e413d26f96 100644
  	return pte_write(pte) ||
 -		((flags & FOLL_FORCE) && (flags & FOLL_COW) && pte_dirty(pte));
 +		((flags & FOLL_FORCE) && (flags & FOLL_COW) &&
-+		 !arch_cow_mapping(vma->vm_flags) && pte_dirty(pte));
++		 !arch_shadow_stack_mapping(vma->vm_flags) && pte_dirty(pte));
  }
  
  static struct page *follow_page_pte(struct vm_area_struct *vma,
@@ -50,7 +50,7 @@ index 6076df8e04a4..a2e413d26f96 100644
  		return NULL;
  	}
 diff --git a/mm/huge_memory.c b/mm/huge_memory.c
-index 608746bb9d19..c93db1a1587f 100644
+index 608746bb9d19..cb1b0cb4b4eb 100644
 --- a/mm/huge_memory.c
 +++ b/mm/huge_memory.c
 @@ -1520,10 +1520,12 @@ vm_fault_t do_huge_pmd_wp_page(struct vm_fault *vmf, pmd_t orig_pmd)
@@ -64,7 +64,7 @@ index 608746bb9d19..c93db1a1587f 100644
  	return pmd_write(pmd) ||
 -	       ((flags & FOLL_FORCE) && (flags & FOLL_COW) && pmd_dirty(pmd));
 +	       ((flags & FOLL_FORCE) && (flags & FOLL_COW) &&
-+		!arch_cow_mapping(vma->vm_flags) && pmd_dirty(pmd));
++		!arch_shadow_stack_mapping(vma->vm_flags) && pmd_dirty(pmd));
  }
  
  struct page *follow_trans_huge_pmd(struct vm_area_struct *vma,
@@ -78,5 +78,5 @@ index 608746bb9d19..c93db1a1587f 100644
  
  	/* Avoid dumping huge zero page */
 -- 
-2.26.1
+2.26.2
 
diff --git a/0029-x86-cet-shstk-User-mode-Shadow-Stack-support.patch b/0029-x86-cet-shstk-User-mode-shadow-stack-support.patch
similarity index 95%
rename from 0029-x86-cet-shstk-User-mode-Shadow-Stack-support.patch
rename to 0029-x86-cet-shstk-User-mode-shadow-stack-support.patch
index 394a46705..5447038e9 100644
--- a/0029-x86-cet-shstk-User-mode-Shadow-Stack-support.patch
+++ b/0029-x86-cet-shstk-User-mode-shadow-stack-support.patch
@@ -1,17 +1,19 @@
-From e722491314061fb1d50fb75409f7a89e3ca8f47f Mon Sep 17 00:00:00 2001
+From aa77162fb0c7c08cc2aa8728136ada1edc7deb78 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Thu, 22 Aug 2019 10:06:11 -0700
-Subject: [PATCH 29/46] x86/cet/shstk: User-mode Shadow Stack support
+Subject: [PATCH 29/47] x86/cet/shstk: User-mode shadow stack support
 
-This patch adds basic shadow stack  enabling/disabling routines.  A task's
-shadow stack is allocated from memory with VM_SHSTK flag and read-only
-protection.  It has a fixed size of min(RLIMIT_STACK, 4GB).
+This patch adds basic shadow stack enabling/disabling routines.  A task's
+shadow stack is allocated from memory with VM_SHSTK flag and has a fixed
+size of min(RLIMIT_STACK, 4GB).
+
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 
 v10:
 - Change no_cet_shstk to no_user_shstk.
 - Limit shadow stack size to 4 GB, and round_up to PAGE_SIZE.
 - Replace checking shstk_enabled with shstk_size being zero.
-- Retry and WARN_ON_ONCE() when vm_munmap() fails.
+- WARN_ON_ONCE() when vm_munmap() fails.
 
 v9:
 - Change cpu_feature_enabled() to static_cpu_has().
@@ -25,8 +27,6 @@ v6:
 
 v2:
 - Change noshstk to no_cet_shstk.
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 ---
  arch/x86/include/asm/cet.h                    |  26 ++++
  arch/x86/include/asm/disabled-features.h      |   8 +-
@@ -99,7 +99,7 @@ index 4ea8584682f9..a0e1b24cfa02 100644
  #define DISABLED_MASK18	0
  #define DISABLED_MASK_CHECK BUILD_BUG_ON_ZERO(NCAPINTS != 19)
 diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h
-index d0e20d31976a..d0681021fb74 100644
+index eb9536f803f9..0ccf1c7ab173 100644
 --- a/arch/x86/include/asm/processor.h
 +++ b/arch/x86/include/asm/processor.h
 @@ -27,6 +27,7 @@ struct vm86;
@@ -367,5 +367,5 @@ index 4ea8584682f9..a0e1b24cfa02 100644
  #define DISABLED_MASK18	0
  #define DISABLED_MASK_CHECK BUILD_BUG_ON_ZERO(NCAPINTS != 19)
 -- 
-2.26.1
+2.26.2
 
diff --git a/0030-x86-cet-shstk-Handle-signals-for-Shadow-Stack.patch b/0030-x86-cet-shstk-Handle-signals-for-shadow-stack.patch
similarity index 79%
rename from 0030-x86-cet-shstk-Handle-signals-for-Shadow-Stack.patch
rename to 0030-x86-cet-shstk-Handle-signals-for-shadow-stack.patch
index 02c47704a..3320b2c08 100644
--- a/0030-x86-cet-shstk-Handle-signals-for-Shadow-Stack.patch
+++ b/0030-x86-cet-shstk-Handle-signals-for-shadow-stack.patch
@@ -1,7 +1,7 @@
-From d8de779fe78febd77434edc7a77e28481e436e55 Mon Sep 17 00:00:00 2001
+From c1d73346e6a4683987764f84a6f151da8bc62cdc Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Thu, 5 Jan 2017 13:48:31 -0800
-Subject: [PATCH 30/46] x86/cet/shstk: Handle signals for Shadow Stack
+Subject: [PATCH 30/47] x86/cet/shstk: Handle signals for shadow stack
 
 To deliver a signal, create a shadow stack restore token and put a restore
 token and the signal restorer address on the shadow stack.  For sigreturn,
@@ -17,8 +17,12 @@ be introduced later in the Indirect Branch Tracking (IBT) series, but add
 that into sc_ext now to keep the struct stable in case the IBT series is
 applied later.
 
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
+
 v10:
 - Combine with WRUSS instruction patch, since it is used only here.
+- Revise signal restore code to the latest supervisor states handling.
+  Move shadow stack restore token checking out of the fast path.
 
 v9:
 - Update CET MSR access according to XSAVES supervisor state changes.
@@ -30,21 +34,19 @@ v2:
 - Move CET status from sigcontext to a separate struct sc_ext, which is
   located above the fpstate on the signal frame.
 - Add a restore token for sigreturn address.
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 ---
  arch/x86/ia32/ia32_signal.c            |  17 +++
- arch/x86/include/asm/cet.h             |   7 ++
+ arch/x86/include/asm/cet.h             |   8 ++
  arch/x86/include/asm/fpu/internal.h    |  10 ++
- arch/x86/include/asm/special_insns.h   |  32 +++++
+ arch/x86/include/asm/special_insns.h   |  32 ++++++
  arch/x86/include/uapi/asm/sigcontext.h |   9 ++
- arch/x86/kernel/cet.c                  | 157 +++++++++++++++++++++++++
- arch/x86/kernel/fpu/signal.c           |  96 +++++++++++++++
+ arch/x86/kernel/cet.c                  | 151 +++++++++++++++++++++++++
+ arch/x86/kernel/fpu/signal.c           | 101 +++++++++++++++++
  arch/x86/kernel/signal.c               |  10 ++
  8 files changed, 338 insertions(+)
 
 diff --git a/arch/x86/ia32/ia32_signal.c b/arch/x86/ia32/ia32_signal.c
-index f9d8804144d0..10014faa2ec1 100644
+index f9d8804144d0..cb19159817cb 100644
 --- a/arch/x86/ia32/ia32_signal.c
 +++ b/arch/x86/ia32/ia32_signal.c
 @@ -35,6 +35,7 @@
@@ -81,14 +83,14 @@ index f9d8804144d0..10014faa2ec1 100644
  	sp = fpu__alloc_mathframe(sp, 1, &fx_aligned, &math_size);
  	*fpstate = (struct _fpstate_32 __user *) sp;
 +
-+	if (save_cet_to_sigframe(*fpstate, (unsigned long)restorer, 1))
++	if (save_cet_to_sigframe(1, *fpstate, (unsigned long)restorer))
 +		return (void __user *) -1L;
 +
  	if (copy_fpstate_to_sigframe(*fpstate, (void __user *)fx_aligned,
  				     math_size) < 0)
  		return (void __user *) -1L;
 diff --git a/arch/x86/include/asm/cet.h b/arch/x86/include/asm/cet.h
-index caac0687c8e4..c913a1cdf070 100644
+index caac0687c8e4..56fe08eebae6 100644
 --- a/arch/x86/include/asm/cet.h
 +++ b/arch/x86/include/asm/cet.h
 @@ -6,6 +6,8 @@
@@ -100,22 +102,23 @@ index caac0687c8e4..c913a1cdf070 100644
  /*
   * Per-thread CET status
   */
-@@ -17,8 +19,13 @@ struct cet_status {
+@@ -17,8 +19,14 @@ struct cet_status {
  #ifdef CONFIG_X86_INTEL_CET
  int cet_setup_shstk(void);
  void cet_disable_free_shstk(struct task_struct *p);
-+int cet_restore_signal(bool ia32, struct sc_ext *sc);
++int cet_verify_rstor_token(bool ia32, unsigned long ssp, unsigned long *new_ssp);
++void cet_restore_signal(struct sc_ext *sc);
 +int cet_setup_signal(bool ia32, unsigned long rstor, struct sc_ext *sc);
  #else
  static inline void cet_disable_free_shstk(struct task_struct *p) {}
-+static inline int cet_restore_signal(bool ia32, struct sc_ext *sc) { return -EINVAL; }
++static inline void cet_restore_signal(struct sc_ext *sc) { return; }
 +static inline int cet_setup_signal(bool ia32, unsigned long rstor,
 +				   struct sc_ext *sc) { return -EINVAL; }
  #endif
  
  #endif /* __ASSEMBLY__ */
 diff --git a/arch/x86/include/asm/fpu/internal.h b/arch/x86/include/asm/fpu/internal.h
-index 42159f45bf9c..ed5a76f1f608 100644
+index 42159f45bf9c..9dda2935c738 100644
 --- a/arch/x86/include/asm/fpu/internal.h
 +++ b/arch/x86/include/asm/fpu/internal.h
 @@ -476,6 +476,16 @@ static inline void copy_kernel_to_fpregs(union fpregs_state *fpstate)
@@ -123,11 +126,11 @@ index 42159f45bf9c..ed5a76f1f608 100644
  }
  
 +#ifdef CONFIG_X86_INTEL_CET
-+extern int save_cet_to_sigframe(void __user *fp, unsigned long restorer,
-+				int is_ia32);
++extern int save_cet_to_sigframe(int ia32, void __user *fp,
++				unsigned long restorer);
 +#else
-+static inline int save_cet_to_sigframe(void __user *fp, unsigned long restorer,
-+				int is_ia32)
++static inline int save_cet_to_sigframe(int ia32, void __user *fp,
++				unsigned long restorer);
 +{
 +	return 0;
 +}
@@ -199,7 +202,7 @@ index 844d60eb1882..cf2d55db3be4 100644
   * The 32-bit signal frame:
   */
 diff --git a/arch/x86/kernel/cet.c b/arch/x86/kernel/cet.c
-index d8196c8e792a..8f3b2cd95a2f 100644
+index d8196c8e792a..274fecdd9669 100644
 --- a/arch/x86/kernel/cet.c
 +++ b/arch/x86/kernel/cet.c
 @@ -19,6 +19,8 @@
@@ -225,8 +228,8 @@ index d8196c8e792a..8f3b2cd95a2f 100644
 + * valid and then set shadow stack pointer according to the
 + * token.
 + */
-+static int verify_rstor_token(bool ia32, unsigned long ssp,
-+			      unsigned long *new_ssp)
++int cet_verify_rstor_token(bool ia32, unsigned long ssp,
++			   unsigned long *new_ssp)
 +{
 +	unsigned long token;
 +
@@ -292,7 +295,7 @@ index d8196c8e792a..8f3b2cd95a2f 100644
  int cet_setup_shstk(void)
  {
  	unsigned long addr, size;
-@@ -133,3 +209,84 @@ void cet_disable_free_shstk(struct task_struct *tsk)
+@@ -133,3 +209,78 @@ void cet_disable_free_shstk(struct task_struct *tsk)
  	cet->shstk_base = 0;
  	cet->shstk_size = 0;
  }
@@ -301,28 +304,22 @@ index d8196c8e792a..8f3b2cd95a2f 100644
 + * Called from __fpu__restore_sig() and XSAVES buffer is protected by
 + * set_thread_flag(TIF_NEED_FPU_LOAD) in the slow path.
 + */
-+int cet_restore_signal(bool ia32, struct sc_ext *sc_ext)
++void cet_restore_signal(struct sc_ext *sc_ext)
 +{
 +	struct cet_user_state *cet_user_state;
 +	struct cet_status *cet = &current->thread.cet;
-+	unsigned long new_ssp = 0;
 +	u64 msr_val = 0;
-+	int err;
 +
 +	cet_user_state = get_xsave_addr(&current->thread.fpu.state.xsave,
 +					XFEATURE_CET_USER);
 +	if (!cet_user_state)
-+		return -1;
++		return;
 +
 +	if (cet->shstk_size) {
-+		err = verify_rstor_token(ia32, sc_ext->ssp, &new_ssp);
-+		if (err)
-+			return err;
-+
 +		if (test_thread_flag(TIF_NEED_FPU_LOAD))
-+			cet_user_state->user_ssp = new_ssp;
++			cet_user_state->user_ssp = sc_ext->ssp;
 +		else
-+			wrmsrl(MSR_IA32_PL3_SSP, new_ssp);
++			wrmsrl(MSR_IA32_PL3_SSP, sc_ext->ssp);
 +
 +		msr_val |= MSR_IA32_CET_SHSTK_EN;
 +	}
@@ -332,7 +329,7 @@ index d8196c8e792a..8f3b2cd95a2f 100644
 +	else
 +		wrmsrl(MSR_IA32_U_CET, msr_val);
 +
-+	return 0;
++	return;
 +}
 +
 +/*
@@ -378,15 +375,15 @@ index d8196c8e792a..8f3b2cd95a2f 100644
 +	return 0;
 +}
 diff --git a/arch/x86/kernel/fpu/signal.c b/arch/x86/kernel/fpu/signal.c
-index 4dad5afc938d..8862d3edbf34 100644
+index 4dad5afc938d..95ee76d08971 100644
 --- a/arch/x86/kernel/fpu/signal.c
 +++ b/arch/x86/kernel/fpu/signal.c
-@@ -52,6 +52,72 @@ static inline int check_for_xstate(struct fxregs_state __user *buf,
+@@ -52,6 +52,73 @@ static inline int check_for_xstate(struct fxregs_state __user *buf,
  	return 0;
  }
  
 +#ifdef CONFIG_X86_INTEL_CET
-+int save_cet_to_sigframe(void __user *fp, unsigned long restorer, int is_ia32)
++int save_cet_to_sigframe(int ia32, void __user *fp, unsigned long restorer)
 +{
 +	int err = 0;
 +
@@ -396,13 +393,13 @@ index 4dad5afc938d..8862d3edbf34 100644
 +	if (fp) {
 +		struct sc_ext ext = {0, 0, 0};
 +
-+		err = cet_setup_signal(is_ia32, restorer, &ext);
++		err = cet_setup_signal(ia32, restorer, &ext);
 +		if (!err) {
 +			void __user *p = fp;
 +
 +			ext.total_size = sizeof(ext);
 +
-+			if (is_ia32)
++			if (ia32)
 +				p += sizeof(struct fregs_state);
 +
 +			p += fpu_user_xstate_size + FP_XSTATE_MAGIC2_SIZE;
@@ -416,36 +413,37 @@ index 4dad5afc938d..8862d3edbf34 100644
 +	return err;
 +}
 +
-+static int restore_cet_from_sigframe(int is_ia32, void __user *fp)
++static int get_cet_from_sigframe(int ia32, void __user *fp, struct sc_ext *ext)
 +{
 +	int err = 0;
 +
++	memset(ext, 0, sizeof(*ext));
++
 +	if (!current->thread.cet.shstk_size)
 +		return 0;
 +
 +	if (fp) {
-+		struct sc_ext ext = {0, 0, 0};
 +		void __user *p = fp;
 +
-+		if (is_ia32)
++		if (ia32)
 +			p += sizeof(struct fregs_state);
 +
 +		p += fpu_user_xstate_size + FP_XSTATE_MAGIC2_SIZE;
 +		p = (void __user *)ALIGN((unsigned long)p, 8);
 +
-+		if (copy_from_user(&ext, p, sizeof(ext)))
++		if (copy_from_user(ext, p, sizeof(*ext)))
 +			return -EFAULT;
 +
-+		if (ext.total_size != sizeof(ext))
++		if (ext->total_size != sizeof(*ext))
 +			return -EFAULT;
 +
-+		err = cet_restore_signal(is_ia32, &ext);
++		err = cet_verify_rstor_token(ia32, ext->ssp, &ext->ssp);
 +	}
 +
 +	return err;
 +}
 +#else
-+static int restore_cet_from_sigframe(int is_ia32, void __user *fp)
++static int get_cet_from_sigframe(int ia32, void __user *fp, struct sc_ext *ext)
 +{
 +	return 0;
 +}
@@ -454,28 +452,47 @@ index 4dad5afc938d..8862d3edbf34 100644
  /*
   * Signal frame handlers.
   */
-@@ -346,6 +412,9 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
+@@ -294,6 +361,7 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
+ 	struct task_struct *tsk = current;
+ 	struct fpu *fpu = &tsk->thread.fpu;
+ 	struct user_i387_ia32_struct env;
++	struct sc_ext sc_ext;
+ 	u64 user_xfeatures = 0;
+ 	int fx_only = 0;
+ 	int ret = 0;
+@@ -334,6 +402,10 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
+ 	if ((unsigned long)buf_fx % 64)
+ 		fx_only = 1;
+ 
++	ret = get_cet_from_sigframe(ia32_fxstate, buf, &sc_ext);
++	if (ret)
++		return ret;
++
+ 	if (!ia32_fxstate) {
+ 		/*
+ 		 * Attempt to restore the FPU registers directly from user
+@@ -346,7 +418,10 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
  		pagefault_disable();
  		ret = copy_user_to_fpregs_zeroing(buf_fx, user_xfeatures, fx_only);
  		pagefault_enable();
-+		if (!ret)
-+			ret = restore_cet_from_sigframe(0, buf);
 +
  		if (!ret) {
++			cet_restore_signal(&sc_ext);
++
  			/* Restore supervisor states */
  			if (test_thread_flag(TIF_NEED_FPU_LOAD) &&
-@@ -402,6 +471,10 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
- 		sanitize_restored_user_xstate(&fpu->state, envp, user_xfeatures,
- 					      fx_only);
- 
-+		ret = restore_cet_from_sigframe((int)ia32_fxstate, buf);
-+		if (ret)
-+			goto err_out;
-+
+ 			    xfeatures_mask_supervisor())
+@@ -405,6 +480,9 @@ static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)
  		fpregs_lock();
  		if (unlikely(init_bv))
  			copy_kernel_to_xregs(&init_fpstate.xsave, init_bv);
-@@ -473,12 +546,35 @@ int fpu__restore_sig(void __user *buf, int ia32_frame)
++
++		cet_restore_signal(&sc_ext);
++
+ 		/*
+ 		 * Restore previously saved supervisor xstates along with
+ 		 * copied-in user xstates.
+@@ -473,12 +551,35 @@ int fpu__restore_sig(void __user *buf, int ia32_frame)
  	return __fpu__restore_sig(buf, buf_fx, size);
  }
  
@@ -512,7 +529,7 @@ index 4dad5afc938d..8862d3edbf34 100644
  	if (ia32_frame && use_fxsr()) {
  		frame_size += sizeof(struct fregs_state);
 diff --git a/arch/x86/kernel/signal.c b/arch/x86/kernel/signal.c
-index 0052bbe5dfd4..059b8cbc6a32 100644
+index 0052bbe5dfd4..5ee1b2e51de3 100644
 --- a/arch/x86/kernel/signal.c
 +++ b/arch/x86/kernel/signal.c
 @@ -44,6 +44,7 @@
@@ -540,12 +557,12 @@ index 0052bbe5dfd4..059b8cbc6a32 100644
 +#ifdef CONFIG_X86_64
 +	if (ka->sa.sa_flags & SA_RESTORER)
 +		restorer = ka->sa.sa_restorer;
-+	ret = save_cet_to_sigframe(*fpstate, (unsigned long)restorer, 0);
++	ret = save_cet_to_sigframe(0, *fpstate, (unsigned long)restorer);
 +#endif
 +
  	/* save i387 and extended state */
  	ret = copy_fpstate_to_sigframe(*fpstate, (void __user *)buf_fx, math_size);
  	if (ret < 0)
 -- 
-2.26.1
+2.26.2
 
diff --git a/0031-ELF-UAPI-and-Kconfig-additions-for-ELF-program-prope.patch b/0031-ELF-UAPI-and-Kconfig-additions-for-ELF-program-prope.patch
index b81ab99bb..4b0ea8446 100644
--- a/0031-ELF-UAPI-and-Kconfig-additions-for-ELF-program-prope.patch
+++ b/0031-ELF-UAPI-and-Kconfig-additions-for-ELF-program-prope.patch
@@ -1,17 +1,17 @@
-From 51e4eb695cda8f3ead009a750155529d90d49d5e Mon Sep 17 00:00:00 2001
+From d40a5c912271c278da622a4fdb04cc076a76e93d Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Fri, 18 Oct 2019 18:25:34 +0100
-Subject: [PATCH 31/46] ELF: UAPI and Kconfig additions for ELF program
+Subject: [PATCH 31/47] ELF: UAPI and Kconfig additions for ELF program
  properties
 
 Introduce basic ELF definitions relating to the NT_GNU_PROPERTY_TYPE_0
 note.
 
-v10:
-- Merge GNU_PROPERTY_X86_FEATURE_1_* from a separate patch.
-
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Reviewed-by: Kees Cook <keescook@chromium.org>
+
+v10:
+- Merge GNU_PROPERTY_X86_FEATURE_1_* from a separate patch.
 ---
  fs/Kconfig.binfmt        | 3 +++
  include/linux/elf.h      | 8 ++++++++
@@ -81,5 +81,5 @@ index 34c02e4290fe..61251ecabdd7 100644
 +
  #endif /* _UAPI_LINUX_ELF_H */
 -- 
-2.26.1
+2.26.2
 
diff --git a/0032-ELF-Add-ELF-program-property-parsing-support.patch b/0032-ELF-Add-ELF-program-property-parsing-support.patch
index e940b5008..3679b2f3d 100644
--- a/0032-ELF-Add-ELF-program-property-parsing-support.patch
+++ b/0032-ELF-Add-ELF-program-property-parsing-support.patch
@@ -1,7 +1,7 @@
-From 6d78f2d83d8cc62daab91870ce9e0c5fecc90632 Mon Sep 17 00:00:00 2001
+From 3fd39c16bc91e36ee8aa93195460f41c34f575d7 Mon Sep 17 00:00:00 2001
 From: Dave Martin <Dave.Martin@arm.com>
 Date: Mon, 16 Mar 2020 16:50:44 +0000
-Subject: [PATCH 32/46] ELF: Add ELF program property parsing support
+Subject: [PATCH 32/47] ELF: Add ELF program property parsing support
 
 ELF program properties will be needed for detecting whether to
 enable optional architecture or ABI features for a new ELF process.
@@ -306,5 +306,5 @@ index 61251ecabdd7..518651708d8f 100644
  typedef struct elf32_note {
    Elf32_Word	n_namesz;	/* Name size */
 -- 
-2.26.1
+2.26.2
 
diff --git a/0033-ELF-Introduce-arch_setup_elf_property.patch b/0033-ELF-Introduce-arch_setup_elf_property.patch
index b64dc0a3d..fc1103c48 100644
--- a/0033-ELF-Introduce-arch_setup_elf_property.patch
+++ b/0033-ELF-Introduce-arch_setup_elf_property.patch
@@ -1,13 +1,12 @@
-From cc398d898c51f15a4b24367a53246e73c244c3d3 Mon Sep 17 00:00:00 2001
+From abf3f7efe6bb775056682297d179512fea3d0bdb Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 20 Aug 2019 13:20:37 -0700
-Subject: [PATCH 33/46] ELF: Introduce arch_setup_elf_property()
+Subject: [PATCH 33/47] ELF: Introduce arch_setup_elf_property()
 
 An ELF file's .note.gnu.property indicates architecture features of the
 file.  These features are extracted earlier and stored in the struct
 'arch_elf_state'.  Introduce arch_setup_elf_property() to setup and enable
-these features.  The first use-case of this function is Shadow Stack and
-Indirect Branch Tracking, which are introduced later.
+these features.  The first use-case of this function is shadow stack.
 
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 ---
@@ -51,5 +50,5 @@ index 7bdc6da160c7..81f2161fa4a8 100644
  
  #endif /* _LINUX_ELF_H */
 -- 
-2.26.1
+2.26.2
 
diff --git a/0034-x86-cet-shstk-ELF-header-parsing-for-Shadow-Stack.patch b/0034-x86-cet-shstk-ELF-header-parsing-for-shadow-stack.patch
similarity index 90%
rename from 0034-x86-cet-shstk-ELF-header-parsing-for-Shadow-Stack.patch
rename to 0034-x86-cet-shstk-ELF-header-parsing-for-shadow-stack.patch
index 08dec9865..5ec732955 100644
--- a/0034-x86-cet-shstk-ELF-header-parsing-for-Shadow-Stack.patch
+++ b/0034-x86-cet-shstk-ELF-header-parsing-for-shadow-stack.patch
@@ -1,15 +1,15 @@
-From d4f4d7405b882516ebb1cc5e2ca862cc4f089eeb Mon Sep 17 00:00:00 2001
+From 768ac125b0a38111e1e40311fc98734e81f06043 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 3 Oct 2017 16:07:12 -0700
-Subject: [PATCH 34/46] x86/cet/shstk: ELF header parsing for Shadow Stack
+Subject: [PATCH 34/47] x86/cet/shstk: ELF header parsing for shadow stack
 
-Check an ELF file's .note.gnu.property, and setup Shadow Stack if the
+Check an ELF file's .note.gnu.property, and setup shadow stack if the
 application supports it.
 
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
+
 v9:
 - Change cpu_feature_enabled() to static_cpu_has().
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 ---
  arch/x86/Kconfig             |  2 ++
  arch/x86/include/asm/elf.h   | 13 +++++++++++++
@@ -17,12 +17,12 @@ Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
  3 files changed, 44 insertions(+)
 
 diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
-index 5a598741da67..561cc1632a2b 100644
+index ac07e1f6a2bc..8b7b97ff5fb4 100644
 --- a/arch/x86/Kconfig
 +++ b/arch/x86/Kconfig
 @@ -1970,6 +1970,8 @@ config X86_INTEL_SHADOW_STACK_USER
  	select X86_INTEL_CET
- 	select ARCH_HAS_COW_MAPPING
+ 	select ARCH_MAYBE_MKWRITE
  	select ARCH_HAS_SHADOW_STACK
 +	select ARCH_USE_GNU_PROPERTY
 +	select ARCH_BINFMT_ELF_STATE
@@ -91,5 +91,5 @@ index 5ef9d8f25b0e..93ba4afd0c19 100644
 +}
 +#endif
 -- 
-2.26.1
+2.26.2
 
diff --git a/0035-x86-cet-shstk-Handle-thread-Shadow-Stack.patch b/0035-x86-cet-shstk-Handle-thread-shadow-stack.patch
similarity index 77%
rename from 0035-x86-cet-shstk-Handle-thread-Shadow-Stack.patch
rename to 0035-x86-cet-shstk-Handle-thread-shadow-stack.patch
index 349b19bc6..964c3057c 100644
--- a/0035-x86-cet-shstk-Handle-thread-Shadow-Stack.patch
+++ b/0035-x86-cet-shstk-Handle-thread-shadow-stack.patch
@@ -1,13 +1,10 @@
-From 711aa4e9494076635becbeb13201c13b3fe31461 Mon Sep 17 00:00:00 2001
+From 1f9b310566a6b1d0f1c981af209df6695b98e9a9 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Thu, 3 May 2018 12:40:57 -0700
-Subject: [PATCH 35/46] x86/cet/shstk: Handle thread Shadow Stack
+Subject: [PATCH 35/47] x86/cet/shstk: Handle thread shadow stack
 
-The shadow stack for clone/fork is handled as the following:
-
-(1) If ((clone_flags & (CLONE_VFORK | CLONE_VM)) == CLONE_VM),
-    the kernel allocates (and frees on thread exit) a new shadow stack for
-    the child.
+The kernel allocates (and frees on thread exit) a new shadow stack for a
+pthread child.
 
     It is possible for the kernel to complete the clone syscall and set the
     child's shadow stack pointer to NULL and let the child thread allocate
@@ -16,23 +13,14 @@ The shadow stack for clone/fork is handled as the following:
     cannot handle signals before the child can successfully allocate a
     shadow stack.
 
-(2) For (clone_flags & CLONE_VFORK), the child uses the existing shadow
-    stack.
-
-(3) For all other cases, the shadow stack is copied/reused whenever the
-    parent or the child does a call/ret.
-
-This patch handles cases (1) & (2).  Case (3) is handled in the shaodw
-stack page fault patches.
+A 64-bit shadow stack has a size of min(RLIMIT_STACK, 4 GB).  A compat-mode
+thread shadow stack has a size of 1/4 min(RLIMIT_STACK, 4 GB).  This allows
+more threads to run in a 32-bit address space.
 
-A 64-bit shadow stack has a size of min(RLIMIT_STACK, 4GB).  A compat-mode
-thread shadow stack has a size of 1/4 min(RLIMIT_STACK, 4GB).  This allows
-more threads to share a 32-bit address space.
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 
 v10:
-- Limit shadow stack size to 4GB.
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
+- Limit shadow stack size to 4 GB.
 ---
  arch/x86/include/asm/cet.h         |  2 ++
  arch/x86/include/asm/mmu_context.h |  3 +++
@@ -41,21 +29,22 @@ Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
  4 files changed, 53 insertions(+)
 
 diff --git a/arch/x86/include/asm/cet.h b/arch/x86/include/asm/cet.h
-index c913a1cdf070..a7ee9b2eaef2 100644
+index 56fe08eebae6..71dc92acd2f2 100644
 --- a/arch/x86/include/asm/cet.h
 +++ b/arch/x86/include/asm/cet.h
-@@ -18,10 +18,12 @@ struct cet_status {
+@@ -18,11 +18,13 @@ struct cet_status {
  
  #ifdef CONFIG_X86_INTEL_CET
  int cet_setup_shstk(void);
 +int cet_setup_thread_shstk(struct task_struct *p);
  void cet_disable_free_shstk(struct task_struct *p);
- int cet_restore_signal(bool ia32, struct sc_ext *sc);
+ int cet_verify_rstor_token(bool ia32, unsigned long ssp, unsigned long *new_ssp);
+ void cet_restore_signal(struct sc_ext *sc);
  int cet_setup_signal(bool ia32, unsigned long rstor, struct sc_ext *sc);
  #else
 +static inline int cet_setup_thread_shstk(struct task_struct *p) { return 0; }
  static inline void cet_disable_free_shstk(struct task_struct *p) {}
- static inline int cet_restore_signal(bool ia32, struct sc_ext *sc) { return -EINVAL; }
+ static inline void cet_restore_signal(struct sc_ext *sc) { return; }
  static inline int cet_setup_signal(bool ia32, unsigned long rstor,
 diff --git a/arch/x86/include/asm/mmu_context.h b/arch/x86/include/asm/mmu_context.h
 index 4e55370e48e8..bb7a4a2d6923 100644
@@ -79,7 +68,7 @@ index 4e55370e48e8..bb7a4a2d6923 100644
  	loadsegment(fs, 0);			\
  } while (0)
 diff --git a/arch/x86/kernel/cet.c b/arch/x86/kernel/cet.c
-index 8f3b2cd95a2f..e0c3915db10f 100644
+index 274fecdd9669..121552047b86 100644
 --- a/arch/x86/kernel/cet.c
 +++ b/arch/x86/kernel/cet.c
 @@ -169,6 +169,47 @@ int cet_setup_shstk(void)
@@ -156,5 +145,5 @@ index 9d9cff2c1018..ef1c2b8086a2 100644
  		io_bitmap_share(p);
  
 -- 
-2.26.1
+2.26.2
 
diff --git a/0036-x86-cet-shstk-Add-arch_prctl-functions-for-Shadow-St.patch b/0036-x86-cet-shstk-Add-arch_prctl-functions-for-shadow-st.patch
similarity index 80%
rename from 0036-x86-cet-shstk-Add-arch_prctl-functions-for-Shadow-St.patch
rename to 0036-x86-cet-shstk-Add-arch_prctl-functions-for-shadow-st.patch
index e538ff56b..39c306d56 100644
--- a/0036-x86-cet-shstk-Add-arch_prctl-functions-for-Shadow-St.patch
+++ b/0036-x86-cet-shstk-Add-arch_prctl-functions-for-shadow-st.patch
@@ -1,39 +1,39 @@
-From 396f691ecd6cf6b70f2154be575957dfa3348409 Mon Sep 17 00:00:00 2001
+From fa9c172f816639766372c888270c296916f8c48d Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Thu, 3 May 2018 13:04:29 -0700
-Subject: [PATCH 36/46] x86/cet/shstk: Add arch_prctl functions for Shadow
- Stack
+Subject: [PATCH 36/47] x86/cet/shstk: Add arch_prctl functions for shadow
+ stack
 
-arch_prctl(ARCH_X86_CET_STATUS, u64 *addr)
-    Return CET feature status.
+arch_prctl(ARCH_X86_CET_STATUS, u64 *args)
+    Get CET feature status.
 
-    The parameter 'addr' is a pointer to a user buffer.  On returning to
-    the caller, the kernel fills the following information:
+    The parameter 'args' is a pointer to a user buffer.  The kernel returns
+    the following information:
 
-    *addr = SHSTK/IBT status
-    *(addr + 1) = SHSTK base address
-    *(addr + 2) = SHSTK size
+    *args = shadow stack/IBT status
+    *(args + 1) = shadow stack base address
+    *(args + 2) = shadow stack size
 
 arch_prctl(ARCH_X86_CET_DISABLE, u64 features)
     Disable CET features specified in 'features'.  Return -EPERM if CET is
     locked.
 
 arch_prctl(ARCH_X86_CET_LOCK)
-    Lock in CET feature.
+    Lock in CET features.
 
-arch_prctl(ARCH_X86_CET_ALLOC_SHSTK, u64 *addr)
-    Allocate a new SHSTK.
+arch_prctl(ARCH_X86_CET_ALLOC_SHSTK, u64 *args)
+    Allocate a new shadow stack.
 
-    The parameter 'addr' is a pointer to a user buffer and indicates the
-    desired SHSTK size to allocate.  On returning to the caller the buffer
-    contains the address of the new SHSTK.
+    The parameter 'args' is a pointer to a user buffer containing the
+    desired size to allocate.  The kernel returns the allocated shadow
+    stack address in *args.
+
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 
 v10:
 - Verify CET is enabled before handling arch_prctl.
 - Change input parameters from unsigned long to u64, to make it clear they
   are 64-bit.
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 ---
  arch/x86/include/asm/cet.h        |  4 ++
  arch/x86/include/uapi/asm/prctl.h |  5 ++
@@ -45,10 +45,10 @@ Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
  create mode 100644 arch/x86/kernel/cet_prctl.c
 
 diff --git a/arch/x86/include/asm/cet.h b/arch/x86/include/asm/cet.h
-index a7ee9b2eaef2..bd753392af93 100644
+index 71dc92acd2f2..99e6e741d28c 100644
 --- a/arch/x86/include/asm/cet.h
 +++ b/arch/x86/include/asm/cet.h
-@@ -14,15 +14,19 @@ struct sc_ext;
+@@ -14,16 +14,20 @@ struct sc_ext;
  struct cet_status {
  	unsigned long	shstk_base;
  	unsigned long	shstk_size;
@@ -61,13 +61,14 @@ index a7ee9b2eaef2..bd753392af93 100644
  int cet_setup_thread_shstk(struct task_struct *p);
 +int cet_alloc_shstk(unsigned long *arg);
  void cet_disable_free_shstk(struct task_struct *p);
- int cet_restore_signal(bool ia32, struct sc_ext *sc);
+ int cet_verify_rstor_token(bool ia32, unsigned long ssp, unsigned long *new_ssp);
+ void cet_restore_signal(struct sc_ext *sc);
  int cet_setup_signal(bool ia32, unsigned long rstor, struct sc_ext *sc);
  #else
 +static inline int prctl_cet(int option, u64 arg2) { return -EINVAL; }
  static inline int cet_setup_thread_shstk(struct task_struct *p) { return 0; }
  static inline void cet_disable_free_shstk(struct task_struct *p) {}
- static inline int cet_restore_signal(bool ia32, struct sc_ext *sc) { return -EINVAL; }
+ static inline void cet_restore_signal(struct sc_ext *sc) { return; }
 diff --git a/arch/x86/include/uapi/asm/prctl.h b/arch/x86/include/uapi/asm/prctl.h
 index 5a6aac9fa41f..d962f0ec9ccf 100644
 --- a/arch/x86/include/uapi/asm/prctl.h
@@ -96,7 +97,7 @@ index e9cc2551573b..0b621e2afbdc 100644
  ###
  # 64 bit specific files
 diff --git a/arch/x86/kernel/cet.c b/arch/x86/kernel/cet.c
-index e0c3915db10f..646cb05b5896 100644
+index 121552047b86..c1b9b540c03e 100644
 --- a/arch/x86/kernel/cet.c
 +++ b/arch/x86/kernel/cet.c
 @@ -145,6 +145,35 @@ static int create_rstor_token(bool ia32, unsigned long ssp,
@@ -137,7 +138,7 @@ index e0c3915db10f..646cb05b5896 100644
  	unsigned long addr, size;
 diff --git a/arch/x86/kernel/cet_prctl.c b/arch/x86/kernel/cet_prctl.c
 new file mode 100644
-index 000000000000..0b4df3cbe2de
+index 000000000000..0139c48f2215
 --- /dev/null
 +++ b/arch/x86/kernel/cet_prctl.c
 @@ -0,0 +1,87 @@
@@ -158,15 +159,14 @@ index 000000000000..0b4df3cbe2de
 +static int handle_get_status(u64 arg2)
 +{
 +	struct cet_status *cet = &current->thread.cet;
-+	unsigned int features = 0;
-+	u64 buf[3];
++	u64 buf[3] = {0, 0, 0};
 +
-+	if (cet->shstk_size)
-+		features |= GNU_PROPERTY_X86_FEATURE_1_SHSTK;
++	if (cet->shstk_size) {
++		buf[0] |= GNU_PROPERTY_X86_FEATURE_1_SHSTK;
++		buf[1] = (u64)cet->shstk_base;
++		buf[2] = (u64)cet->shstk_size;
++	}
 +
-+	buf[0] = (u64)features;
-+	buf[1] = (u64)cet->shstk_base;
-+	buf[2] = (u64)cet->shstk_size;
 +	return copy_to_user((u64 __user *)arg2, buf, sizeof(buf));
 +}
 +
@@ -198,7 +198,8 @@ index 000000000000..0b4df3cbe2de
 +{
 +	struct cet_status *cet;
 +
-+	BUILD_BUG_ON(!IS_ENABLED(CONFIG_X86_INTEL_CET));
++	if (!IS_ENABLED(CONFIG_X86_INTEL_CET))
++		return -EINVAL;
 +
 +	if (option == ARCH_X86_CET_STATUS)
 +		return handle_get_status(arg2);
@@ -243,5 +244,5 @@ index ef1c2b8086a2..de6773dd6a16 100644
 -	return -EINVAL;
  }
 -- 
-2.26.1
+2.26.2
 
diff --git a/0037-x86-cet-ibt-Add-Kconfig-option-for-user-mode-Indirec.patch b/0037-x86-cet-ibt-Add-Kconfig-option-for-user-mode-Indirec.patch
index 7285db215..56dfaf8bd 100644
--- a/0037-x86-cet-ibt-Add-Kconfig-option-for-user-mode-Indirec.patch
+++ b/0037-x86-cet-ibt-Add-Kconfig-option-for-user-mode-Indirec.patch
@@ -1,7 +1,7 @@
-From ed198287388e9b4ebeda804686ecbc059cb0740b Mon Sep 17 00:00:00 2001
+From 3128d65d8795f9513b1cd63822cc3eb3a0cc85dc Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Wed, 4 Oct 2017 12:35:32 -0700
-Subject: [PATCH 37/46] x86/cet/ibt: Add Kconfig option for user-mode Indirect
+Subject: [PATCH 37/47] x86/cet/ibt: Add Kconfig option for user-mode Indirect
  Branch Tracking
 
 Introduce Kconfig option X86_INTEL_BRANCH_TRACKING_USER.
@@ -12,16 +12,16 @@ feature enabled, and the processor and the application support it.
 When this feature is enabled, legacy non-IBT applications continue to
 work, but without IBT protection.
 
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
+
 v10:
 - Change build-time CET check to config depends on.
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 ---
  arch/x86/Kconfig | 16 ++++++++++++++++
  1 file changed, 16 insertions(+)
 
 diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
-index 561cc1632a2b..e769a55e07ed 100644
+index 8b7b97ff5fb4..d45fbdfe61e7 100644
 --- a/arch/x86/Kconfig
 +++ b/arch/x86/Kconfig
 @@ -1983,6 +1983,22 @@ config X86_INTEL_SHADOW_STACK_USER
@@ -48,5 +48,5 @@ index 561cc1632a2b..e769a55e07ed 100644
  	bool "EFI runtime service support"
  	depends on ACPI
 -- 
-2.26.1
+2.26.2
 
diff --git a/0038-x86-cet-ibt-User-mode-Indirect-Branch-Tracking-suppo.patch b/0038-x86-cet-ibt-User-mode-Indirect-Branch-Tracking-suppo.patch
index 85f92e5e3..9244cdee1 100644
--- a/0038-x86-cet-ibt-User-mode-Indirect-Branch-Tracking-suppo.patch
+++ b/0038-x86-cet-ibt-User-mode-Indirect-Branch-Tracking-suppo.patch
@@ -1,11 +1,13 @@
-From f3c16a33b95a3623780d00dd4635537b69ffd64e Mon Sep 17 00:00:00 2001
+From 618fb42db1a4274e3b522ab16e383c29b5486caf Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Thu, 3 May 2018 13:30:56 -0700
-Subject: [PATCH 38/46] x86/cet/ibt: User-mode Indirect Branch Tracking support
+Subject: [PATCH 38/47] x86/cet/ibt: User-mode Indirect Branch Tracking support
 
 Introduce user-mode Indirect Branch Tracking (IBT) support.  Update setup
 routines to include IBT.
 
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
+
 v10:
 - Change no_cet_ibt to no_user_ibt.
 
@@ -14,8 +16,6 @@ v9:
 
 v2:
 - Change noibt to no_cet_ibt.
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 ---
  arch/x86/include/asm/cet.h                    |  3 ++
  arch/x86/include/asm/disabled-features.h      |  8 ++++-
@@ -25,7 +25,7 @@ Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
  5 files changed, 67 insertions(+), 2 deletions(-)
 
 diff --git a/arch/x86/include/asm/cet.h b/arch/x86/include/asm/cet.h
-index bd753392af93..3ad52fa6d38e 100644
+index 99e6e741d28c..f163c805a559 100644
 --- a/arch/x86/include/asm/cet.h
 +++ b/arch/x86/include/asm/cet.h
 @@ -15,6 +15,7 @@ struct cet_status {
@@ -36,9 +36,9 @@ index bd753392af93..3ad52fa6d38e 100644
  };
  
  #ifdef CONFIG_X86_INTEL_CET
-@@ -25,6 +26,8 @@ int cet_alloc_shstk(unsigned long *arg);
- void cet_disable_free_shstk(struct task_struct *p);
- int cet_restore_signal(bool ia32, struct sc_ext *sc);
+@@ -26,6 +27,8 @@ void cet_disable_free_shstk(struct task_struct *p);
+ int cet_verify_rstor_token(bool ia32, unsigned long ssp, unsigned long *new_ssp);
+ void cet_restore_signal(struct sc_ext *sc);
  int cet_setup_signal(bool ia32, unsigned long rstor, struct sc_ext *sc);
 +int cet_setup_ibt(void);
 +void cet_disable_ibt(void);
@@ -72,7 +72,7 @@ index a0e1b24cfa02..52c9c07cfacc 100644
  
  #endif /* _ASM_X86_DISABLED_FEATURES_H */
 diff --git a/arch/x86/kernel/cet.c b/arch/x86/kernel/cet.c
-index 646cb05b5896..3ea81bb32c8e 100644
+index c1b9b540c03e..1782b905b705 100644
 --- a/arch/x86/kernel/cet.c
 +++ b/arch/x86/kernel/cet.c
 @@ -13,6 +13,8 @@
@@ -84,7 +84,7 @@ index 646cb05b5896..3ea81bb32c8e 100644
  #include <asm/msr.h>
  #include <asm/user.h>
  #include <asm/fpu/internal.h>
-@@ -360,3 +362,34 @@ int cet_setup_signal(bool ia32, unsigned long rstor_addr, struct sc_ext *sc_ext)
+@@ -354,3 +356,34 @@ int cet_setup_signal(bool ia32, unsigned long rstor_addr, struct sc_ext *sc_ext)
  
  	return 0;
  }
@@ -174,5 +174,5 @@ index a0e1b24cfa02..52c9c07cfacc 100644
  
  #endif /* _ASM_X86_DISABLED_FEATURES_H */
 -- 
-2.26.1
+2.26.2
 
diff --git a/0039-x86-cet-ibt-Handle-signals-for-Indirect-Branch-Track.patch b/0039-x86-cet-ibt-Handle-signals-for-Indirect-Branch-Track.patch
index 0f63bec88..ad2156da8 100644
--- a/0039-x86-cet-ibt-Handle-signals-for-Indirect-Branch-Track.patch
+++ b/0039-x86-cet-ibt-Handle-signals-for-Indirect-Branch-Track.patch
@@ -1,7 +1,7 @@
-From 3f46fb1a263e51d77446fe5b8432230f9307960d Mon Sep 17 00:00:00 2001
+From c34135cf7596c5bf22455a6281f3eaf45f549b52 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 28 May 2019 12:29:14 -0700
-Subject: [PATCH 39/46] x86/cet/ibt: Handle signals for Indirect Branch
+Subject: [PATCH 39/47] x86/cet/ibt: Handle signals for Indirect Branch
  Tracking
 
 Indirect Branch Tracking setting does not change in signal delivering or
@@ -12,20 +12,20 @@ starts.
 WAIT_ENDBR status can be read from MSR_IA32_U_CET.  It is reset for signal
 delivering, but preserved on a task's stack and restored for sigreturn.
 
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
+
 v9:
 - Fix missing WAIT_ENDBR in signal handling.
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 ---
  arch/x86/kernel/cet.c        | 27 +++++++++++++++++++++++++--
  arch/x86/kernel/fpu/signal.c |  8 +++++---
  2 files changed, 30 insertions(+), 5 deletions(-)
 
 diff --git a/arch/x86/kernel/cet.c b/arch/x86/kernel/cet.c
-index 3ea81bb32c8e..a8a8c117f1e0 100644
+index 1782b905b705..92b8730c0b08 100644
 --- a/arch/x86/kernel/cet.c
 +++ b/arch/x86/kernel/cet.c
-@@ -312,6 +312,13 @@ int cet_restore_signal(bool ia32, struct sc_ext *sc_ext)
+@@ -306,6 +306,13 @@ void cet_restore_signal(struct sc_ext *sc_ext)
  		msr_val |= MSR_IA32_CET_SHSTK_EN;
  	}
  
@@ -39,7 +39,7 @@ index 3ea81bb32c8e..a8a8c117f1e0 100644
  	if (test_thread_flag(TIF_NEED_FPU_LOAD))
  		cet_user_state->user_cet = msr_val;
  	else
-@@ -354,9 +361,25 @@ int cet_setup_signal(bool ia32, unsigned long rstor_addr, struct sc_ext *sc_ext)
+@@ -348,9 +355,25 @@ int cet_setup_signal(bool ia32, unsigned long rstor_addr, struct sc_ext *sc_ext)
  		sc_ext->ssp = new_ssp;
  	}
  
@@ -68,10 +68,10 @@ index 3ea81bb32c8e..a8a8c117f1e0 100644
  	}
  
 diff --git a/arch/x86/kernel/fpu/signal.c b/arch/x86/kernel/fpu/signal.c
-index 8862d3edbf34..af047395d14a 100644
+index 95ee76d08971..b6ea9b0e0c0b 100644
 --- a/arch/x86/kernel/fpu/signal.c
 +++ b/arch/x86/kernel/fpu/signal.c
-@@ -57,7 +57,8 @@ int save_cet_to_sigframe(void __user *fp, unsigned long restorer, int is_ia32)
+@@ -57,7 +57,8 @@ int save_cet_to_sigframe(int ia32, void __user *fp, unsigned long restorer)
  {
  	int err = 0;
  
@@ -81,9 +81,9 @@ index 8862d3edbf34..af047395d14a 100644
  		return 0;
  
  	if (fp) {
-@@ -87,7 +88,8 @@ static int restore_cet_from_sigframe(int is_ia32, void __user *fp)
- {
- 	int err = 0;
+@@ -89,7 +90,8 @@ static int get_cet_from_sigframe(int ia32, void __user *fp, struct sc_ext *ext)
+ 
+ 	memset(ext, 0, sizeof(*ext));
  
 -	if (!current->thread.cet.shstk_size)
 +	if (!current->thread.cet.shstk_size &&
@@ -91,7 +91,7 @@ index 8862d3edbf34..af047395d14a 100644
  		return 0;
  
  	if (fp) {
-@@ -555,7 +557,7 @@ static unsigned long fpu__alloc_sigcontext_ext(unsigned long sp)
+@@ -560,7 +562,7 @@ static unsigned long fpu__alloc_sigcontext_ext(unsigned long sp)
  	 * sigcontext_ext is at: fpu + fpu_user_xstate_size +
  	 * FP_XSTATE_MAGIC2_SIZE, then aligned to 8.
  	 */
@@ -101,5 +101,5 @@ index 8862d3edbf34..af047395d14a 100644
  
  	return sp;
 -- 
-2.26.1
+2.26.2
 
diff --git a/0040-x86-cet-ibt-ELF-header-parsing-for-Indirect-Branch-T.patch b/0040-x86-cet-ibt-ELF-header-parsing-for-Indirect-Branch-T.patch
index b337a6f59..8f70193f9 100644
--- a/0040-x86-cet-ibt-ELF-header-parsing-for-Indirect-Branch-T.patch
+++ b/0040-x86-cet-ibt-ELF-header-parsing-for-Indirect-Branch-T.patch
@@ -1,22 +1,22 @@
-From 3fa213a8f9697559db1637bfeb538abdcc43b971 Mon Sep 17 00:00:00 2001
+From b3b1e0792fdb15d5d2aafee0aed105aebbc7d377 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Tue, 30 Apr 2019 15:16:22 -0700
-Subject: [PATCH 40/46] x86/cet/ibt: ELF header parsing for Indirect Branch
+Subject: [PATCH 40/47] x86/cet/ibt: ELF header parsing for Indirect Branch
  Tracking
 
 Update arch_setup_elf_property() for Indirect Branch Tracking.
 
+Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
+
 v9:
 - Change cpu_feature_enabled() to static_cpu_has().
-
-Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 ---
  arch/x86/Kconfig             | 2 ++
  arch/x86/kernel/process_64.c | 8 ++++++++
  2 files changed, 10 insertions(+)
 
 diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
-index e769a55e07ed..283ad77e0eb0 100644
+index d45fbdfe61e7..1a7e077ab336 100644
 --- a/arch/x86/Kconfig
 +++ b/arch/x86/Kconfig
 @@ -1989,6 +1989,8 @@ config X86_INTEL_BRANCH_TRACKING_USER
@@ -48,5 +48,5 @@ index 93ba4afd0c19..b7ab2030010b 100644
  }
  #endif
 -- 
-2.26.1
+2.26.2
 
diff --git a/0041-x86-cet-ibt-Add-arch_prctl-functions-for-Indirect-Br.patch b/0041-x86-cet-ibt-Add-arch_prctl-functions-for-Indirect-Br.patch
index 2190784eb..552943948 100644
--- a/0041-x86-cet-ibt-Add-arch_prctl-functions-for-Indirect-Br.patch
+++ b/0041-x86-cet-ibt-Add-arch_prctl-functions-for-Indirect-Br.patch
@@ -1,7 +1,7 @@
-From 2fa078b6e28d1feae5bd13e9cfa404c54a7f8801 Mon Sep 17 00:00:00 2001
+From a7482b9bac2cb5857679330b3a561d75018fdc35 Mon Sep 17 00:00:00 2001
 From: "H.J. Lu" <hjl.tools@gmail.com>
 Date: Tue, 21 Aug 2018 14:13:05 -0700
-Subject: [PATCH 41/46] x86/cet/ibt: Add arch_prctl functions for Indirect
+Subject: [PATCH 41/47] x86/cet/ibt: Add arch_prctl functions for Indirect
  Branch Tracking
 
 Update ARCH_X86_CET_STATUS and ARCH_X86_CET_DISABLE for Indirect Branch
@@ -10,23 +10,24 @@ Tracking.
 Signed-off-by: H.J. Lu <hjl.tools@gmail.com>
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 ---
- arch/x86/kernel/cet_prctl.c | 7 ++++++-
- 1 file changed, 6 insertions(+), 1 deletion(-)
+ arch/x86/kernel/cet_prctl.c | 8 +++++++-
+ 1 file changed, 7 insertions(+), 1 deletion(-)
 
 diff --git a/arch/x86/kernel/cet_prctl.c b/arch/x86/kernel/cet_prctl.c
-index 0b4df3cbe2de..c3c8de3b0321 100644
+index 0139c48f2215..a8e68fefd524 100644
 --- a/arch/x86/kernel/cet_prctl.c
 +++ b/arch/x86/kernel/cet_prctl.c
-@@ -20,6 +20,8 @@ static int handle_get_status(u64 arg2)
+@@ -23,6 +23,9 @@ static int handle_get_status(u64 arg2)
+ 		buf[2] = (u64)cet->shstk_size;
+ 	}
  
- 	if (cet->shstk_size)
- 		features |= GNU_PROPERTY_X86_FEATURE_1_SHSTK;
 +	if (cet->ibt_enabled)
-+		features |= GNU_PROPERTY_X86_FEATURE_1_IBT;
++		buf[0] |= GNU_PROPERTY_X86_FEATURE_1_IBT;
++
+ 	return copy_to_user((u64 __user *)arg2, buf, sizeof(buf));
+ }
  
- 	buf[0] = (u64)features;
- 	buf[1] = (u64)cet->shstk_base;
-@@ -60,7 +62,8 @@ int prctl_cet(int option, u64 arg2)
+@@ -60,7 +63,8 @@ int prctl_cet(int option, u64 arg2)
  	if (option == ARCH_X86_CET_STATUS)
  		return handle_get_status(arg2);
  
@@ -36,7 +37,7 @@ index 0b4df3cbe2de..c3c8de3b0321 100644
  		return -EINVAL;
  
  	cet = &current->thread.cet;
-@@ -71,6 +74,8 @@ int prctl_cet(int option, u64 arg2)
+@@ -71,6 +75,8 @@ int prctl_cet(int option, u64 arg2)
  			return -EPERM;
  		if (arg2 & GNU_PROPERTY_X86_FEATURE_1_SHSTK)
  			cet_disable_free_shstk(current);
@@ -46,5 +47,5 @@ index 0b4df3cbe2de..c3c8de3b0321 100644
  		return 0;
  
 -- 
-2.26.1
+2.26.2
 
diff --git a/0042-x86-cet-Add-PTRACE-interface-for-CET.patch b/0042-x86-cet-Add-PTRACE-interface-for-CET.patch
index 0380a048a..cc60750e1 100644
--- a/0042-x86-cet-Add-PTRACE-interface-for-CET.patch
+++ b/0042-x86-cet-Add-PTRACE-interface-for-CET.patch
@@ -1,7 +1,7 @@
-From 51da9e418a3333e45a06b1fd91ea8d49e8a1531a Mon Sep 17 00:00:00 2001
+From 0e216686d24cd1eb195e46f69c413d69d1dbd4d5 Mon Sep 17 00:00:00 2001
 From: Yu-cheng Yu <yu-cheng.yu@intel.com>
 Date: Mon, 23 Apr 2018 12:55:13 -0700
-Subject: [PATCH 42/46] x86/cet: Add PTRACE interface for CET
+Subject: [PATCH 42/47] x86/cet: Add PTRACE interface for CET
 
 Add REGSET_CET64/REGSET_CET32 to get/set CET MSRs:
 
@@ -10,11 +10,11 @@ Add REGSET_CET64/REGSET_CET32 to get/set CET MSRs:
 
 Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
 ---
- arch/x86/include/asm/fpu/regset.h |  7 +++---
- arch/x86/kernel/fpu/regset.c      | 41 +++++++++++++++++++++++++++++++
- arch/x86/kernel/ptrace.c          | 16 ++++++++++++
+ arch/x86/include/asm/fpu/regset.h |  7 ++---
+ arch/x86/kernel/fpu/regset.c      | 45 +++++++++++++++++++++++++++++++
+ arch/x86/kernel/ptrace.c          | 16 +++++++++++
  include/uapi/linux/elf.h          |  1 +
- 4 files changed, 62 insertions(+), 3 deletions(-)
+ 4 files changed, 66 insertions(+), 3 deletions(-)
 
 diff --git a/arch/x86/include/asm/fpu/regset.h b/arch/x86/include/asm/fpu/regset.h
 index d5bdffb9d27f..edad0d889084 100644
@@ -37,10 +37,10 @@ index d5bdffb9d27f..edad0d889084 100644
  /*
   * xstateregs_active == regset_fpregs_active. Please refer to the comment
 diff --git a/arch/x86/kernel/fpu/regset.c b/arch/x86/kernel/fpu/regset.c
-index bd1d0649f8ce..21df3df7ff52 100644
+index bd1d0649f8ce..dcb86ccd2b7e 100644
 --- a/arch/x86/kernel/fpu/regset.c
 +++ b/arch/x86/kernel/fpu/regset.c
-@@ -156,6 +156,47 @@ int xstateregs_set(struct task_struct *target, const struct user_regset *regset,
+@@ -156,6 +156,51 @@ int xstateregs_set(struct task_struct *target, const struct user_regset *regset,
  	return ret;
  }
  
@@ -63,9 +63,11 @@ index bd1d0649f8ce..21df3df7ff52 100644
 +	if (!boot_cpu_has(X86_FEATURE_SHSTK))
 +		return -ENODEV;
 +
++	fpu__prepare_read(fpu);
 +	cetregs = get_xsave_addr(&fpu->state.xsave, XFEATURE_CET_USER);
++	if (!cetregs)
++		return -EFAULT;
 +
-+	fpu__prepare_read(fpu);
 +	return user_regset_copyout(&pos, &count, &kbuf, &ubuf, cetregs, 0, -1);
 +}
 +
@@ -79,9 +81,11 @@ index bd1d0649f8ce..21df3df7ff52 100644
 +	if (!boot_cpu_has(X86_FEATURE_SHSTK))
 +		return -ENODEV;
 +
++	fpu__prepare_write(fpu);
 +	cetregs = get_xsave_addr(&fpu->state.xsave, XFEATURE_CET_USER);
++	if (!cetregs)
++		return -EFAULT;
 +
-+	fpu__prepare_write(fpu);
 +	return user_regset_copyin(&pos, &count, &kbuf, &ubuf, cetregs, 0, -1);
 +}
 +
@@ -143,5 +147,5 @@ index 518651708d8f..793f171c37c2 100644
  #define NT_S390_TIMER	0x301		/* s390 timer register */
  #define NT_S390_TODCMP	0x302		/* s390 TOD clock comparator register */
 -- 
-2.26.1
+2.26.2
 
diff --git a/0044-x86-vdso-32-Add-ENDBR32-to-__kernel_vsyscall-entry-p.patch b/0043-x86-vdso-32-Add-ENDBR32-to-__kernel_vsyscall-entry-p.patch
similarity index 86%
rename from 0044-x86-vdso-32-Add-ENDBR32-to-__kernel_vsyscall-entry-p.patch
rename to 0043-x86-vdso-32-Add-ENDBR32-to-__kernel_vsyscall-entry-p.patch
index b453b5c30..b91b73848 100644
--- a/0044-x86-vdso-32-Add-ENDBR32-to-__kernel_vsyscall-entry-p.patch
+++ b/0043-x86-vdso-32-Add-ENDBR32-to-__kernel_vsyscall-entry-p.patch
@@ -1,7 +1,7 @@
-From 8d971bbd8af2317d560d2cac27e958838d06d791 Mon Sep 17 00:00:00 2001
+From 10486539dac89628be1de5efeda613c6a5f5c554 Mon Sep 17 00:00:00 2001
 From: "H.J. Lu" <hjl.tools@gmail.com>
 Date: Fri, 28 Sep 2018 06:21:50 -0700
-Subject: [PATCH 44/46] x86/vdso/32: Add ENDBR32 to __kernel_vsyscall entry
+Subject: [PATCH 43/47] x86/vdso/32: Add ENDBR32 to __kernel_vsyscall entry
  point
 
 Add ENDBR32 to __kernel_vsyscall entry point.
@@ -28,5 +28,5 @@ index de1fff7188aa..5cf74ebd4746 100644
  	 * Reshuffle regs so that all of any of the entry instructions
  	 * will preserve enough state.
 -- 
-2.26.1
+2.26.2
 
diff --git a/0045-x86-vdso-Insert-endbr32-endbr64-to-vDSO.patch b/0044-x86-vdso-Insert-endbr32-endbr64-to-vDSO.patch
similarity index 89%
rename from 0045-x86-vdso-Insert-endbr32-endbr64-to-vDSO.patch
rename to 0044-x86-vdso-Insert-endbr32-endbr64-to-vDSO.patch
index cc70dc7a2..fe6e9c08b 100644
--- a/0045-x86-vdso-Insert-endbr32-endbr64-to-vDSO.patch
+++ b/0044-x86-vdso-Insert-endbr32-endbr64-to-vDSO.patch
@@ -1,7 +1,7 @@
-From dd790296beabad3216cc1408de9c4829f6e4d8ee Mon Sep 17 00:00:00 2001
+From 0ecedbdfed4227515c63bfa3ea99d81cfef99cd7 Mon Sep 17 00:00:00 2001
 From: "H.J. Lu" <hjl.tools@gmail.com>
 Date: Fri, 16 Mar 2018 04:18:48 -0700
-Subject: [PATCH 45/46] x86/vdso: Insert endbr32/endbr64 to vDSO
+Subject: [PATCH 44/47] x86/vdso: Insert endbr32/endbr64 to vDSO
 
 When Indirect Branch Tracking (IBT) is enabled, vDSO functions may be
 called indirectly, and must have ENDBR32 or ENDBR64 as the first
@@ -31,5 +31,5 @@ index 433a1259f61d..6de3493acfe4 100644
  $(obj)/%.so: $(obj)/%.so.dbg FORCE
  	$(call if_changed,objcopy)
 -- 
-2.26.1
+2.26.2
 
diff --git a/0046-x86-Disallow-vsyscall-emulation-when-CET-is-enabled.patch b/0045-x86-Disallow-vsyscall-emulation-when-CET-is-enabled.patch
similarity index 90%
rename from 0046-x86-Disallow-vsyscall-emulation-when-CET-is-enabled.patch
rename to 0045-x86-Disallow-vsyscall-emulation-when-CET-is-enabled.patch
index 8559423cf..744de00c2 100644
--- a/0046-x86-Disallow-vsyscall-emulation-when-CET-is-enabled.patch
+++ b/0045-x86-Disallow-vsyscall-emulation-when-CET-is-enabled.patch
@@ -1,7 +1,7 @@
-From e277d2d98b2eef754fa0ee4a4d94c6e2913d169f Mon Sep 17 00:00:00 2001
+From e9ee6e6b4a877122a190e5927f78b40aa31cb26a Mon Sep 17 00:00:00 2001
 From: "H.J. Lu" <hjl.tools@gmail.com>
 Date: Wed, 29 Jan 2020 08:44:11 -0800
-Subject: [PATCH 46/46] x86: Disallow vsyscall emulation when CET is enabled
+Subject: [PATCH 45/47] x86: Disallow vsyscall emulation when CET is enabled
 
 Emulation of the legacy vsyscall page is required by some programs built
 before 2013.  Newer programs after 2013 don't use it.  Disallow vsyscall
@@ -15,7 +15,7 @@ Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
  1 file changed, 6 insertions(+), 2 deletions(-)
 
 diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
-index 283ad77e0eb0..86c224f670e8 100644
+index 1a7e077ab336..2400cf2ca99c 100644
 --- a/arch/x86/Kconfig
 +++ b/arch/x86/Kconfig
 @@ -1210,7 +1210,7 @@ config X86_ESPFIX64
@@ -55,5 +55,5 @@ index 283ad77e0eb0..86c224f670e8 100644
  		bool "Full emulation"
  		help
 -- 
-2.26.1
+2.26.2
 
diff --git a/0046-powerpc-Keep-.rela-sections-when-CONFIG_RELOCATABLE-.patch b/0046-powerpc-Keep-.rela-sections-when-CONFIG_RELOCATABLE-.patch
new file mode 100644
index 000000000..7b598817d
--- /dev/null
+++ b/0046-powerpc-Keep-.rela-sections-when-CONFIG_RELOCATABLE-.patch
@@ -0,0 +1,56 @@
+From fddad324894961199f98da7f9d964ee918e3af4d Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Mon, 27 Apr 2020 14:04:48 -0700
+Subject: [PATCH 46/47] powerpc: Keep .rela* sections when CONFIG_RELOCATABLE
+ is defined
+
+arch/powerpc/kernel/vmlinux.lds.S has
+
+ #ifdef CONFIG_RELOCATABLE
+ ...
+        .rela.dyn : AT(ADDR(.rela.dyn) - LOAD_OFFSET)
+        {
+                __rela_dyn_start = .;
+                *(.rela*)
+        }
+ #endif
+ ...
+        DISCARDS
+        /DISCARD/ : {
+                *(*.EMB.apuinfo)
+                *(.glink .iplt .plt .rela* .comment)
+                *(.gnu.version*)
+                *(.gnu.attributes)
+                *(.eh_frame)
+        }
+
+Since .rela* sections are needed when CONFIG_RELOCATABLE is defined,
+don't discard .rela* sections if CONFIG_RELOCATABLE is defined.
+
+Signed-off-by: H.J. Lu <hjl.tools@gmail.com>
+Acked-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
+---
+ arch/powerpc/kernel/vmlinux.lds.S | 5 ++++-
+ 1 file changed, 4 insertions(+), 1 deletion(-)
+
+diff --git a/arch/powerpc/kernel/vmlinux.lds.S b/arch/powerpc/kernel/vmlinux.lds.S
+index 31a0f201fb6f..4ba07734a210 100644
+--- a/arch/powerpc/kernel/vmlinux.lds.S
++++ b/arch/powerpc/kernel/vmlinux.lds.S
+@@ -366,9 +366,12 @@ SECTIONS
+ 	DISCARDS
+ 	/DISCARD/ : {
+ 		*(*.EMB.apuinfo)
+-		*(.glink .iplt .plt .rela* .comment)
++		*(.glink .iplt .plt .comment)
+ 		*(.gnu.version*)
+ 		*(.gnu.attributes)
+ 		*(.eh_frame)
++#ifndef CONFIG_RELOCATABLE
++		*(.rela*)
++#endif
+ 	}
+ }
+-- 
+2.26.2
+
diff --git a/0043-Discard-.note.gnu.property-sections-in-generic-NOTES.patch b/0047-Discard-.note.gnu.property-sections-in-generic-NOTES.patch
similarity index 94%
rename from 0043-Discard-.note.gnu.property-sections-in-generic-NOTES.patch
rename to 0047-Discard-.note.gnu.property-sections-in-generic-NOTES.patch
index fba56501a..3cf69a074 100644
--- a/0043-Discard-.note.gnu.property-sections-in-generic-NOTES.patch
+++ b/0047-Discard-.note.gnu.property-sections-in-generic-NOTES.patch
@@ -1,7 +1,7 @@
-From 31c6689632b4c2f0ca12d4b027e7ce5a13b82009 Mon Sep 17 00:00:00 2001
+From 4d25a79fb639bfcd424a00d87dab6b53825f864a Mon Sep 17 00:00:00 2001
 From: "H.J. Lu" <hjl.tools@gmail.com>
 Date: Thu, 30 Jan 2020 12:39:09 -0800
-Subject: [PATCH 43/46] Discard .note.gnu.property sections in generic NOTES
+Subject: [PATCH 47/47] Discard .note.gnu.property sections in generic NOTES
 
 With the command-line option, -mx86-used-note=yes, the x86 assembler
 in binutils 2.32 and above generates a program property note in a note
@@ -77,5 +77,5 @@ index 71e387a5fe90..95cd678428f4 100644
  		__start_notes = .;					\
  		KEEP(*(.note.*))					\
 -- 
-2.26.1
+2.26.2
 
diff --git a/kernel.spec b/kernel.spec
index 5d468a3b9..df889f67a 100644
--- a/kernel.spec
+++ b/kernel.spec
@@ -19,33 +19,34 @@ Patch200016: 0016-x86-mm-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_HW.patch
 Patch200017: 0017-x86-mm-Remove-_PAGE_DIRTY_HW-from-kernel-RO-pages.patch
 Patch200018: 0018-x86-mm-Introduce-_PAGE_COW.patch
 Patch200019: 0019-drm-i915-gvt-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_BITS.patch
-Patch200020: 0020-x86-mm-Update-pte_modify-and-pmd_modify-for-_PAGE_CO.patch
+Patch200020: 0020-x86-mm-Update-pte_modify-for-_PAGE_COW.patch
 Patch200021: 0021-x86-mm-Update-ptep_set_wrprotect-and-pmdp_set_wrprot.patch
-Patch200022: 0022-mm-Introduce-VM_SHSTK-for-Shadow-Stack-memory.patch
+Patch200022: 0022-mm-Introduce-VM_SHSTK-for-shadow-stack-memory.patch
 Patch200023: 0023-x86-mm-Shadow-Stack-page-fault-error-checking.patch
-Patch200024: 0024-x86-mm-Update-is_cow_mapping-and-maybe_mkwrite-for-s.patch
-Patch200025: 0025-mm-Update-do_anonymous_page-and-do_numa_page.patch
-Patch200026: 0026-mm-Update-can_follow_write_pte-for-Shadow-Stack.patch
-Patch200027: 0027-x86-mm-Add-guard-pages-around-a-Shadow-Stack.patch
-Patch200028: 0028-mm-mmap-Add-Shadow-Stack-pages-to-memory-accounting.patch
-Patch200029: 0029-x86-cet-shstk-User-mode-Shadow-Stack-support.patch
-Patch200030: 0030-x86-cet-shstk-Handle-signals-for-Shadow-Stack.patch
+Patch200024: 0024-x86-mm-Update-maybe_mkwrite-for-shadow-stack.patch
+Patch200025: 0025-mm-Fixup-places-that-call-pte_mkwrite-directly.patch
+Patch200026: 0026-mm-Add-guard-pages-around-a-shadow-stack.patch
+Patch200027: 0027-mm-mmap-Add-shadow-stack-pages-to-memory-accounting.patch
+Patch200028: 0028-mm-Update-can_follow_write_pte-for-shadow-stack.patch
+Patch200029: 0029-x86-cet-shstk-User-mode-shadow-stack-support.patch
+Patch200030: 0030-x86-cet-shstk-Handle-signals-for-shadow-stack.patch
 Patch200031: 0031-ELF-UAPI-and-Kconfig-additions-for-ELF-program-prope.patch
 Patch200032: 0032-ELF-Add-ELF-program-property-parsing-support.patch
 Patch200033: 0033-ELF-Introduce-arch_setup_elf_property.patch
-Patch200034: 0034-x86-cet-shstk-ELF-header-parsing-for-Shadow-Stack.patch
-Patch200035: 0035-x86-cet-shstk-Handle-thread-Shadow-Stack.patch
-Patch200036: 0036-x86-cet-shstk-Add-arch_prctl-functions-for-Shadow-St.patch
+Patch200034: 0034-x86-cet-shstk-ELF-header-parsing-for-shadow-stack.patch
+Patch200035: 0035-x86-cet-shstk-Handle-thread-shadow-stack.patch
+Patch200036: 0036-x86-cet-shstk-Add-arch_prctl-functions-for-shadow-st.patch
 Patch200037: 0037-x86-cet-ibt-Add-Kconfig-option-for-user-mode-Indirec.patch
 Patch200038: 0038-x86-cet-ibt-User-mode-Indirect-Branch-Tracking-suppo.patch
 Patch200039: 0039-x86-cet-ibt-Handle-signals-for-Indirect-Branch-Track.patch
 Patch200040: 0040-x86-cet-ibt-ELF-header-parsing-for-Indirect-Branch-T.patch
 Patch200041: 0041-x86-cet-ibt-Add-arch_prctl-functions-for-Indirect-Br.patch
 Patch200042: 0042-x86-cet-Add-PTRACE-interface-for-CET.patch
-Patch200043: 0043-Discard-.note.gnu.property-sections-in-generic-NOTES.patch
-Patch200044: 0044-x86-vdso-32-Add-ENDBR32-to-__kernel_vsyscall-entry-p.patch
-Patch200045: 0045-x86-vdso-Insert-endbr32-endbr64-to-vDSO.patch
-Patch200046: 0046-x86-Disallow-vsyscall-emulation-when-CET-is-enabled.patch
+Patch200043: 0043-x86-vdso-32-Add-ENDBR32-to-__kernel_vsyscall-entry-p.patch
+Patch200044: 0044-x86-vdso-Insert-endbr32-endbr64-to-vDSO.patch
+Patch200045: 0045-x86-Disallow-vsyscall-emulation-when-CET-is-enabled.patch
+Patch200046: 0046-powerpc-Keep-.rela-sections-when-CONFIG_RELOCATABLE-.patch
+Patch200047: 0047-Discard-.note.gnu.property-sections-in-generic-NOTES.patch
 
 # We have to override the new %%install behavior because, well... the kernel is special.
 %global __spec_install_pre %{___build_pre}
@@ -1434,33 +1435,35 @@ ApplyOptionalPatch 0016-x86-mm-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_HW.patch
 ApplyOptionalPatch 0017-x86-mm-Remove-_PAGE_DIRTY_HW-from-kernel-RO-pages.patch
 ApplyOptionalPatch 0018-x86-mm-Introduce-_PAGE_COW.patch
 ApplyOptionalPatch 0019-drm-i915-gvt-Change-_PAGE_DIRTY-to-_PAGE_DIRTY_BITS.patch
-ApplyOptionalPatch 0020-x86-mm-Update-pte_modify-and-pmd_modify-for-_PAGE_CO.patch
+ApplyOptionalPatch 0020-x86-mm-Update-pte_modify-for-_PAGE_COW.patch
 ApplyOptionalPatch 0021-x86-mm-Update-ptep_set_wrprotect-and-pmdp_set_wrprot.patch
-ApplyOptionalPatch 0022-mm-Introduce-VM_SHSTK-for-Shadow-Stack-memory.patch
+ApplyOptionalPatch 0022-mm-Introduce-VM_SHSTK-for-shadow-stack-memory.patch
 ApplyOptionalPatch 0023-x86-mm-Shadow-Stack-page-fault-error-checking.patch
-ApplyOptionalPatch 0024-x86-mm-Update-is_cow_mapping-and-maybe_mkwrite-for-s.patch
-ApplyOptionalPatch 0025-mm-Update-do_anonymous_page-and-do_numa_page.patch
-ApplyOptionalPatch 0026-mm-Update-can_follow_write_pte-for-Shadow-Stack.patch
-ApplyOptionalPatch 0027-x86-mm-Add-guard-pages-around-a-Shadow-Stack.patch
-ApplyOptionalPatch 0028-mm-mmap-Add-Shadow-Stack-pages-to-memory-accounting.patch
-ApplyOptionalPatch 0029-x86-cet-shstk-User-mode-Shadow-Stack-support.patch
-ApplyOptionalPatch 0030-x86-cet-shstk-Handle-signals-for-Shadow-Stack.patch
+ApplyOptionalPatch 0024-x86-mm-Update-maybe_mkwrite-for-shadow-stack.patch
+ApplyOptionalPatch 0025-mm-Fixup-places-that-call-pte_mkwrite-directly.patch
+ApplyOptionalPatch 0026-mm-Add-guard-pages-around-a-shadow-stack.patch
+ApplyOptionalPatch 0027-mm-mmap-Add-shadow-stack-pages-to-memory-accounting.patch
+ApplyOptionalPatch 0028-mm-Update-can_follow_write_pte-for-shadow-stack.patch
+ApplyOptionalPatch 0029-x86-cet-shstk-User-mode-shadow-stack-support.patch
+ApplyOptionalPatch 0030-x86-cet-shstk-Handle-signals-for-shadow-stack.patch
 ApplyOptionalPatch 0031-ELF-UAPI-and-Kconfig-additions-for-ELF-program-prope.patch
 ApplyOptionalPatch 0032-ELF-Add-ELF-program-property-parsing-support.patch
 ApplyOptionalPatch 0033-ELF-Introduce-arch_setup_elf_property.patch
-ApplyOptionalPatch 0034-x86-cet-shstk-ELF-header-parsing-for-Shadow-Stack.patch
-ApplyOptionalPatch 0035-x86-cet-shstk-Handle-thread-Shadow-Stack.patch
-ApplyOptionalPatch 0036-x86-cet-shstk-Add-arch_prctl-functions-for-Shadow-St.patch
+ApplyOptionalPatch 0034-x86-cet-shstk-ELF-header-parsing-for-shadow-stack.patch
+ApplyOptionalPatch 0035-x86-cet-shstk-Handle-thread-shadow-stack.patch
+ApplyOptionalPatch 0036-x86-cet-shstk-Add-arch_prctl-functions-for-shadow-st.patch
 ApplyOptionalPatch 0037-x86-cet-ibt-Add-Kconfig-option-for-user-mode-Indirec.patch
 ApplyOptionalPatch 0038-x86-cet-ibt-User-mode-Indirect-Branch-Tracking-suppo.patch
 ApplyOptionalPatch 0039-x86-cet-ibt-Handle-signals-for-Indirect-Branch-Track.patch
 ApplyOptionalPatch 0040-x86-cet-ibt-ELF-header-parsing-for-Indirect-Branch-T.patch
 ApplyOptionalPatch 0041-x86-cet-ibt-Add-arch_prctl-functions-for-Indirect-Br.patch
 ApplyOptionalPatch 0042-x86-cet-Add-PTRACE-interface-for-CET.patch
-ApplyOptionalPatch 0043-Discard-.note.gnu.property-sections-in-generic-NOTES.patch
-ApplyOptionalPatch 0044-x86-vdso-32-Add-ENDBR32-to-__kernel_vsyscall-entry-p.patch
-ApplyOptionalPatch 0045-x86-vdso-Insert-endbr32-endbr64-to-vDSO.patch
-ApplyOptionalPatch 0046-x86-Disallow-vsyscall-emulation-when-CET-is-enabled.patch
+ApplyOptionalPatch 0043-x86-vdso-32-Add-ENDBR32-to-__kernel_vsyscall-entry-p.patch
+ApplyOptionalPatch 0044-x86-vdso-Insert-endbr32-endbr64-to-vDSO.patch
+ApplyOptionalPatch 0045-x86-Disallow-vsyscall-emulation-when-CET-is-enabled.patch
+ApplyOptionalPatch 0046-powerpc-Keep-.rela-sections-when-CONFIG_RELOCATABLE-.patch
+ApplyOptionalPatch 0047-Discard-.note.gnu.property-sections-in-generic-NOTES.patch
+
 # END OF PATCH APPLICATIONS
 
 # Any further pre-build tree manipulations happen here.
-- 
2.26.2

